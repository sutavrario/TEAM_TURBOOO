"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var version = "2.17.0";

const DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS = 60;

const DEFAULT_POPUP_CONFIG_OPTIONS = {
    timeoutInSeconds: DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS
};

const DEFAULT_SILENT_TOKEN_RETRY_COUNT = 3;

const CLEANUP_IFRAME_TIMEOUT_IN_SECONDS = 2;

const DEFAULT_FETCH_TIMEOUT_MS = 1e4;

const CACHE_LOCATION_MEMORY = "memory";

const MISSING_REFRESH_TOKEN_ERROR_MESSAGE = "Missing Refresh Token";

const INVALID_REFRESH_TOKEN_ERROR_MESSAGE = "invalid refresh token";

const USER_BLOCKED_ERROR_MESSAGE = "user is blocked";

const MFA_STEP_UP_ERROR_DESCRIPTION = "Multifactor authentication required";

const DEFAULT_SCOPE = "openid profile email";

const DEFAULT_SESSION_CHECK_EXPIRY_DAYS = 1;

const DEFAULT_AUTH0_CLIENT = {
    name: "auth0-spa-js",
    version: version
};

const DEFAULT_NOW_PROVIDER = () => Date.now();

const DEFAULT_AUDIENCE = "default";

class GenericError extends Error {
    constructor(error, error_description) {
        super(error_description);
        this.error = error;
        this.error_description = error_description;
        Object.setPrototypeOf(this, GenericError.prototype);
    }
    static fromPayload(_ref) {
        let {error: error, error_description: error_description} = _ref;
        return new GenericError(error, error_description);
    }
}

class AuthenticationError extends GenericError {
    constructor(error, error_description, state) {
        let appState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        super(error, error_description);
        this.state = state;
        this.appState = appState;
        Object.setPrototypeOf(this, AuthenticationError.prototype);
    }
}

class ConnectError extends GenericError {
    constructor(error, error_description, connection, state) {
        let appState = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        super(error, error_description);
        this.connection = connection;
        this.state = state;
        this.appState = appState;
        Object.setPrototypeOf(this, ConnectError.prototype);
    }
}

class TimeoutError extends GenericError {
    constructor() {
        super("timeout", "Timeout");
        Object.setPrototypeOf(this, TimeoutError.prototype);
    }
}

class PopupTimeoutError extends TimeoutError {
    constructor(popup) {
        super();
        this.popup = popup;
        Object.setPrototypeOf(this, PopupTimeoutError.prototype);
    }
}

class PopupCancelledError extends GenericError {
    constructor(popup) {
        super("cancelled", "Popup closed");
        this.popup = popup;
        Object.setPrototypeOf(this, PopupCancelledError.prototype);
    }
}

class PopupOpenError extends GenericError {
    constructor() {
        super("popup_open", "Unable to open a popup for loginWithPopup - window.open returned `null`");
        Object.setPrototypeOf(this, PopupOpenError.prototype);
    }
}

class MfaRequiredError extends GenericError {
    constructor(error, error_description, mfa_token, mfa_requirements) {
        super(error, error_description);
        this.mfa_token = mfa_token;
        this.mfa_requirements = mfa_requirements;
        Object.setPrototypeOf(this, MfaRequiredError.prototype);
    }
}

class MissingRefreshTokenError extends GenericError {
    constructor(audience, scope) {
        super("missing_refresh_token", "Missing Refresh Token (audience: '".concat(valueOrEmptyString(audience, [ "default" ]), "', scope: '").concat(valueOrEmptyString(scope), "')"));
        this.audience = audience;
        this.scope = scope;
        Object.setPrototypeOf(this, MissingRefreshTokenError.prototype);
    }
}

class MissingScopesError extends GenericError {
    constructor(audience, scope) {
        super("missing_scopes", "Missing requested scopes after refresh (audience: '".concat(valueOrEmptyString(audience, [ "default" ]), "', missing scope: '").concat(valueOrEmptyString(scope), "')"));
        this.audience = audience;
        this.scope = scope;
        Object.setPrototypeOf(this, MissingScopesError.prototype);
    }
}

class UseDpopNonceError extends GenericError {
    constructor(newDpopNonce) {
        super("use_dpop_nonce", "Server rejected DPoP proof: wrong nonce");
        this.newDpopNonce = newDpopNonce;
        Object.setPrototypeOf(this, UseDpopNonceError.prototype);
    }
}

function valueOrEmptyString(value) {
    let exclude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return value && !exclude.includes(value) ? value : "";
}

const parseAuthenticationResult = queryString => {
    if (queryString.indexOf("#") > -1) {
        queryString = queryString.substring(0, queryString.indexOf("#"));
    }
    const searchParams = new URLSearchParams(queryString);
    return {
        state: searchParams.get("state"),
        code: searchParams.get("code") || undefined,
        connect_code: searchParams.get("connect_code") || undefined,
        error: searchParams.get("error") || undefined,
        error_description: searchParams.get("error_description") || undefined
    };
};

const runIframe = function runIframe(authorizeUrl, eventOrigin) {
    let timeoutInSeconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS;
    return new Promise(((res, rej) => {
        const iframe = window.document.createElement("iframe");
        iframe.setAttribute("width", "0");
        iframe.setAttribute("height", "0");
        iframe.style.display = "none";
        const removeIframe = () => {
            if (window.document.body.contains(iframe)) {
                window.document.body.removeChild(iframe);
                window.removeEventListener("message", _iframeEventHandler, false);
            }
        };
        let _iframeEventHandler;
        const timeoutSetTimeoutId = setTimeout((() => {
            rej(new TimeoutError);
            removeIframe();
        }), timeoutInSeconds * 1e3);
        _iframeEventHandler = function iframeEventHandler(e) {
            if (e.origin != eventOrigin) return;
            if (!e.data || e.data.type !== "authorization_response") return;
            const eventSource = e.source;
            if (eventSource) {
                eventSource.close();
            }
            e.data.response.error ? rej(GenericError.fromPayload(e.data.response)) : res(e.data.response);
            clearTimeout(timeoutSetTimeoutId);
            window.removeEventListener("message", _iframeEventHandler, false);
            setTimeout(removeIframe, CLEANUP_IFRAME_TIMEOUT_IN_SECONDS * 1e3);
        };
        window.addEventListener("message", _iframeEventHandler, false);
        window.document.body.appendChild(iframe);
        iframe.setAttribute("src", authorizeUrl);
    }));
};

const openPopup = url => {
    const width = 400;
    const height = 600;
    const left = window.screenX + (window.innerWidth - width) / 2;
    const top = window.screenY + (window.innerHeight - height) / 2;
    return window.open(url, "auth0:authorize:popup", "left=".concat(left, ",top=").concat(top, ",width=").concat(width, ",height=").concat(height, ",resizable,scrollbars=yes,status=1"));
};

const runPopup = config => new Promise(((resolve, reject) => {
    let _popupEventListener;
    const popupTimer = setInterval((() => {
        if (config.popup && config.popup.closed) {
            clearInterval(popupTimer);
            clearTimeout(timeoutId);
            window.removeEventListener("message", _popupEventListener, false);
            reject(new PopupCancelledError(config.popup));
        }
    }), 1e3);
    const timeoutId = setTimeout((() => {
        clearInterval(popupTimer);
        reject(new PopupTimeoutError(config.popup));
        window.removeEventListener("message", _popupEventListener, false);
    }), (config.timeoutInSeconds || DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS) * 1e3);
    _popupEventListener = function popupEventListener(e) {
        if (!e.data || e.data.type !== "authorization_response") {
            return;
        }
        clearTimeout(timeoutId);
        clearInterval(popupTimer);
        window.removeEventListener("message", _popupEventListener, false);
        if (config.closePopup !== false) {
            config.popup.close();
        }
        if (e.data.response.error) {
            return reject(GenericError.fromPayload(e.data.response));
        }
        resolve(e.data.response);
    };
    window.addEventListener("message", _popupEventListener);
}));

const getCrypto = () => window.crypto;

const createRandomString = () => {
    const charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
    let random = "";
    const randomValues = Array.from(getCrypto().getRandomValues(new Uint8Array(43)));
    randomValues.forEach((v => random += charset[v % charset.length]));
    return random;
};

const encode$2 = value => btoa(value);

const stripUndefined = params => Object.keys(params).filter((k => typeof params[k] !== "undefined")).reduce(((acc, key) => Object.assign(Object.assign({}, acc), {
    [key]: params[key]
})), {});

const ALLOWED_AUTH0CLIENT_PROPERTIES = [ {
    key: "name",
    type: [ "string" ]
}, {
    key: "version",
    type: [ "string", "number" ]
}, {
    key: "env",
    type: [ "object" ]
} ];

const stripAuth0Client = function stripAuth0Client(auth0Client) {
    let excludeEnv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return Object.keys(auth0Client).reduce(((acc, key) => {
        if (excludeEnv && key === "env") {
            return acc;
        }
        const allowedProperty = ALLOWED_AUTH0CLIENT_PROPERTIES.find((p => p.key === key));
        if (allowedProperty && allowedProperty.type.includes(typeof auth0Client[key])) {
            acc[key] = auth0Client[key];
        }
        return acc;
    }), {});
};

const createQueryParams = _a => {
    var {clientId: client_id} = _a, params = __rest(_a, [ "clientId" ]);
    return new URLSearchParams(stripUndefined(Object.assign({
        client_id: client_id
    }, params))).toString();
};

const sha256 = async s => {
    const digestOp = getCrypto().subtle.digest({
        name: "SHA-256"
    }, (new TextEncoder).encode(s));
    return await digestOp;
};

const urlEncodeB64 = input => {
    const b64Chars = {
        "+": "-",
        "/": "_",
        "=": ""
    };
    return input.replace(/[+/=]/g, (m => b64Chars[m]));
};

const decodeB64 = input => decodeURIComponent(atob(input).split("").map((c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))).join(""));

const urlDecodeB64 = input => decodeB64(input.replace(/_/g, "/").replace(/-/g, "+"));

const bufferToBase64UrlEncoded = input => {
    const ie11SafeInput = new Uint8Array(input);
    return urlEncodeB64(window.btoa(String.fromCharCode(...Array.from(ie11SafeInput))));
};

const validateCrypto = () => {
    if (!getCrypto()) {
        throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
    }
    if (typeof getCrypto().subtle === "undefined") {
        throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    }
};

const getDomain = domainUrl => {
    if (!/^https?:\/\//.test(domainUrl)) {
        return "https://".concat(domainUrl);
    }
    return domainUrl;
};

const getTokenIssuer = (issuer, domainUrl) => {
    if (issuer) {
        return issuer.startsWith("https://") ? issuer : "https://".concat(issuer, "/");
    }
    return "".concat(domainUrl, "/");
};

const parseNumber = value => {
    if (typeof value !== "string") {
        return value;
    }
    return parseInt(value, 10) || undefined;
};

const fromEntries = iterable => [ ...iterable ].reduce(((obj, _ref) => {
    let [key, val] = _ref;
    obj[key] = val;
    return obj;
}), {});

var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

var browserTabsLock = {};

var processLock = {};

Object.defineProperty(processLock, "__esModule", {
    value: true
});

var ProcessLocking = function() {
    function ProcessLocking() {
        var _this = this;
        this.locked = new Map;
        this.addToLocked = function(key, toAdd) {
            var callbacks = _this.locked.get(key);
            if (callbacks === undefined) {
                if (toAdd === undefined) {
                    _this.locked.set(key, []);
                } else {
                    _this.locked.set(key, [ toAdd ]);
                }
            } else {
                if (toAdd !== undefined) {
                    callbacks.unshift(toAdd);
                    _this.locked.set(key, callbacks);
                }
            }
        };
        this.isLocked = function(key) {
            return _this.locked.has(key);
        };
        this.lock = function(key) {
            return new Promise((function(resolve, reject) {
                if (_this.isLocked(key)) {
                    _this.addToLocked(key, resolve);
                } else {
                    _this.addToLocked(key);
                    resolve();
                }
            }));
        };
        this.unlock = function(key) {
            var callbacks = _this.locked.get(key);
            if (callbacks === undefined || callbacks.length === 0) {
                _this.locked.delete(key);
                return;
            }
            var toCall = callbacks.pop();
            _this.locked.set(key, callbacks);
            if (toCall !== undefined) {
                setTimeout(toCall, 0);
            }
        };
    }
    ProcessLocking.getInstance = function() {
        if (ProcessLocking.instance === undefined) {
            ProcessLocking.instance = new ProcessLocking;
        }
        return ProcessLocking.instance;
    };
    return ProcessLocking;
}();

function getLock() {
    return ProcessLocking.getInstance();
}

processLock.default = getLock;

var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P((function(resolve) {
                resolve(result.value);
            })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([ n, v ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
            0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [ op[0] & 2, t.value ];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;

              case 4:
                _.label++;
                return {
                    value: op[1],
                    done: false
                };

              case 5:
                _.label++;
                y = op[1];
                op = [ 0 ];
                continue;

              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;

              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                }
                if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [ 6, e ];
            y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};

var _this = commonjsGlobal;

Object.defineProperty(browserTabsLock, "__esModule", {
    value: true
});

var processLock_1 = processLock;

var LOCK_STORAGE_KEY = "browser-tabs-lock-key";

var DEFAULT_STORAGE_HANDLER = {
    key: function(index) {
        return __awaiter(_this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                throw new Error("Unsupported");
            }));
        }));
    },
    getItem: function(key) {
        return __awaiter(_this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                throw new Error("Unsupported");
            }));
        }));
    },
    clear: function() {
        return __awaiter(_this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                return [ 2, window.localStorage.clear() ];
            }));
        }));
    },
    removeItem: function(key) {
        return __awaiter(_this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                throw new Error("Unsupported");
            }));
        }));
    },
    setItem: function(key, value) {
        return __awaiter(_this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                throw new Error("Unsupported");
            }));
        }));
    },
    keySync: function(index) {
        return window.localStorage.key(index);
    },
    getItemSync: function(key) {
        return window.localStorage.getItem(key);
    },
    clearSync: function() {
        return window.localStorage.clear();
    },
    removeItemSync: function(key) {
        return window.localStorage.removeItem(key);
    },
    setItemSync: function(key, value) {
        return window.localStorage.setItem(key, value);
    }
};

function delay(milliseconds) {
    return new Promise((function(resolve) {
        return setTimeout(resolve, milliseconds);
    }));
}

function generateRandomString(length) {
    var CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
    var randomstring = "";
    for (var i = 0; i < length; i++) {
        var INDEX = Math.floor(Math.random() * CHARS.length);
        randomstring += CHARS[INDEX];
    }
    return randomstring;
}

function getLockId() {
    return Date.now().toString() + generateRandomString(15);
}

var SuperTokensLock = function() {
    function SuperTokensLock(storageHandler) {
        this.acquiredIatSet = new Set;
        this.storageHandler = undefined;
        this.id = getLockId();
        this.acquireLock = this.acquireLock.bind(this);
        this.releaseLock = this.releaseLock.bind(this);
        this.releaseLock__private__ = this.releaseLock__private__.bind(this);
        this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);
        this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);
        this.storageHandler = storageHandler;
        if (SuperTokensLock.waiters === undefined) {
            SuperTokensLock.waiters = [];
        }
    }
    SuperTokensLock.prototype.acquireLock = function(lockKey, timeout) {
        if (timeout === void 0) {
            timeout = 5e3;
        }
        return __awaiter(this, void 0, void 0, (function() {
            var iat, MAX_TIME, STORAGE_KEY, STORAGE, lockObj, TIMEOUT_KEY, lockObjPostDelay, parsedLockObjPostDelay;
            return __generator(this, (function(_a) {
                switch (_a.label) {
                  case 0:
                    iat = Date.now() + generateRandomString(4);
                    MAX_TIME = Date.now() + timeout;
                    STORAGE_KEY = LOCK_STORAGE_KEY + "-" + lockKey;
                    STORAGE = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                    _a.label = 1;

                  case 1:
                    if (!(Date.now() < MAX_TIME)) return [ 3, 8 ];
                    return [ 4, delay(30) ];

                  case 2:
                    _a.sent();
                    lockObj = STORAGE.getItemSync(STORAGE_KEY);
                    if (!(lockObj === null)) return [ 3, 5 ];
                    TIMEOUT_KEY = this.id + "-" + lockKey + "-" + iat;
                    return [ 4, delay(Math.floor(Math.random() * 25)) ];

                  case 3:
                    _a.sent();
                    STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({
                        id: this.id,
                        iat: iat,
                        timeoutKey: TIMEOUT_KEY,
                        timeAcquired: Date.now(),
                        timeRefreshed: Date.now()
                    }));
                    return [ 4, delay(30) ];

                  case 4:
                    _a.sent();
                    lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);
                    if (lockObjPostDelay !== null) {
                        parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);
                        if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {
                            this.acquiredIatSet.add(iat);
                            this.refreshLockWhileAcquired(STORAGE_KEY, iat);
                            return [ 2, true ];
                        }
                    }
                    return [ 3, 7 ];

                  case 5:
                    SuperTokensLock.lockCorrector(this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler);
                    return [ 4, this.waitForSomethingToChange(MAX_TIME) ];

                  case 6:
                    _a.sent();
                    _a.label = 7;

                  case 7:
                    iat = Date.now() + generateRandomString(4);
                    return [ 3, 1 ];

                  case 8:
                    return [ 2, false ];
                }
            }));
        }));
    };
    SuperTokensLock.prototype.refreshLockWhileAcquired = function(storageKey, iat) {
        return __awaiter(this, void 0, void 0, (function() {
            var _this = this;
            return __generator(this, (function(_a) {
                setTimeout((function() {
                    return __awaiter(_this, void 0, void 0, (function() {
                        var STORAGE, lockObj, parsedLockObj;
                        return __generator(this, (function(_a) {
                            switch (_a.label) {
                              case 0:
                                return [ 4, processLock_1.default().lock(iat) ];

                              case 1:
                                _a.sent();
                                if (!this.acquiredIatSet.has(iat)) {
                                    processLock_1.default().unlock(iat);
                                    return [ 2 ];
                                }
                                STORAGE = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                                lockObj = STORAGE.getItemSync(storageKey);
                                if (lockObj !== null) {
                                    parsedLockObj = JSON.parse(lockObj);
                                    parsedLockObj.timeRefreshed = Date.now();
                                    STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));
                                    processLock_1.default().unlock(iat);
                                } else {
                                    processLock_1.default().unlock(iat);
                                    return [ 2 ];
                                }
                                this.refreshLockWhileAcquired(storageKey, iat);
                                return [ 2 ];
                            }
                        }));
                    }));
                }), 1e3);
                return [ 2 ];
            }));
        }));
    };
    SuperTokensLock.prototype.waitForSomethingToChange = function(MAX_TIME) {
        return __awaiter(this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                switch (_a.label) {
                  case 0:
                    return [ 4, new Promise((function(resolve) {
                        var resolvedCalled = false;
                        var startedAt = Date.now();
                        var MIN_TIME_TO_WAIT = 50;
                        var removedListeners = false;
                        function stopWaiting() {
                            if (!removedListeners) {
                                window.removeEventListener("storage", stopWaiting);
                                SuperTokensLock.removeFromWaiting(stopWaiting);
                                clearTimeout(timeOutId);
                                removedListeners = true;
                            }
                            if (!resolvedCalled) {
                                resolvedCalled = true;
                                var timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);
                                if (timeToWait > 0) {
                                    setTimeout(resolve, timeToWait);
                                } else {
                                    resolve(null);
                                }
                            }
                        }
                        window.addEventListener("storage", stopWaiting);
                        SuperTokensLock.addToWaiting(stopWaiting);
                        var timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));
                    })) ];

                  case 1:
                    _a.sent();
                    return [ 2 ];
                }
            }));
        }));
    };
    SuperTokensLock.addToWaiting = function(func) {
        this.removeFromWaiting(func);
        if (SuperTokensLock.waiters === undefined) {
            return;
        }
        SuperTokensLock.waiters.push(func);
    };
    SuperTokensLock.removeFromWaiting = function(func) {
        if (SuperTokensLock.waiters === undefined) {
            return;
        }
        SuperTokensLock.waiters = SuperTokensLock.waiters.filter((function(i) {
            return i !== func;
        }));
    };
    SuperTokensLock.notifyWaiters = function() {
        if (SuperTokensLock.waiters === undefined) {
            return;
        }
        var waiters = SuperTokensLock.waiters.slice();
        waiters.forEach((function(i) {
            return i();
        }));
    };
    SuperTokensLock.prototype.releaseLock = function(lockKey) {
        return __awaiter(this, void 0, void 0, (function() {
            return __generator(this, (function(_a) {
                switch (_a.label) {
                  case 0:
                    return [ 4, this.releaseLock__private__(lockKey) ];

                  case 1:
                    return [ 2, _a.sent() ];
                }
            }));
        }));
    };
    SuperTokensLock.prototype.releaseLock__private__ = function(lockKey) {
        return __awaiter(this, void 0, void 0, (function() {
            var STORAGE, STORAGE_KEY, lockObj, parsedlockObj;
            return __generator(this, (function(_a) {
                switch (_a.label) {
                  case 0:
                    STORAGE = this.storageHandler === undefined ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                    STORAGE_KEY = LOCK_STORAGE_KEY + "-" + lockKey;
                    lockObj = STORAGE.getItemSync(STORAGE_KEY);
                    if (lockObj === null) {
                        return [ 2 ];
                    }
                    parsedlockObj = JSON.parse(lockObj);
                    if (!(parsedlockObj.id === this.id)) return [ 3, 2 ];
                    return [ 4, processLock_1.default().lock(parsedlockObj.iat) ];

                  case 1:
                    _a.sent();
                    this.acquiredIatSet.delete(parsedlockObj.iat);
                    STORAGE.removeItemSync(STORAGE_KEY);
                    processLock_1.default().unlock(parsedlockObj.iat);
                    SuperTokensLock.notifyWaiters();
                    _a.label = 2;

                  case 2:
                    return [ 2 ];
                }
            }));
        }));
    };
    SuperTokensLock.lockCorrector = function(storageHandler) {
        var MIN_ALLOWED_TIME = Date.now() - 5e3;
        var STORAGE = storageHandler;
        var KEYS = [];
        var currIndex = 0;
        while (true) {
            var key = STORAGE.keySync(currIndex);
            if (key === null) {
                break;
            }
            KEYS.push(key);
            currIndex++;
        }
        var notifyWaiters = false;
        for (var i = 0; i < KEYS.length; i++) {
            var LOCK_KEY = KEYS[i];
            if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {
                var lockObj = STORAGE.getItemSync(LOCK_KEY);
                if (lockObj !== null) {
                    var parsedlockObj = JSON.parse(lockObj);
                    if (parsedlockObj.timeRefreshed === undefined && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME || parsedlockObj.timeRefreshed !== undefined && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME) {
                        STORAGE.removeItemSync(LOCK_KEY);
                        notifyWaiters = true;
                    }
                }
            }
        }
        if (notifyWaiters) {
            SuperTokensLock.notifyWaiters();
        }
    };
    SuperTokensLock.waiters = undefined;
    return SuperTokensLock;
}();

var _default = browserTabsLock.default = SuperTokensLock;

class WebLocksApiManager {
    async runWithLock(key, timeout, callback) {
        const controller = new AbortController;
        const timeoutId = setTimeout((() => controller.abort()), timeout);
        try {
            return await navigator.locks.request(key, {
                mode: "exclusive",
                signal: controller.signal
            }, (async lock => {
                clearTimeout(timeoutId);
                if (!lock) throw new Error("Lock not available");
                return await callback();
            }));
        } catch (error) {
            clearTimeout(timeoutId);
            if ((error === null || error === void 0 ? void 0 : error.name) === "AbortError") throw new TimeoutError;
            throw error;
        }
    }
}

class LegacyLockManager {
    constructor() {
        this.activeLocks = new Set;
        this.lock = new _default;
        this.pagehideHandler = () => {
            this.activeLocks.forEach((key => this.lock.releaseLock(key)));
            this.activeLocks.clear();
        };
    }
    async runWithLock(key, timeout, callback) {
        const retryAttempts = 10;
        let acquired = false;
        for (let i = 0; i < retryAttempts && !acquired; i++) {
            acquired = await this.lock.acquireLock(key, timeout);
        }
        if (!acquired) {
            throw new TimeoutError;
        }
        this.activeLocks.add(key);
        if (this.activeLocks.size === 1 && typeof window !== "undefined") {
            window.addEventListener("pagehide", this.pagehideHandler);
        }
        try {
            return await callback();
        } finally {
            this.activeLocks.delete(key);
            await this.lock.releaseLock(key);
            if (this.activeLocks.size === 0 && typeof window !== "undefined") {
                window.removeEventListener("pagehide", this.pagehideHandler);
            }
        }
    }
}

function isWebLocksSupported() {
    var _a;
    return typeof navigator !== "undefined" && typeof ((_a = navigator.locks) === null || _a === void 0 ? void 0 : _a.request) === "function";
}

function createLockManager() {
    return isWebLocksSupported() ? new WebLocksApiManager : new LegacyLockManager;
}

let lockManager = null;

function getLockManager() {
    if (!lockManager) {
        lockManager = createLockManager();
    }
    return lockManager;
}

const encoder$2 = new TextEncoder;

const decoder$2 = new TextDecoder;

function buf$1(input) {
    if (typeof input === "string") {
        return encoder$2.encode(input);
    }
    return decoder$2.decode(input);
}

function checkRsaKeyAlgorithm$1(algorithm) {
    if (typeof algorithm.modulusLength !== "number" || algorithm.modulusLength < 2048) {
        throw new OperationProcessingError$1(`${algorithm.name} modulusLength must be at least 2048 bits`);
    }
}

function subtleAlgorithm$1(key) {
    switch (key.algorithm.name) {
      case "ECDSA":
        return {
            name: key.algorithm.name,
            hash: "SHA-256"
        };

      case "RSA-PSS":
        checkRsaKeyAlgorithm$1(key.algorithm);
        return {
            name: key.algorithm.name,
            saltLength: 256 >> 3
        };

      case "RSASSA-PKCS1-v1_5":
        checkRsaKeyAlgorithm$1(key.algorithm);
        return {
            name: key.algorithm.name
        };

      case "Ed25519":
        return {
            name: key.algorithm.name
        };
    }
    throw new UnsupportedOperationError$1;
}

async function jwt(header, claimsSet, key) {
    if (key.usages.includes("sign") === false) {
        throw new TypeError('private CryptoKey instances used for signing assertions must include "sign" in their "usages"');
    }
    const input = `${b64u$1(buf$1(JSON.stringify(header)))}.${b64u$1(buf$1(JSON.stringify(claimsSet)))}`;
    const signature = b64u$1(await crypto.subtle.sign(subtleAlgorithm$1(key), key, buf$1(input)));
    return `${input}.${signature}`;
}

let encodeBase64Url$1;

if (Uint8Array.prototype.toBase64) {
    encodeBase64Url$1 = input => {
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        return input.toBase64({
            alphabet: "base64url",
            omitPadding: true
        });
    };
} else {
    const CHUNK_SIZE = 32768;
    encodeBase64Url$1 = input => {
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        const arr = [];
        for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {
            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));
        }
        return btoa(arr.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
}

function b64u$1(input) {
    return encodeBase64Url$1(input);
}

class UnsupportedOperationError$1 extends Error {
    constructor(message) {
        var _a;
        super(message !== null && message !== void 0 ? message : "operation not supported");
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
    }
}

class OperationProcessingError$1 extends Error {
    constructor(message) {
        var _a;
        super(message);
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
    }
}

function psAlg$1(key) {
    switch (key.algorithm.hash.name) {
      case "SHA-256":
        return "PS256";

      default:
        throw new UnsupportedOperationError$1("unsupported RsaHashedKeyAlgorithm hash name");
    }
}

function rsAlg$1(key) {
    switch (key.algorithm.hash.name) {
      case "SHA-256":
        return "RS256";

      default:
        throw new UnsupportedOperationError$1("unsupported RsaHashedKeyAlgorithm hash name");
    }
}

function esAlg$1(key) {
    switch (key.algorithm.namedCurve) {
      case "P-256":
        return "ES256";

      default:
        throw new UnsupportedOperationError$1("unsupported EcKeyAlgorithm namedCurve");
    }
}

function determineJWSAlgorithm(key) {
    switch (key.algorithm.name) {
      case "RSA-PSS":
        return psAlg$1(key);

      case "RSASSA-PKCS1-v1_5":
        return rsAlg$1(key);

      case "ECDSA":
        return esAlg$1(key);

      case "Ed25519":
        return "Ed25519";

      default:
        throw new UnsupportedOperationError$1("unsupported CryptoKey algorithm name");
    }
}

function isCryptoKey$1(key) {
    return key instanceof CryptoKey;
}

function isPrivateKey(key) {
    return isCryptoKey$1(key) && key.type === "private";
}

function isPublicKey(key) {
    return isCryptoKey$1(key) && key.type === "public";
}

function epochTime$1() {
    return Math.floor(Date.now() / 1e3);
}

async function generateProof$1(keypair, htu, htm, nonce, accessToken, additional) {
    const privateKey = keypair === null || keypair === void 0 ? void 0 : keypair.privateKey;
    const publicKey = keypair === null || keypair === void 0 ? void 0 : keypair.publicKey;
    if (!isPrivateKey(privateKey)) {
        throw new TypeError('"keypair.privateKey" must be a private CryptoKey');
    }
    if (!isPublicKey(publicKey)) {
        throw new TypeError('"keypair.publicKey" must be a public CryptoKey');
    }
    if (publicKey.extractable !== true) {
        throw new TypeError('"keypair.publicKey.extractable" must be true');
    }
    if (typeof htu !== "string") {
        throw new TypeError('"htu" must be a string');
    }
    if (typeof htm !== "string") {
        throw new TypeError('"htm" must be a string');
    }
    if (nonce !== undefined && typeof nonce !== "string") {
        throw new TypeError('"nonce" must be a string or undefined');
    }
    if (accessToken !== undefined && typeof accessToken !== "string") {
        throw new TypeError('"accessToken" must be a string or undefined');
    }
    if (additional !== undefined && (typeof additional !== "object" || additional === null || Array.isArray(additional))) {
        throw new TypeError('"additional" must be an object');
    }
    return jwt({
        alg: determineJWSAlgorithm(privateKey),
        typ: "dpop+jwt",
        jwk: await publicJwk(publicKey)
    }, Object.assign(Object.assign({}, additional), {
        iat: epochTime$1(),
        jti: crypto.randomUUID(),
        htm: htm,
        nonce: nonce,
        htu: htu,
        ath: accessToken ? b64u$1(await crypto.subtle.digest("SHA-256", buf$1(accessToken))) : undefined
    }), privateKey);
}

async function publicJwk(key) {
    const {kty: kty, e: e, n: n, x: x, y: y, crv: crv} = await crypto.subtle.exportKey("jwk", key);
    return {
        kty: kty,
        crv: crv,
        e: e,
        n: n,
        x: x,
        y: y
    };
}

async function generateKeyPair$1(alg, options) {
    var _a;
    let algorithm;
    if (typeof alg !== "string" || alg.length === 0) {
        throw new TypeError('"alg" must be a non-empty string');
    }
    switch (alg) {
      case "PS256":
        algorithm = {
            name: "RSA-PSS",
            hash: "SHA-256",
            modulusLength: 2048,
            publicExponent: new Uint8Array([ 1, 0, 1 ])
        };
        break;

      case "RS256":
        algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-256",
            modulusLength: 2048,
            publicExponent: new Uint8Array([ 1, 0, 1 ])
        };
        break;

      case "ES256":
        algorithm = {
            name: "ECDSA",
            namedCurve: "P-256"
        };
        break;

      case "Ed25519":
        algorithm = {
            name: "Ed25519"
        };
        break;

      default:
        throw new UnsupportedOperationError$1;
    }
    return crypto.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, [ "sign", "verify" ]);
}

async function calculateThumbprint$1(publicKey) {
    if (!isPublicKey(publicKey)) {
        throw new TypeError('"publicKey" must be a public CryptoKey');
    }
    if (publicKey.extractable !== true) {
        throw new TypeError('"publicKey.extractable" must be true');
    }
    const jwk = await publicJwk(publicKey);
    let components;
    switch (jwk.kty) {
      case "EC":
        components = {
            crv: jwk.crv,
            kty: jwk.kty,
            x: jwk.x,
            y: jwk.y
        };
        break;

      case "OKP":
        components = {
            crv: jwk.crv,
            kty: jwk.kty,
            x: jwk.x
        };
        break;

      case "RSA":
        components = {
            e: jwk.e,
            kty: jwk.kty,
            n: jwk.n
        };
        break;

      default:
        throw new UnsupportedOperationError$1("unsupported JWK kty");
    }
    return b64u$1(await crypto.subtle.digest({
        name: "SHA-256"
    }, buf$1(JSON.stringify(components))));
}

const DPOP_NONCE_HEADER = "dpop-nonce";

const KEY_PAIR_ALGORITHM = "ES256";

const SUPPORTED_GRANT_TYPES = [ "authorization_code", "refresh_token", "urn:ietf:params:oauth:grant-type:token-exchange", "http://auth0.com/oauth/grant-type/mfa-oob", "http://auth0.com/oauth/grant-type/mfa-otp", "http://auth0.com/oauth/grant-type/mfa-recovery-code" ];

function generateKeyPair() {
    return generateKeyPair$1(KEY_PAIR_ALGORITHM, {
        extractable: false
    });
}

function calculateThumbprint(keyPair) {
    return calculateThumbprint$1(keyPair.publicKey);
}

function normalizeUrl(url) {
    const parsedUrl = new URL(url);
    parsedUrl.search = "";
    parsedUrl.hash = "";
    return parsedUrl.href;
}

function generateProof(_ref) {
    let {keyPair: keyPair, url: url, method: method, nonce: nonce, accessToken: accessToken} = _ref;
    const normalizedUrl = normalizeUrl(url);
    return generateProof$1(keyPair, normalizedUrl, method, nonce, accessToken);
}

function isGrantTypeSupported(grantType) {
    return SUPPORTED_GRANT_TYPES.includes(grantType);
}

const sendMessage = (message, to) => new Promise((function(resolve, reject) {
    const messageChannel = new MessageChannel;
    messageChannel.port1.onmessage = function(event) {
        if (event.data.error) {
            reject(new Error(event.data.error));
        } else {
            resolve(event.data);
        }
        messageChannel.port1.close();
    };
    to.postMessage(message, [ messageChannel.port2 ]);
}));

const createAbortController = () => new AbortController;

const dofetch = async (fetchUrl, fetchOptions) => {
    const response = await fetch(fetchUrl, fetchOptions);
    return {
        ok: response.ok,
        json: await response.json(),
        headers: fromEntries(response.headers)
    };
};

const fetchWithoutWorker = async (fetchUrl, fetchOptions, timeout) => {
    const controller = createAbortController();
    fetchOptions.signal = controller.signal;
    let timeoutId;
    return Promise.race([ dofetch(fetchUrl, fetchOptions), new Promise(((_, reject) => {
        timeoutId = setTimeout((() => {
            controller.abort();
            reject(new Error("Timeout when executing 'fetch'"));
        }), timeout);
    })) ]).finally((() => {
        clearTimeout(timeoutId);
    }));
};

const fetchWithWorker = async (fetchUrl, audience, scope, fetchOptions, timeout, worker, useFormData, useMrrt) => sendMessage({
    auth: {
        audience: audience,
        scope: scope
    },
    timeout: timeout,
    fetchUrl: fetchUrl,
    fetchOptions: fetchOptions,
    useFormData: useFormData,
    useMrrt: useMrrt
}, worker);

const switchFetch = async function switchFetch(fetchUrl, audience, scope, fetchOptions, worker, useFormData) {
    let timeout = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_FETCH_TIMEOUT_MS;
    let useMrrt = arguments.length > 7 ? arguments[7] : undefined;
    if (worker) {
        return fetchWithWorker(fetchUrl, audience, scope, fetchOptions, timeout, worker, useFormData, useMrrt);
    } else {
        return fetchWithoutWorker(fetchUrl, fetchOptions, timeout);
    }
};

async function getJSON(url, timeout, audience, scope, options, worker, useFormData, useMrrt, dpop, isDpopRetry) {
    if (dpop) {
        const dpopProof = await dpop.generateProof({
            url: url,
            method: options.method || "GET",
            nonce: await dpop.getNonce()
        });
        options.headers = Object.assign(Object.assign({}, options.headers), {
            dpop: dpopProof
        });
    }
    let fetchError = null;
    let response;
    for (let i = 0; i < DEFAULT_SILENT_TOKEN_RETRY_COUNT; i++) {
        try {
            response = await switchFetch(url, audience, scope, options, worker, useFormData, timeout, useMrrt);
            fetchError = null;
            break;
        } catch (e) {
            fetchError = e;
        }
    }
    if (fetchError) {
        throw fetchError;
    }
    const _a = response.json, {error: error, error_description: error_description} = _a, data = __rest(_a, [ "error", "error_description" ]), {headers: headers, ok: ok} = response;
    let newDpopNonce;
    if (dpop) {
        newDpopNonce = headers[DPOP_NONCE_HEADER];
        if (newDpopNonce) {
            await dpop.setNonce(newDpopNonce);
        }
    }
    if (!ok) {
        const errorMessage = error_description || "HTTP error. Unable to fetch ".concat(url);
        if (error === "mfa_required") {
            throw new MfaRequiredError(error, errorMessage, data.mfa_token, data.mfa_requirements);
        }
        if (error === "missing_refresh_token") {
            throw new MissingRefreshTokenError(audience, scope);
        }
        if (error === "use_dpop_nonce") {
            if (!dpop || !newDpopNonce || isDpopRetry) {
                throw new UseDpopNonceError(newDpopNonce);
            }
            return getJSON(url, timeout, audience, scope, options, worker, useFormData, useMrrt, dpop, true);
        }
        throw new GenericError(error || "request_error", errorMessage);
    }
    return data;
}

async function oauthToken(_a, worker) {
    var {baseUrl: baseUrl, timeout: timeout, audience: audience, scope: scope, auth0Client: auth0Client, useFormData: useFormData, useMrrt: useMrrt, dpop: dpop} = _a, options = __rest(_a, [ "baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData", "useMrrt", "dpop" ]);
    const isTokenExchange = options.grant_type === "urn:ietf:params:oauth:grant-type:token-exchange";
    const refreshWithMrrt = options.grant_type === "refresh_token" && useMrrt;
    const allParams = Object.assign(Object.assign(Object.assign(Object.assign({}, options), isTokenExchange && audience && {
        audience: audience
    }), isTokenExchange && scope && {
        scope: scope
    }), refreshWithMrrt && {
        audience: audience,
        scope: scope
    });
    const body = useFormData ? createQueryParams(allParams) : JSON.stringify(allParams);
    const isDpopSupported = isGrantTypeSupported(options.grant_type);
    return await getJSON("".concat(baseUrl, "/oauth/token"), timeout, audience || DEFAULT_AUDIENCE, scope, {
        method: "POST",
        body: body,
        headers: {
            "Content-Type": useFormData ? "application/x-www-form-urlencoded" : "application/json",
            "Auth0-Client": btoa(JSON.stringify(stripAuth0Client(auth0Client || DEFAULT_AUTH0_CLIENT)))
        }
    }, worker, useFormData, useMrrt, isDpopSupported ? dpop : undefined);
}

const dedupe = arr => Array.from(new Set(arr));

const getUniqueScopes = function getUniqueScopes() {
    for (var _len = arguments.length, scopes = new Array(_len), _key = 0; _key < _len; _key++) {
        scopes[_key] = arguments[_key];
    }
    return dedupe(scopes.filter(Boolean).join(" ").trim().split(/\s+/)).join(" ");
};

const injectDefaultScopes = function injectDefaultScopes(authScopes, openIdScope) {
    for (var _len2 = arguments.length, extraScopes = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        extraScopes[_key2 - 2] = arguments[_key2];
    }
    if (typeof authScopes !== "object") {
        return {
            [DEFAULT_AUDIENCE]: getUniqueScopes(openIdScope, authScopes, ...extraScopes)
        };
    }
    let requestedScopes = {
        [DEFAULT_AUDIENCE]: getUniqueScopes(openIdScope, ...extraScopes)
    };
    Object.keys(authScopes).forEach((key => {
        const audienceScopes = authScopes[key];
        requestedScopes[key] = getUniqueScopes(openIdScope, audienceScopes, ...extraScopes);
    }));
    return requestedScopes;
};

const scopesToRequest = (authScopes, methodScopes, audience) => {
    let scope;
    if (audience) {
        scope = authScopes[audience];
    }
    if (!scope) {
        scope = authScopes[DEFAULT_AUDIENCE];
    }
    return getUniqueScopes(scope, methodScopes);
};

const CACHE_KEY_PREFIX = "@@auth0spajs@@";

const CACHE_KEY_ID_TOKEN_SUFFIX = "@@user@@";

class CacheKey {
    constructor(data) {
        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CACHE_KEY_PREFIX;
        let suffix = arguments.length > 2 ? arguments[2] : undefined;
        this.prefix = prefix;
        this.suffix = suffix;
        this.clientId = data.clientId;
        this.scope = data.scope;
        this.audience = data.audience;
    }
    toKey() {
        return [ this.prefix, this.clientId, this.audience, this.scope, this.suffix ].filter(Boolean).join("::");
    }
    static fromKey(key) {
        const [prefix, clientId, audience, scope] = key.split("::");
        return new CacheKey({
            clientId: clientId,
            scope: scope,
            audience: audience
        }, prefix);
    }
    static fromCacheEntry(entry) {
        const {scope: scope, audience: audience, client_id: clientId} = entry;
        return new CacheKey({
            scope: scope,
            audience: audience,
            clientId: clientId
        });
    }
}

class LocalStorageCache {
    set(key, entry) {
        localStorage.setItem(key, JSON.stringify(entry));
    }
    get(key) {
        const json = window.localStorage.getItem(key);
        if (!json) return;
        try {
            const payload = JSON.parse(json);
            return payload;
        } catch (e) {
            return;
        }
    }
    remove(key) {
        localStorage.removeItem(key);
    }
    allKeys() {
        return Object.keys(window.localStorage).filter((key => key.startsWith(CACHE_KEY_PREFIX)));
    }
}

class InMemoryCache {
    constructor() {
        this.enclosedCache = function() {
            let cache = {};
            return {
                set(key, entry) {
                    cache[key] = entry;
                },
                get(key) {
                    const cacheEntry = cache[key];
                    if (!cacheEntry) {
                        return;
                    }
                    return cacheEntry;
                },
                remove(key) {
                    delete cache[key];
                },
                allKeys() {
                    return Object.keys(cache);
                }
            };
        }();
    }
}

const DEFAULT_EXPIRY_ADJUSTMENT_SECONDS = 0;

class CacheManager {
    constructor(cache, keyManifest, nowProvider) {
        this.cache = cache;
        this.keyManifest = keyManifest;
        this.nowProvider = nowProvider || DEFAULT_NOW_PROVIDER;
    }
    async setIdToken(clientId, idToken, decodedToken) {
        var _a;
        const cacheKey = this.getIdTokenCacheKey(clientId);
        await this.cache.set(cacheKey, {
            id_token: idToken,
            decodedToken: decodedToken
        });
        await ((_a = this.keyManifest) === null || _a === void 0 ? void 0 : _a.add(cacheKey));
    }
    async getIdToken(cacheKey) {
        const entry = await this.cache.get(this.getIdTokenCacheKey(cacheKey.clientId));
        if (!entry && cacheKey.scope && cacheKey.audience) {
            const entryByScope = await this.get(cacheKey);
            if (!entryByScope) {
                return;
            }
            if (!entryByScope.id_token || !entryByScope.decodedToken) {
                return;
            }
            return {
                id_token: entryByScope.id_token,
                decodedToken: entryByScope.decodedToken
            };
        }
        if (!entry) {
            return;
        }
        return {
            id_token: entry.id_token,
            decodedToken: entry.decodedToken
        };
    }
    async get(cacheKey) {
        let expiryAdjustmentSeconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_EXPIRY_ADJUSTMENT_SECONDS;
        let useMrrt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let cacheMode = arguments.length > 3 ? arguments[3] : undefined;
        var _a;
        let wrappedEntry = await this.cache.get(cacheKey.toKey());
        if (!wrappedEntry) {
            const keys = await this.getCacheKeys();
            if (!keys) return;
            const matchedKey = this.matchExistingCacheKey(cacheKey, keys);
            if (matchedKey) {
                wrappedEntry = await this.cache.get(matchedKey);
            }
            if (!wrappedEntry && useMrrt && cacheMode !== "cache-only") {
                return this.getEntryWithRefreshToken(cacheKey, keys);
            }
        }
        if (!wrappedEntry) {
            return;
        }
        const now = await this.nowProvider();
        const nowSeconds = Math.floor(now / 1e3);
        if (wrappedEntry.expiresAt - expiryAdjustmentSeconds < nowSeconds) {
            if (wrappedEntry.body.refresh_token) {
                return this.modifiedCachedEntry(wrappedEntry, cacheKey);
            }
            await this.cache.remove(cacheKey.toKey());
            await ((_a = this.keyManifest) === null || _a === void 0 ? void 0 : _a.remove(cacheKey.toKey()));
            return;
        }
        return wrappedEntry.body;
    }
    async modifiedCachedEntry(wrappedEntry, cacheKey) {
        wrappedEntry.body = {
            refresh_token: wrappedEntry.body.refresh_token,
            audience: wrappedEntry.body.audience,
            scope: wrappedEntry.body.scope
        };
        await this.cache.set(cacheKey.toKey(), wrappedEntry);
        return {
            refresh_token: wrappedEntry.body.refresh_token,
            audience: wrappedEntry.body.audience,
            scope: wrappedEntry.body.scope
        };
    }
    async set(entry) {
        var _a;
        const cacheKey = new CacheKey({
            clientId: entry.client_id,
            scope: entry.scope,
            audience: entry.audience
        });
        const wrappedEntry = await this.wrapCacheEntry(entry);
        await this.cache.set(cacheKey.toKey(), wrappedEntry);
        await ((_a = this.keyManifest) === null || _a === void 0 ? void 0 : _a.add(cacheKey.toKey()));
    }
    async remove(client_id, audience, scope) {
        const cacheKey = new CacheKey({
            clientId: client_id,
            scope: scope,
            audience: audience
        });
        await this.cache.remove(cacheKey.toKey());
    }
    async clear(clientId) {
        var _a;
        const keys = await this.getCacheKeys();
        if (!keys) return;
        await keys.filter((key => clientId ? key.includes(clientId) : true)).reduce((async (memo, key) => {
            await memo;
            await this.cache.remove(key);
        }), Promise.resolve());
        await ((_a = this.keyManifest) === null || _a === void 0 ? void 0 : _a.clear());
    }
    async wrapCacheEntry(entry) {
        const now = await this.nowProvider();
        const expiresInTime = Math.floor(now / 1e3) + entry.expires_in;
        return {
            body: entry,
            expiresAt: expiresInTime
        };
    }
    async getCacheKeys() {
        var _a;
        if (this.keyManifest) {
            return (_a = await this.keyManifest.get()) === null || _a === void 0 ? void 0 : _a.keys;
        } else if (this.cache.allKeys) {
            return this.cache.allKeys();
        }
    }
    getIdTokenCacheKey(clientId) {
        return new CacheKey({
            clientId: clientId
        }, CACHE_KEY_PREFIX, CACHE_KEY_ID_TOKEN_SUFFIX).toKey();
    }
    matchExistingCacheKey(keyToMatch, allKeys) {
        return allKeys.filter((key => {
            var _a;
            const cacheKey = CacheKey.fromKey(key);
            const scopeSet = new Set(cacheKey.scope && cacheKey.scope.split(" "));
            const scopesToMatch = ((_a = keyToMatch.scope) === null || _a === void 0 ? void 0 : _a.split(" ")) || [];
            const hasAllScopes = cacheKey.scope && scopesToMatch.reduce(((acc, current) => acc && scopeSet.has(current)), true);
            return cacheKey.prefix === CACHE_KEY_PREFIX && cacheKey.clientId === keyToMatch.clientId && cacheKey.audience === keyToMatch.audience && hasAllScopes;
        }))[0];
    }
    async getEntryWithRefreshToken(keyToMatch, allKeys) {
        var _a;
        for (const key of allKeys) {
            const cacheKey = CacheKey.fromKey(key);
            if (cacheKey.prefix === CACHE_KEY_PREFIX && cacheKey.clientId === keyToMatch.clientId) {
                const cachedEntry = await this.cache.get(key);
                if ((_a = cachedEntry === null || cachedEntry === void 0 ? void 0 : cachedEntry.body) === null || _a === void 0 ? void 0 : _a.refresh_token) {
                    return this.modifiedCachedEntry(cachedEntry, keyToMatch);
                }
            }
        }
        return undefined;
    }
    async updateEntry(oldRefreshToken, newRefreshToken) {
        var _a;
        const allKeys = await this.getCacheKeys();
        if (!allKeys) return;
        for (const key of allKeys) {
            const entry = await this.cache.get(key);
            if (((_a = entry === null || entry === void 0 ? void 0 : entry.body) === null || _a === void 0 ? void 0 : _a.refresh_token) === oldRefreshToken) {
                entry.body.refresh_token = newRefreshToken;
                await this.cache.set(key, entry);
            }
        }
    }
}

const TRANSACTION_STORAGE_KEY_PREFIX = "a0.spajs.txs";

class TransactionManager {
    constructor(storage, clientId, cookieDomain) {
        this.storage = storage;
        this.clientId = clientId;
        this.cookieDomain = cookieDomain;
        this.storageKey = "".concat(TRANSACTION_STORAGE_KEY_PREFIX, ".").concat(this.clientId);
    }
    create(transaction) {
        this.storage.save(this.storageKey, transaction, {
            daysUntilExpire: 1,
            cookieDomain: this.cookieDomain
        });
    }
    get() {
        return this.storage.get(this.storageKey);
    }
    remove() {
        this.storage.remove(this.storageKey, {
            cookieDomain: this.cookieDomain
        });
    }
}

const isNumber = n => typeof n === "number";

const idTokendecoded = [ "iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm" ];

const decode$1 = token => {
    const parts = token.split(".");
    const [header, payload, signature] = parts;
    if (parts.length !== 3 || !header || !payload || !signature) {
        throw new Error("ID token could not be decoded");
    }
    const payloadJSON = JSON.parse(urlDecodeB64(payload));
    const claims = {
        __raw: token
    };
    const user = {};
    Object.keys(payloadJSON).forEach((k => {
        claims[k] = payloadJSON[k];
        if (!idTokendecoded.includes(k)) {
            user[k] = payloadJSON[k];
        }
    }));
    return {
        encoded: {
            header: header,
            payload: payload,
            signature: signature
        },
        header: JSON.parse(urlDecodeB64(header)),
        claims: claims,
        user: user
    };
};

const verify$1 = options => {
    if (!options.id_token) {
        throw new Error("ID token is required but missing");
    }
    const decoded = decode$1(options.id_token);
    if (!decoded.claims.iss) {
        throw new Error("Issuer (iss) claim must be a string present in the ID token");
    }
    if (decoded.claims.iss !== options.iss) {
        throw new Error('Issuer (iss) claim mismatch in the ID token; expected "'.concat(options.iss, '", found "').concat(decoded.claims.iss, '"'));
    }
    if (!decoded.user.sub) {
        throw new Error("Subject (sub) claim must be a string present in the ID token");
    }
    if (decoded.header.alg !== "RS256") {
        throw new Error('Signature algorithm of "'.concat(decoded.header.alg, '" is not supported. Expected the ID token to be signed with "RS256".'));
    }
    if (!decoded.claims.aud || !(typeof decoded.claims.aud === "string" || Array.isArray(decoded.claims.aud))) {
        throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
    }
    if (Array.isArray(decoded.claims.aud)) {
        if (!decoded.claims.aud.includes(options.aud)) {
            throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(options.aud, '" but was not one of "').concat(decoded.claims.aud.join(", "), '"'));
        }
        if (decoded.claims.aud.length > 1) {
            if (!decoded.claims.azp) {
                throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
            }
            if (decoded.claims.azp !== options.aud) {
                throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "'.concat(options.aud, '", found "').concat(decoded.claims.azp, '"'));
            }
        }
    } else if (decoded.claims.aud !== options.aud) {
        throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(options.aud, '" but found "').concat(decoded.claims.aud, '"'));
    }
    if (options.nonce) {
        if (!decoded.claims.nonce) {
            throw new Error("Nonce (nonce) claim must be a string present in the ID token");
        }
        if (decoded.claims.nonce !== options.nonce) {
            throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "'.concat(options.nonce, '", found "').concat(decoded.claims.nonce, '"'));
        }
    }
    if (options.max_age && !isNumber(decoded.claims.auth_time)) {
        throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
    }
    if (decoded.claims.exp == null || !isNumber(decoded.claims.exp)) {
        throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
    }
    if (!isNumber(decoded.claims.iat)) {
        throw new Error("Issued At (iat) claim must be a number present in the ID token");
    }
    const leeway = options.leeway || 60;
    const now = new Date(options.now || Date.now());
    const expDate = new Date(0);
    expDate.setUTCSeconds(decoded.claims.exp + leeway);
    if (now > expDate) {
        throw new Error("Expiration Time (exp) claim error in the ID token; current time (".concat(now, ") is after expiration time (").concat(expDate, ")"));
    }
    if (decoded.claims.nbf != null && isNumber(decoded.claims.nbf)) {
        const nbfDate = new Date(0);
        nbfDate.setUTCSeconds(decoded.claims.nbf - leeway);
        if (now < nbfDate) {
            throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (".concat(now, ") is before ").concat(nbfDate));
        }
    }
    if (decoded.claims.auth_time != null && isNumber(decoded.claims.auth_time)) {
        const authTimeDate = new Date(0);
        authTimeDate.setUTCSeconds(parseInt(decoded.claims.auth_time) + options.max_age + leeway);
        if (now > authTimeDate) {
            throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (".concat(now, ") is after last auth at ").concat(authTimeDate));
        }
    }
    if (options.organization) {
        const org = options.organization.trim();
        if (org.startsWith("org_")) {
            const orgId = org;
            if (!decoded.claims.org_id) {
                throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
            } else if (orgId !== decoded.claims.org_id) {
                throw new Error('Organization ID (org_id) claim mismatch in the ID token; expected "'.concat(orgId, '", found "').concat(decoded.claims.org_id, '"'));
            }
        } else {
            const orgName = org.toLowerCase();
            if (!decoded.claims.org_name) {
                throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
            } else if (orgName !== decoded.claims.org_name) {
                throw new Error('Organization Name (org_name) claim mismatch in the ID token; expected "'.concat(orgName, '", found "').concat(decoded.claims.org_name, '"'));
            }
        }
    }
    return decoded;
};

var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function stringifyAttribute(name, value) {
    if (!value) {
        return "";
    }
    var stringified = "; " + name;
    if (value === true) {
        return stringified;
    }
    return stringified + "=" + value;
}

function stringifyAttributes(attributes) {
    if (typeof attributes.expires === "number") {
        var expires = new Date;
        expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e5);
        attributes.expires = expires;
    }
    return stringifyAttribute("Expires", attributes.expires ? attributes.expires.toUTCString() : "") + stringifyAttribute("Domain", attributes.domain) + stringifyAttribute("Path", attributes.path) + stringifyAttribute("Secure", attributes.secure) + stringifyAttribute("SameSite", attributes.sameSite);
}

function encode$1(name, value, attributes) {
    return encodeURIComponent(name).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(value).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + stringifyAttributes(attributes);
}

function parse(cookieString) {
    var result = {};
    var cookies = cookieString ? cookieString.split("; ") : [];
    var rdecode = /(%[\dA-F]{2})+/gi;
    for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split("=");
        var cookie = parts.slice(1).join("=");
        if (cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
        }
        try {
            var name_1 = parts[0].replace(rdecode, decodeURIComponent);
            result[name_1] = cookie.replace(rdecode, decodeURIComponent);
        } catch (e) {}
    }
    return result;
}

function getAll() {
    return parse(document.cookie);
}

function get(name) {
    return getAll()[name];
}

var get_1 = get;

function set(name, value, attributes) {
    document.cookie = encode$1(name, value, __assign({
        path: "/"
    }, attributes));
}

var set_1 = set;

function remove(name, attributes) {
    set(name, "", __assign(__assign({}, attributes), {
        expires: -1
    }));
}

var remove_1 = remove;

const CookieStorage = {
    get(key) {
        const value = get_1(key);
        if (typeof value === "undefined") {
            return;
        }
        return JSON.parse(value);
    },
    save(key, value, options) {
        let cookieAttributes = {};
        if ("https:" === window.location.protocol) {
            cookieAttributes = {
                secure: true,
                sameSite: "none"
            };
        }
        if (options === null || options === void 0 ? void 0 : options.daysUntilExpire) {
            cookieAttributes.expires = options.daysUntilExpire;
        }
        if (options === null || options === void 0 ? void 0 : options.cookieDomain) {
            cookieAttributes.domain = options.cookieDomain;
        }
        set_1(key, JSON.stringify(value), cookieAttributes);
    },
    remove(key, options) {
        let cookieAttributes = {};
        if (options === null || options === void 0 ? void 0 : options.cookieDomain) {
            cookieAttributes.domain = options.cookieDomain;
        }
        remove_1(key, cookieAttributes);
    }
};

const LEGACY_PREFIX = "_legacy_";

const CookieStorageWithLegacySameSite = {
    get(key) {
        const value = CookieStorage.get(key);
        if (value) {
            return value;
        }
        return CookieStorage.get("".concat(LEGACY_PREFIX).concat(key));
    },
    save(key, value, options) {
        let cookieAttributes = {};
        if ("https:" === window.location.protocol) {
            cookieAttributes = {
                secure: true
            };
        }
        if (options === null || options === void 0 ? void 0 : options.daysUntilExpire) {
            cookieAttributes.expires = options.daysUntilExpire;
        }
        if (options === null || options === void 0 ? void 0 : options.cookieDomain) {
            cookieAttributes.domain = options.cookieDomain;
        }
        set_1("".concat(LEGACY_PREFIX).concat(key), JSON.stringify(value), cookieAttributes);
        CookieStorage.save(key, value, options);
    },
    remove(key, options) {
        let cookieAttributes = {};
        if (options === null || options === void 0 ? void 0 : options.cookieDomain) {
            cookieAttributes.domain = options.cookieDomain;
        }
        remove_1(key, cookieAttributes);
        CookieStorage.remove(key, options);
        CookieStorage.remove("".concat(LEGACY_PREFIX).concat(key), options);
    }
};

const SessionStorage = {
    get(key) {
        if (typeof sessionStorage === "undefined") {
            return;
        }
        const value = sessionStorage.getItem(key);
        if (value == null) {
            return;
        }
        return JSON.parse(value);
    },
    save(key, value) {
        sessionStorage.setItem(key, JSON.stringify(value));
    },
    remove(key) {
        sessionStorage.removeItem(key);
    }
};

exports.ResponseType = void 0;

(function(ResponseType) {
    ResponseType["Code"] = "code";
    ResponseType["ConnectCode"] = "connect_code";
})(exports.ResponseType || (exports.ResponseType = {}));

class User {}

function decodeBase64$1(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64$1(base64, enableUnicode);
    var start = source.indexOf("\n", 10) + 1;
    var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
    var blob = new Blob([ body ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}

var WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24oKSB7CiAgICAidXNlIHN0cmljdCI7CiAgICBjbGFzcyBHZW5lcmljRXJyb3IgZXh0ZW5kcyBFcnJvciB7CiAgICAgICAgY29uc3RydWN0b3IoZXJyb3IsIGVycm9yX2Rlc2NyaXB0aW9uKSB7CiAgICAgICAgICAgIHN1cGVyKGVycm9yX2Rlc2NyaXB0aW9uKTsKICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yOwogICAgICAgICAgICB0aGlzLmVycm9yX2Rlc2NyaXB0aW9uID0gZXJyb3JfZGVzY3JpcHRpb247CiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBHZW5lcmljRXJyb3IucHJvdG90eXBlKTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGZyb21QYXlsb2FkKF9yZWYpIHsKICAgICAgICAgICAgbGV0IHtlcnJvcjogZXJyb3IsIGVycm9yX2Rlc2NyaXB0aW9uOiBlcnJvcl9kZXNjcmlwdGlvbn0gPSBfcmVmOwogICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNFcnJvcihlcnJvciwgZXJyb3JfZGVzY3JpcHRpb24pOwogICAgICAgIH0KICAgIH0KICAgIGNsYXNzIE1pc3NpbmdSZWZyZXNoVG9rZW5FcnJvciBleHRlbmRzIEdlbmVyaWNFcnJvciB7CiAgICAgICAgY29uc3RydWN0b3IoYXVkaWVuY2UsIHNjb3BlKSB7CiAgICAgICAgICAgIHN1cGVyKCJtaXNzaW5nX3JlZnJlc2hfdG9rZW4iLCAiTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyIuY29uY2F0KHZhbHVlT3JFbXB0eVN0cmluZyhhdWRpZW5jZSwgWyAiZGVmYXVsdCIgXSksICInLCBzY29wZTogJyIpLmNvbmNhdCh2YWx1ZU9yRW1wdHlTdHJpbmcoc2NvcGUpLCAiJykiKSk7CiAgICAgICAgICAgIHRoaXMuYXVkaWVuY2UgPSBhdWRpZW5jZTsKICAgICAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlOwogICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWlzc2luZ1JlZnJlc2hUb2tlbkVycm9yLnByb3RvdHlwZSk7CiAgICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gdmFsdWVPckVtcHR5U3RyaW5nKHZhbHVlKSB7CiAgICAgICAgbGV0IGV4Y2x1ZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdOwogICAgICAgIHJldHVybiB2YWx1ZSAmJiAhZXhjbHVkZS5pbmNsdWRlcyh2YWx1ZSkgPyB2YWx1ZSA6ICIiOwogICAgfQogICAgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHsKICAgICAgICB2YXIgdCA9IHt9OwogICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTsKICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAiZnVuY3Rpb24iKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiB0OwogICAgfQogICAgdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gImZ1bmN0aW9uIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7CiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7CiAgICAgICAgcmV0dXJuIGUubmFtZSA9ICJTdXBwcmVzc2VkRXJyb3IiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7CiAgICB9OwogICAgY29uc3Qgc3RyaXBVbmRlZmluZWQgPSBwYXJhbXMgPT4gT2JqZWN0LmtleXMocGFyYW1zKS5maWx0ZXIoKGsgPT4gdHlwZW9mIHBhcmFtc1trXSAhPT0gInVuZGVmaW5lZCIpKS5yZWR1Y2UoKChhY2MsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7CiAgICAgICAgW2tleV06IHBhcmFtc1trZXldCiAgICB9KSksIHt9KTsKICAgIGNvbnN0IGNyZWF0ZVF1ZXJ5UGFyYW1zID0gX2EgPT4gewogICAgICAgIHZhciB7Y2xpZW50SWQ6IGNsaWVudF9pZH0gPSBfYSwgcGFyYW1zID0gX19yZXN0KF9hLCBbICJjbGllbnRJZCIgXSk7CiAgICAgICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc3RyaXBVbmRlZmluZWQoT2JqZWN0LmFzc2lnbih7CiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50X2lkCiAgICAgICAgfSwgcGFyYW1zKSkpLnRvU3RyaW5nKCk7CiAgICB9OwogICAgY29uc3QgZnJvbUVudHJpZXMgPSBpdGVyYWJsZSA9PiBbIC4uLml0ZXJhYmxlIF0ucmVkdWNlKCgob2JqLCBfcmVmKSA9PiB7CiAgICAgICAgbGV0IFtrZXksIHZhbF0gPSBfcmVmOwogICAgICAgIG9ialtrZXldID0gdmFsOwogICAgICAgIHJldHVybiBvYmo7CiAgICB9KSwge30pOwogICAgbGV0IHJlZnJlc2hUb2tlbnMgPSB7fTsKICAgIGNvbnN0IGNhY2hlS2V5ID0gKGF1ZGllbmNlLCBzY29wZSkgPT4gIiIuY29uY2F0KGF1ZGllbmNlLCAifCIpLmNvbmNhdChzY29wZSk7CiAgICBjb25zdCBjYWNoZUtleUNvbnRhaW5zQXVkaWVuY2UgPSAoYXVkaWVuY2UsIGNhY2hlS2V5KSA9PiBjYWNoZUtleS5zdGFydHNXaXRoKCIiLmNvbmNhdChhdWRpZW5jZSwgInwiKSk7CiAgICBjb25zdCBnZXRSZWZyZXNoVG9rZW4gPSAoYXVkaWVuY2UsIHNjb3BlKSA9PiByZWZyZXNoVG9rZW5zW2NhY2hlS2V5KGF1ZGllbmNlLCBzY29wZSldOwogICAgY29uc3Qgc2V0UmVmcmVzaFRva2VuID0gKHJlZnJlc2hUb2tlbiwgYXVkaWVuY2UsIHNjb3BlKSA9PiByZWZyZXNoVG9rZW5zW2NhY2hlS2V5KGF1ZGllbmNlLCBzY29wZSldID0gcmVmcmVzaFRva2VuOwogICAgY29uc3QgZGVsZXRlUmVmcmVzaFRva2VuID0gKGF1ZGllbmNlLCBzY29wZSkgPT4gZGVsZXRlIHJlZnJlc2hUb2tlbnNbY2FjaGVLZXkoYXVkaWVuY2UsIHNjb3BlKV07CiAgICBjb25zdCB3YWl0ID0gdGltZSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKSk7CiAgICBjb25zdCBmb3JtRGF0YVRvT2JqZWN0ID0gZm9ybURhdGEgPT4gewogICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhmb3JtRGF0YSk7CiAgICAgICAgY29uc3QgcGFyc2VkUXVlcnkgPSB7fTsKICAgICAgICBxdWVyeVBhcmFtcy5mb3JFYWNoKCgodmFsLCBrZXkpID0+IHsKICAgICAgICAgICAgcGFyc2VkUXVlcnlba2V5XSA9IHZhbDsKICAgICAgICB9KSk7CiAgICAgICAgcmV0dXJuIHBhcnNlZFF1ZXJ5OwogICAgfTsKICAgIGNvbnN0IHVwZGF0ZVJlZnJlc2hUb2tlbnMgPSAob2xkUmVmcmVzaFRva2VuLCBuZXdSZWZyZXNoVG9rZW4pID0+IHsKICAgICAgICBPYmplY3QuZW50cmllcyhyZWZyZXNoVG9rZW5zKS5mb3JFYWNoKChfcmVmID0+IHsKICAgICAgICAgICAgbGV0IFtrZXksIHRva2VuXSA9IF9yZWY7CiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gb2xkUmVmcmVzaFRva2VuKSB7CiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW5zW2tleV0gPSBuZXdSZWZyZXNoVG9rZW47CiAgICAgICAgICAgIH0KICAgICAgICB9KSk7CiAgICB9OwogICAgY29uc3QgY2hlY2tEb3duc2NvcGluZyA9IChzY29wZSwgYXVkaWVuY2UpID0+IHsKICAgICAgICBjb25zdCBmaW5kQ29pbmNpZGVuY2UgPSBPYmplY3Qua2V5cyhyZWZyZXNoVG9rZW5zKS5maW5kKChrZXkgPT4gewogICAgICAgICAgICBpZiAoa2V5ICE9PSAibGF0ZXN0X3JlZnJlc2hfdG9rZW4iKSB7CiAgICAgICAgICAgICAgICBjb25zdCBpc1NhbWVBdWRpZW5jZSA9IGNhY2hlS2V5Q29udGFpbnNBdWRpZW5jZShhdWRpZW5jZSwga2V5KTsKICAgICAgICAgICAgICAgIGNvbnN0IHNjb3Blc0tleSA9IGtleS5zcGxpdCgifCIpWzFdLnNwbGl0KCIgIik7CiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRTY29wZXMgPSBzY29wZS5zcGxpdCgiICIpOwogICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVzQXJlSW5jbHVkZWQgPSByZXF1ZXN0ZWRTY29wZXMuZXZlcnkoKGtleSA9PiBzY29wZXNLZXkuaW5jbHVkZXMoa2V5KSkpOwogICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZUF1ZGllbmNlICYmIHNjb3Blc0FyZUluY2x1ZGVkOwogICAgICAgICAgICB9CiAgICAgICAgfSkpOwogICAgICAgIHJldHVybiBmaW5kQ29pbmNpZGVuY2UgPyB0cnVlIDogZmFsc2U7CiAgICB9OwogICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBhc3luYyBfcmVmMiA9PiB7CiAgICAgICAgbGV0IHtkYXRhOiB7dGltZW91dDogdGltZW91dCwgYXV0aDogYXV0aCwgZmV0Y2hVcmw6IGZldGNoVXJsLCBmZXRjaE9wdGlvbnM6IGZldGNoT3B0aW9ucywgdXNlRm9ybURhdGE6IHVzZUZvcm1EYXRhLCB1c2VNcnJ0OiB1c2VNcnJ0fSwgcG9ydHM6IFtwb3J0XX0gPSBfcmVmMjsKICAgICAgICBsZXQgaGVhZGVycyA9IHt9OwogICAgICAgIGxldCBqc29uOwogICAgICAgIGxldCByZWZyZXNoVG9rZW47CiAgICAgICAgY29uc3Qge2F1ZGllbmNlOiBhdWRpZW5jZSwgc2NvcGU6IHNjb3BlfSA9IGF1dGggfHwge307CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc3QgYm9keSA9IHVzZUZvcm1EYXRhID8gZm9ybURhdGFUb09iamVjdChmZXRjaE9wdGlvbnMuYm9keSkgOiBKU09OLnBhcnNlKGZldGNoT3B0aW9ucy5ib2R5KTsKICAgICAgICAgICAgaWYgKCFib2R5LnJlZnJlc2hfdG9rZW4gJiYgYm9keS5ncmFudF90eXBlID09PSAicmVmcmVzaF90b2tlbiIpIHsKICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbiA9IGdldFJlZnJlc2hUb2tlbihhdWRpZW5jZSwgc2NvcGUpOwogICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4gJiYgdXNlTXJydCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdFJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbnNbImxhdGVzdF9yZWZyZXNoX3Rva2VuIl07CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNEb3duc2NvcGluZyA9IGNoZWNrRG93bnNjb3Bpbmcoc2NvcGUsIGF1ZGllbmNlKTsKICAgICAgICAgICAgICAgICAgICBpZiAobGF0ZXN0UmVmcmVzaFRva2VuICYmICFpc0Rvd25zY29waW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbiA9IGxhdGVzdFJlZnJlc2hUb2tlbjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikgewogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nUmVmcmVzaFRva2VuRXJyb3IoYXVkaWVuY2UsIHNjb3BlKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gdXNlRm9ybURhdGEgPyBjcmVhdGVRdWVyeVBhcmFtcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvZHkpLCB7CiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuCiAgICAgICAgICAgICAgICB9KSkgOiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvZHkpLCB7CiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuCiAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IGFib3J0Q29udHJvbGxlcjsKICAgICAgICAgICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7CiAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMuc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZXQgcmVzcG9uc2U7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbIHdhaXQodGltZW91dCksIGZldGNoKGZldGNoVXJsLCBPYmplY3QuYXNzaWduKHt9LCBmZXRjaE9wdGlvbnMpKSBdKTsKICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UoewogICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyKSBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTsKICAgICAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UoewogICAgICAgICAgICAgICAgICAgIGVycm9yOiAiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIgogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGVhZGVycyA9IGZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMpOwogICAgICAgICAgICBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpOwogICAgICAgICAgICBpZiAoanNvbi5yZWZyZXNoX3Rva2VuKSB7CiAgICAgICAgICAgICAgICBpZiAodXNlTXJydCkgewogICAgICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbnNbImxhdGVzdF9yZWZyZXNoX3Rva2VuIl0gPSBqc29uLnJlZnJlc2hfdG9rZW47CiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVmcmVzaFRva2VucyhyZWZyZXNoVG9rZW4sIGpzb24ucmVmcmVzaF90b2tlbik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzZXRSZWZyZXNoVG9rZW4oanNvbi5yZWZyZXNoX3Rva2VuLCBhdWRpZW5jZSwgc2NvcGUpOwogICAgICAgICAgICAgICAgZGVsZXRlIGpzb24ucmVmcmVzaF90b2tlbjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGRlbGV0ZVJlZnJlc2hUb2tlbihhdWRpZW5jZSwgc2NvcGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UoewogICAgICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLAogICAgICAgICAgICAgICAganNvbjoganNvbiwKICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7CiAgICAgICAgICAgICAgICBvazogZmFsc2UsCiAgICAgICAgICAgICAgICBqc29uOiB7CiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLmVycm9yLAogICAgICAgICAgICAgICAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiBlcnJvci5tZXNzYWdlCiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycwogICAgICAgICAgICB9KTsKICAgICAgICB9CiAgICB9OwogICAgewogICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBtZXNzYWdlSGFuZGxlcik7CiAgICB9Cn0pKCk7Cgo=", null, false);

const singlePromiseMap = {};

const singlePromise = (cb, key) => {
    let promise = singlePromiseMap[key];
    if (!promise) {
        promise = cb().finally((() => {
            delete singlePromiseMap[key];
            promise = null;
        }));
        singlePromiseMap[key] = promise;
    }
    return promise;
};

class CacheKeyManifest {
    constructor(cache, clientId) {
        this.cache = cache;
        this.clientId = clientId;
        this.manifestKey = this.createManifestKeyFrom(this.clientId);
    }
    async add(key) {
        var _a;
        const keys = new Set(((_a = await this.cache.get(this.manifestKey)) === null || _a === void 0 ? void 0 : _a.keys) || []);
        keys.add(key);
        await this.cache.set(this.manifestKey, {
            keys: [ ...keys ]
        });
    }
    async remove(key) {
        const entry = await this.cache.get(this.manifestKey);
        if (entry) {
            const keys = new Set(entry.keys);
            keys.delete(key);
            if (keys.size > 0) {
                return await this.cache.set(this.manifestKey, {
                    keys: [ ...keys ]
                });
            }
            return await this.cache.remove(this.manifestKey);
        }
    }
    get() {
        return this.cache.get(this.manifestKey);
    }
    clear() {
        return this.cache.remove(this.manifestKey);
    }
    createManifestKeyFrom(clientId) {
        return "".concat(CACHE_KEY_PREFIX, "::").concat(clientId);
    }
}

const GET_TOKEN_SILENTLY_LOCK_KEY = "auth0.lock.getTokenSilently";

const GET_TOKEN_FROM_IFRAME_LOCK_KEY = "auth0.lock.getTokenFromIFrame";

const buildGetTokenSilentlyLockKey = (clientId, audience) => "".concat(GET_TOKEN_SILENTLY_LOCK_KEY, ".").concat(clientId, ".").concat(audience);

const buildIframeLockKey = clientId => "".concat(GET_TOKEN_FROM_IFRAME_LOCK_KEY, ".").concat(clientId);

const buildOrganizationHintCookieName = clientId => "auth0.".concat(clientId, ".organization_hint");

const OLD_IS_AUTHENTICATED_COOKIE_NAME = "auth0.is.authenticated";

const buildIsAuthenticatedCookieName = clientId => "auth0.".concat(clientId, ".is.authenticated");

const cacheLocationBuilders = {
    memory: () => (new InMemoryCache).enclosedCache,
    localstorage: () => new LocalStorageCache
};

const cacheFactory = location => cacheLocationBuilders[location];

const getAuthorizeParams = (clientOptions, scope, authorizationParams, state, nonce, code_challenge, redirect_uri, response_mode, thumbprint) => Object.assign(Object.assign(Object.assign({
    client_id: clientOptions.clientId
}, clientOptions.authorizationParams), authorizationParams), {
    scope: scopesToRequest(scope, authorizationParams.scope, authorizationParams.audience),
    response_type: "code",
    response_mode: response_mode || "query",
    state: state,
    nonce: nonce,
    redirect_uri: redirect_uri || clientOptions.authorizationParams.redirect_uri,
    code_challenge: code_challenge,
    code_challenge_method: "S256",
    dpop_jkt: thumbprint
});

const patchOpenUrlWithOnRedirect = options => {
    const {openUrl: openUrl, onRedirect: onRedirect} = options, originalOptions = __rest(options, [ "openUrl", "onRedirect" ]);
    const result = Object.assign(Object.assign({}, originalOptions), {
        openUrl: openUrl === false || openUrl ? openUrl : onRedirect
    });
    return result;
};

const allScopesAreIncluded = (scopeToInclude, scopes) => {
    const scopeGroup = (scopes === null || scopes === void 0 ? void 0 : scopes.split(" ")) || [];
    const scopesToInclude = (scopeToInclude === null || scopeToInclude === void 0 ? void 0 : scopeToInclude.split(" ")) || [];
    return scopesToInclude.every((key => scopeGroup.includes(key)));
};

const getMissingScopes = (requestedScope, respondedScope) => {
    const requestedScopes = (requestedScope === null || requestedScope === void 0 ? void 0 : requestedScope.split(" ")) || [];
    const respondedScopes = (respondedScope === null || respondedScope === void 0 ? void 0 : respondedScope.split(" ")) || [];
    const missingScopes = requestedScopes.filter((scope => respondedScopes.indexOf(scope) == -1));
    return missingScopes.join(",");
};

const getScopeToRequest = (useMrrt, authorizationParams, cachedAudience, cachedScope) => {
    var _a;
    if (useMrrt && cachedAudience && cachedScope) {
        if (authorizationParams.audience !== cachedAudience) {
            return authorizationParams.scope;
        }
        const cachedScopes = cachedScope.split(" ");
        const newScopes = ((_a = authorizationParams.scope) === null || _a === void 0 ? void 0 : _a.split(" ")) || [];
        const newScopesAreIncluded = newScopes.every((scope => cachedScopes.includes(scope)));
        return cachedScopes.length >= newScopes.length && newScopesAreIncluded ? cachedScope : authorizationParams.scope;
    }
    return authorizationParams.scope;
};

const isRefreshWithMrrt = (cachedAudience, cachedScope, requestAudience, requestScope) => {
    if (cachedAudience !== requestAudience) {
        return true;
    }
    return !allScopesAreIncluded(requestScope, cachedScope);
};

const VERSION = 1;

const NAME = "auth0-spa-js";

const TABLES = {
    NONCE: "nonce",
    KEYPAIR: "keypair"
};

const AUTH0_NONCE_ID = "auth0";

class DpopStorage {
    constructor(clientId) {
        this.clientId = clientId;
    }
    getVersion() {
        return VERSION;
    }
    createDbHandle() {
        const req = window.indexedDB.open(NAME, this.getVersion());
        return new Promise(((resolve, reject) => {
            req.onupgradeneeded = () => Object.values(TABLES).forEach((t => req.result.createObjectStore(t)));
            req.onerror = () => reject(req.error);
            req.onsuccess = () => resolve(req.result);
        }));
    }
    async getDbHandle() {
        if (!this.dbHandle) {
            this.dbHandle = await this.createDbHandle();
        }
        return this.dbHandle;
    }
    async executeDbRequest(table, mode, requestFactory) {
        const db = await this.getDbHandle();
        const txn = db.transaction(table, mode);
        const store = txn.objectStore(table);
        const request = requestFactory(store);
        return new Promise(((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        }));
    }
    buildKey(id) {
        const finalId = id ? "_".concat(id) : AUTH0_NONCE_ID;
        return "".concat(this.clientId, "::").concat(finalId);
    }
    setNonce(nonce, id) {
        return this.save(TABLES.NONCE, this.buildKey(id), nonce);
    }
    setKeyPair(keyPair) {
        return this.save(TABLES.KEYPAIR, this.buildKey(), keyPair);
    }
    async save(table, key, obj) {
        return void await this.executeDbRequest(table, "readwrite", (table => table.put(obj, key)));
    }
    findNonce(id) {
        return this.find(TABLES.NONCE, this.buildKey(id));
    }
    findKeyPair() {
        return this.find(TABLES.KEYPAIR, this.buildKey());
    }
    find(table, key) {
        return this.executeDbRequest(table, "readonly", (table => table.get(key)));
    }
    async deleteBy(table, predicate) {
        const allKeys = await this.executeDbRequest(table, "readonly", (table => table.getAllKeys()));
        allKeys === null || allKeys === void 0 ? void 0 : allKeys.filter(predicate).map((k => this.executeDbRequest(table, "readwrite", (table => table.delete(k)))));
    }
    deleteByClientId(table, clientId) {
        return this.deleteBy(table, (k => typeof k === "string" && k.startsWith("".concat(clientId, "::"))));
    }
    clearNonces() {
        return this.deleteByClientId(TABLES.NONCE, this.clientId);
    }
    clearKeyPairs() {
        return this.deleteByClientId(TABLES.KEYPAIR, this.clientId);
    }
}

class Dpop {
    constructor(clientId) {
        this.storage = new DpopStorage(clientId);
    }
    getNonce(id) {
        return this.storage.findNonce(id);
    }
    setNonce(nonce, id) {
        return this.storage.setNonce(nonce, id);
    }
    async getOrGenerateKeyPair() {
        let keyPair = await this.storage.findKeyPair();
        if (!keyPair) {
            keyPair = await generateKeyPair();
            await this.storage.setKeyPair(keyPair);
        }
        return keyPair;
    }
    async generateProof(params) {
        const keyPair = await this.getOrGenerateKeyPair();
        return generateProof(Object.assign({
            keyPair: keyPair
        }, params));
    }
    async calculateThumbprint() {
        const keyPair = await this.getOrGenerateKeyPair();
        return calculateThumbprint(keyPair);
    }
    async clear() {
        await Promise.all([ this.storage.clearNonces(), this.storage.clearKeyPairs() ]);
    }
}

var TokenType;

(function(TokenType) {
    TokenType["Bearer"] = "Bearer";
    TokenType["DPoP"] = "DPoP";
})(TokenType || (TokenType = {}));

class Fetcher {
    constructor(config, hooks) {
        this.hooks = hooks;
        this.config = Object.assign(Object.assign({}, config), {
            fetch: config.fetch || (typeof window === "undefined" ? fetch : window.fetch.bind(window))
        });
    }
    isAbsoluteUrl(url) {
        return /^(https?:)?\/\//i.test(url);
    }
    buildUrl(baseUrl, url) {
        if (url) {
            if (this.isAbsoluteUrl(url)) {
                return url;
            }
            if (baseUrl) {
                return "".concat(baseUrl.replace(/\/?\/$/, ""), "/").concat(url.replace(/^\/+/, ""));
            }
        }
        throw new TypeError("`url` must be absolute or `baseUrl` non-empty.");
    }
    getAccessToken(authParams) {
        return this.config.getAccessToken ? this.config.getAccessToken(authParams) : this.hooks.getAccessToken(authParams);
    }
    extractUrl(info) {
        if (typeof info === "string") {
            return info;
        }
        if (info instanceof URL) {
            return info.href;
        }
        return info.url;
    }
    buildBaseRequest(info, init) {
        if (!this.config.baseUrl) {
            return new Request(info, init);
        }
        const finalUrl = this.buildUrl(this.config.baseUrl, this.extractUrl(info));
        const finalInfo = info instanceof Request ? new Request(finalUrl, info) : finalUrl;
        return new Request(finalInfo, init);
    }
    setAuthorizationHeader(request, accessToken) {
        let tokenType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TokenType.Bearer;
        request.headers.set("authorization", "".concat(tokenType, " ").concat(accessToken));
    }
    async setDpopProofHeader(request, accessToken) {
        if (!this.config.dpopNonceId) {
            return;
        }
        const dpopNonce = await this.hooks.getDpopNonce();
        const dpopProof = await this.hooks.generateDpopProof({
            accessToken: accessToken,
            method: request.method,
            nonce: dpopNonce,
            url: request.url
        });
        request.headers.set("dpop", dpopProof);
    }
    async prepareRequest(request, authParams) {
        const accessTokenResponse = await this.getAccessToken(authParams);
        let tokenType;
        let accessToken;
        if (typeof accessTokenResponse === "string") {
            tokenType = this.config.dpopNonceId ? TokenType.DPoP : TokenType.Bearer;
            accessToken = accessTokenResponse;
        } else {
            tokenType = accessTokenResponse.token_type;
            accessToken = accessTokenResponse.access_token;
        }
        this.setAuthorizationHeader(request, accessToken, tokenType);
        if (tokenType === TokenType.DPoP) {
            await this.setDpopProofHeader(request, accessToken);
        }
    }
    getHeader(headers, name) {
        if (Array.isArray(headers)) {
            return new Headers(headers).get(name) || "";
        }
        if (typeof headers.get === "function") {
            return headers.get(name) || "";
        }
        return headers[name] || "";
    }
    hasUseDpopNonceError(response) {
        if (response.status !== 401) {
            return false;
        }
        const wwwAuthHeader = this.getHeader(response.headers, "www-authenticate");
        return wwwAuthHeader.includes("invalid_dpop_nonce") || wwwAuthHeader.includes("use_dpop_nonce");
    }
    async handleResponse(response, callbacks) {
        const newDpopNonce = this.getHeader(response.headers, DPOP_NONCE_HEADER);
        if (newDpopNonce) {
            await this.hooks.setDpopNonce(newDpopNonce);
        }
        if (!this.hasUseDpopNonceError(response)) {
            return response;
        }
        if (!newDpopNonce || !callbacks.onUseDpopNonceError) {
            throw new UseDpopNonceError(newDpopNonce);
        }
        return callbacks.onUseDpopNonceError();
    }
    async internalFetchWithAuth(info, init, callbacks, authParams) {
        const request = this.buildBaseRequest(info, init);
        await this.prepareRequest(request, authParams);
        const response = await this.config.fetch(request);
        return this.handleResponse(response, callbacks);
    }
    fetchWithAuth(info, init, authParams) {
        const callbacks = {
            onUseDpopNonceError: () => this.internalFetchWithAuth(info, init, Object.assign(Object.assign({}, callbacks), {
                onUseDpopNonceError: undefined
            }), authParams)
        };
        return this.internalFetchWithAuth(info, init, callbacks, authParams);
    }
}

class MyAccountApiClient {
    constructor(myAccountFetcher, apiBase) {
        this.myAccountFetcher = myAccountFetcher;
        this.apiBase = apiBase;
    }
    async connectAccount(params) {
        const res = await this.myAccountFetcher.fetchWithAuth("".concat(this.apiBase, "v1/connected-accounts/connect"), {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(params)
        });
        return this._handleResponse(res);
    }
    async completeAccount(params) {
        const res = await this.myAccountFetcher.fetchWithAuth("".concat(this.apiBase, "v1/connected-accounts/complete"), {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(params)
        });
        return this._handleResponse(res);
    }
    async _handleResponse(res) {
        let body;
        try {
            body = await res.text();
            body = JSON.parse(body);
        } catch (err) {
            throw new MyAccountApiError({
                type: "invalid_json",
                status: res.status,
                title: "Invalid JSON response",
                detail: body || String(err)
            });
        }
        if (res.ok) {
            return body;
        } else {
            throw new MyAccountApiError(body);
        }
    }
}

class MyAccountApiError extends Error {
    constructor(_ref) {
        let {type: type, status: status, title: title, detail: detail, validation_errors: validation_errors} = _ref;
        super(detail);
        this.name = "MyAccountApiError";
        this.type = type;
        this.status = status;
        this.title = title;
        this.detail = detail;
        this.validation_errors = validation_errors;
        Object.setPrototypeOf(this, MyAccountApiError.prototype);
    }
}

const FACTOR_MAPPING = {
    otp: {
        authenticatorTypes: [ "otp" ]
    },
    sms: {
        authenticatorTypes: [ "oob" ],
        oobChannels: [ "sms" ]
    },
    email: {
        authenticatorTypes: [ "oob" ],
        oobChannels: [ "email" ]
    },
    push: {
        authenticatorTypes: [ "oob" ],
        oobChannels: [ "auth0" ]
    },
    voice: {
        authenticatorTypes: [ "oob" ],
        oobChannels: [ "voice" ]
    }
};

const MfaGrantTypes = {
    OTP: "http://auth0.com/oauth/grant-type/mfa-otp",
    OOB: "http://auth0.com/oauth/grant-type/mfa-oob",
    RECOVERY_CODE: "http://auth0.com/oauth/grant-type/mfa-recovery-code"
};

function getAuthJsEnrollParams(params) {
    const mapping = FACTOR_MAPPING[params.factorType];
    return Object.assign(Object.assign(Object.assign({
        mfaToken: params.mfaToken,
        authenticatorTypes: mapping.authenticatorTypes
    }, mapping.oobChannels && {
        oobChannels: mapping.oobChannels
    }), "phoneNumber" in params && {
        phoneNumber: params.phoneNumber
    }), "email" in params && {
        email: params.email
    });
}

function getGrantType(params) {
    if ("otp" in params && params.otp) {
        return MfaGrantTypes.OTP;
    }
    if ("oobCode" in params && params.oobCode) {
        return MfaGrantTypes.OOB;
    }
    if ("recoveryCode" in params && params.recoveryCode) {
        return MfaGrantTypes.RECOVERY_CODE;
    }
    return undefined;
}

function _OverloadYield(e, d) {
    this.v = e, this.k = d;
}

function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
}

function _awaitAsyncGenerator(e) {
    return new _OverloadYield(e, 0);
}

function _checkPrivateRedeclaration(e, t) {
    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}

function _classPrivateFieldGet2(s, a) {
    return s.get(_assertClassBrand(s, a));
}

function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
}

function _classPrivateFieldSet2(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
}

function _classPrivateMethodInitSpec(e, a) {
    _checkPrivateRedeclaration(e, a), a.add(e);
}

function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}

function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter((function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        }))), t.push.apply(t, o);
    }
    return t;
}

function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach((function(r) {
            _defineProperty(e, r, t[r]);
        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach((function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        }));
    }
    return e;
}

function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}

function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}

function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}

function _wrapAsyncGenerator(e) {
    return function() {
        return new AsyncGenerator(e.apply(this, arguments));
    };
}

function AsyncGenerator(e) {
    var r, t;
    function resume(r, t) {
        try {
            var n = e[r](t), o = n.value, u = o instanceof _OverloadYield;
            Promise.resolve(u ? o.v : o).then((function(t) {
                if (u) {
                    var i = "return" === r ? "return" : "next";
                    if (!o.k || t.done) return resume(i, t);
                    t = e[i](t).value;
                }
                settle(n.done ? "return" : "normal", t);
            }), (function(e) {
                resume("throw", e);
            }));
        } catch (e) {
            settle("throw", e);
        }
    }
    function settle(e, n) {
        switch (e) {
          case "return":
            r.resolve({
                value: n,
                done: !0
            });
            break;

          case "throw":
            r.reject(n);
            break;

          default:
            r.resolve({
                value: n,
                done: !1
            });
        }
        (r = r.next) ? resume(r.key, r.arg) : t = null;
    }
    this._invoke = function(e, n) {
        return new Promise((function(o, u) {
            var i = {
                key: e,
                arg: n,
                resolve: o,
                reject: u,
                next: null
            };
            t ? t = t.next = i : (r = t = i, resume(e, n));
        }));
    }, "function" != typeof e.return && (this.return = void 0);
}

AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
    return this;
}, AsyncGenerator.prototype.next = function(e) {
    return this._invoke("next", e);
}, AsyncGenerator.prototype.throw = function(e) {
    return this._invoke("throw", e);
}, AsyncGenerator.prototype.return = function(e) {
    return this._invoke("return", e);
};

var _navigator$userAgent$2, _navigator$userAgent$$2;

let USER_AGENT$2;

if (typeof navigator === "undefined" || !((_navigator$userAgent$2 = navigator.userAgent) !== null && _navigator$userAgent$2 !== void 0 && (_navigator$userAgent$$2 = _navigator$userAgent$2.startsWith) !== null && _navigator$userAgent$$2 !== void 0 && _navigator$userAgent$$2.call(_navigator$userAgent$2, "Mozilla/5.0 "))) {
    const NAME = "oauth4webapi";
    const VERSION = "v3.8.3";
    USER_AGENT$2 = "".concat(NAME, "/").concat(VERSION);
}

function looseInstanceOf(input, expected) {
    if (input == null) {
        return false;
    }
    try {
        return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];
    } catch (_unused) {
        return false;
    }
}

const ERR_INVALID_ARG_VALUE$1 = "ERR_INVALID_ARG_VALUE";

const ERR_INVALID_ARG_TYPE$1 = "ERR_INVALID_ARG_TYPE";

function CodedTypeError$1(message, code, cause) {
    const err = new TypeError(message, {
        cause: cause
    });
    Object.assign(err, {
        code: code
    });
    return err;
}

const allowInsecureRequests$1 = Symbol();

const clockSkew = Symbol();

const clockTolerance = Symbol();

const customFetch$2 = Symbol();

const modifyAssertion = Symbol();

const jweDecrypt = Symbol();

const encoder$1 = new TextEncoder;

const decoder$1 = new TextDecoder;

function buf(input) {
    if (typeof input === "string") {
        return encoder$1.encode(input);
    }
    return decoder$1.decode(input);
}

let encodeBase64Url;

if (Uint8Array.prototype.toBase64) {
    encodeBase64Url = input => {
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        return input.toBase64({
            alphabet: "base64url",
            omitPadding: true
        });
    };
} else {
    const CHUNK_SIZE = 32768;
    encodeBase64Url = input => {
        if (input instanceof ArrayBuffer) {
            input = new Uint8Array(input);
        }
        const arr = [];
        for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {
            arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));
        }
        return btoa(arr.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
}

let decodeBase64Url;

if (Uint8Array.fromBase64) {
    decodeBase64Url = input => {
        try {
            return Uint8Array.fromBase64(input, {
                alphabet: "base64url"
            });
        } catch (cause) {
            throw CodedTypeError$1("The input to be decoded is not correctly encoded.", ERR_INVALID_ARG_VALUE$1, cause);
        }
    };
} else {
    decodeBase64Url = input => {
        try {
            const binary = atob(input.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, ""));
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        } catch (cause) {
            throw CodedTypeError$1("The input to be decoded is not correctly encoded.", ERR_INVALID_ARG_VALUE$1, cause);
        }
    };
}

function b64u(input) {
    if (typeof input === "string") {
        return decodeBase64Url(input);
    }
    return encodeBase64Url(input);
}

class UnsupportedOperationError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr;
        super(message, options);
        _defineProperty(this, "code", void 0);
        this.name = this.constructor.name;
        this.code = UNSUPPORTED_OPERATION;
        (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, this, this.constructor);
    }
}

class OperationProcessingError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr2;
        super(message, options);
        _defineProperty(this, "code", void 0);
        this.name = this.constructor.name;
        if (options !== null && options !== void 0 && options.code) {
            this.code = options === null || options === void 0 ? void 0 : options.code;
        }
        (_Error$captureStackTr2 = Error.captureStackTrace) === null || _Error$captureStackTr2 === void 0 || _Error$captureStackTr2.call(Error, this, this.constructor);
    }
}

function OPE(message, code, cause) {
    return new OperationProcessingError(message, {
        code: code,
        cause: cause
    });
}

function assertCryptoKey(key, it) {
    if (!(key instanceof CryptoKey)) {
        throw CodedTypeError$1("".concat(it, " must be a CryptoKey"), ERR_INVALID_ARG_TYPE$1);
    }
}

function assertPrivateKey(key, it) {
    assertCryptoKey(key, it);
    if (key.type !== "private") {
        throw CodedTypeError$1("".concat(it, " must be a private CryptoKey"), ERR_INVALID_ARG_VALUE$1);
    }
}

function isJsonObject(input) {
    if (input === null || typeof input !== "object" || Array.isArray(input)) {
        return false;
    }
    return true;
}

function prepareHeaders(input) {
    if (looseInstanceOf(input, Headers)) {
        input = Object.fromEntries(input.entries());
    }
    const headers = new Headers(input !== null && input !== void 0 ? input : {});
    if (USER_AGENT$2 && !headers.has("user-agent")) {
        headers.set("user-agent", USER_AGENT$2);
    }
    if (headers.has("authorization")) {
        throw CodedTypeError$1('"options.headers" must not include the "authorization" header name', ERR_INVALID_ARG_VALUE$1);
    }
    return headers;
}

function signal$1(url, value) {
    if (value !== undefined) {
        if (typeof value === "function") {
            value = value(url.href);
        }
        if (!(value instanceof AbortSignal)) {
            throw CodedTypeError$1('"options.signal" must return or be an instance of AbortSignal', ERR_INVALID_ARG_TYPE$1);
        }
        return value;
    }
    return undefined;
}

function replaceDoubleSlash(pathname) {
    if (pathname.includes("//")) {
        return pathname.replace("//", "/");
    }
    return pathname;
}

function prependWellKnown(url, wellKnown) {
    let allowTerminatingSlash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (url.pathname === "/") {
        url.pathname = wellKnown;
    } else {
        url.pathname = replaceDoubleSlash("".concat(wellKnown, "/").concat(allowTerminatingSlash ? url.pathname : url.pathname.replace(/(\/)$/, "")));
    }
    return url;
}

function appendWellKnown(url, wellKnown) {
    url.pathname = replaceDoubleSlash("".concat(url.pathname, "/").concat(wellKnown));
    return url;
}

async function performDiscovery$1(input, urlName, transform, options) {
    if (!(input instanceof URL)) {
        throw CodedTypeError$1('"'.concat(urlName, '" must be an instance of URL'), ERR_INVALID_ARG_TYPE$1);
    }
    checkProtocol(input, (options === null || options === void 0 ? void 0 : options[allowInsecureRequests$1]) !== true);
    const url = transform(new URL(input.href));
    const headers = prepareHeaders(options === null || options === void 0 ? void 0 : options.headers);
    headers.set("accept", "application/json");
    return ((options === null || options === void 0 ? void 0 : options[customFetch$2]) || fetch)(url.href, {
        body: undefined,
        headers: Object.fromEntries(headers.entries()),
        method: "GET",
        redirect: "manual",
        signal: signal$1(url, options === null || options === void 0 ? void 0 : options.signal)
    });
}

async function discoveryRequest(issuerIdentifier, options) {
    return performDiscovery$1(issuerIdentifier, "issuerIdentifier", (url => {
        switch (options === null || options === void 0 ? void 0 : options.algorithm) {
          case undefined:
          case "oidc":
            appendWellKnown(url, ".well-known/openid-configuration");
            break;

          case "oauth2":
            prependWellKnown(url, ".well-known/oauth-authorization-server");
            break;

          default:
            throw CodedTypeError$1('"options.algorithm" must be "oidc" (default), or "oauth2"', ERR_INVALID_ARG_VALUE$1);
        }
        return url;
    }), options);
}

function assertNumber(input, allow0, it, code, cause) {
    try {
        if (typeof input !== "number" || !Number.isFinite(input)) {
            throw CodedTypeError$1("".concat(it, " must be a number"), ERR_INVALID_ARG_TYPE$1, cause);
        }
        if (input > 0) return;
        if (allow0) {
            if (input !== 0) {
                throw CodedTypeError$1("".concat(it, " must be a non-negative number"), ERR_INVALID_ARG_VALUE$1, cause);
            }
            return;
        }
        throw CodedTypeError$1("".concat(it, " must be a positive number"), ERR_INVALID_ARG_VALUE$1, cause);
    } catch (err) {
        if (code) {
            throw OPE(err.message, code, cause);
        }
        throw err;
    }
}

function assertString$1(input, it, code, cause) {
    try {
        if (typeof input !== "string") {
            throw CodedTypeError$1("".concat(it, " must be a string"), ERR_INVALID_ARG_TYPE$1, cause);
        }
        if (input.length === 0) {
            throw CodedTypeError$1("".concat(it, " must not be empty"), ERR_INVALID_ARG_VALUE$1, cause);
        }
    } catch (err) {
        if (code) {
            throw OPE(err.message, code, cause);
        }
        throw err;
    }
}

async function processDiscoveryResponse(expectedIssuerIdentifier, response) {
    const expected = expectedIssuerIdentifier;
    if (!(expected instanceof URL) && expected !== _nodiscoverycheck) {
        throw CodedTypeError$1('"expectedIssuerIdentifier" must be an instance of URL', ERR_INVALID_ARG_TYPE$1);
    }
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError$1('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE$1);
    }
    if (response.status !== 200) {
        throw OPE('"response" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', RESPONSE_IS_NOT_CONFORM, response);
    }
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString$1(json.issuer, '"response" body "issuer" property', INVALID_RESPONSE, {
        body: json
    });
    if (expected !== _nodiscoverycheck && new URL(json.issuer).href !== expected.href) {
        throw OPE('"response" body "issuer" property does not match the expected value', JSON_ATTRIBUTE_COMPARISON, {
            expected: expected.href,
            body: json,
            attribute: "issuer"
        });
    }
    return json;
}

function assertApplicationJson(response) {
    assertContentType(response, "application/json");
}

function notJson(response) {
    let msg = '"response" content-type must be ';
    for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        types[_key - 1] = arguments[_key];
    }
    if (types.length > 2) {
        const last = types.pop();
        msg += "".concat(types.join(", "), ", or ").concat(last);
    } else if (types.length === 2) {
        msg += "".concat(types[0], " or ").concat(types[1]);
    } else {
        msg += types[0];
    }
    return OPE(msg, RESPONSE_IS_NOT_JSON, response);
}

function assertContentType(response, contentType) {
    if (getContentType(response) !== contentType) {
        throw notJson(response, contentType);
    }
}

function randomBytes() {
    return b64u(crypto.getRandomValues(new Uint8Array(32)));
}

function generateRandomCodeVerifier() {
    return randomBytes();
}

async function calculatePKCECodeChallenge$1(codeVerifier) {
    assertString$1(codeVerifier, "codeVerifier");
    return b64u(await crypto.subtle.digest("SHA-256", buf(codeVerifier)));
}

function getKeyAndKid(input) {
    if (input instanceof CryptoKey) {
        return {
            key: input
        };
    }
    if (!((input === null || input === void 0 ? void 0 : input.key) instanceof CryptoKey)) {
        return {};
    }
    if (input.kid !== undefined) {
        assertString$1(input.kid, '"kid"');
    }
    return {
        key: input.key,
        kid: input.kid
    };
}

function psAlg(key) {
    switch (key.algorithm.hash.name) {
      case "SHA-256":
        return "PS256";

      case "SHA-384":
        return "PS384";

      case "SHA-512":
        return "PS512";

      default:
        throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name", {
            cause: key
        });
    }
}

function rsAlg(key) {
    switch (key.algorithm.hash.name) {
      case "SHA-256":
        return "RS256";

      case "SHA-384":
        return "RS384";

      case "SHA-512":
        return "RS512";

      default:
        throw new UnsupportedOperationError("unsupported RsaHashedKeyAlgorithm hash name", {
            cause: key
        });
    }
}

function esAlg(key) {
    switch (key.algorithm.namedCurve) {
      case "P-256":
        return "ES256";

      case "P-384":
        return "ES384";

      case "P-521":
        return "ES512";

      default:
        throw new UnsupportedOperationError("unsupported EcKeyAlgorithm namedCurve", {
            cause: key
        });
    }
}

function keyToJws(key) {
    switch (key.algorithm.name) {
      case "RSA-PSS":
        return psAlg(key);

      case "RSASSA-PKCS1-v1_5":
        return rsAlg(key);

      case "ECDSA":
        return esAlg(key);

      case "Ed25519":
      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
        return key.algorithm.name;

      case "EdDSA":
        return "Ed25519";

      default:
        throw new UnsupportedOperationError("unsupported CryptoKey algorithm name", {
            cause: key
        });
    }
}

function getClockSkew(client) {
    const skew = client === null || client === void 0 ? void 0 : client[clockSkew];
    return typeof skew === "number" && Number.isFinite(skew) ? skew : 0;
}

function getClockTolerance(client) {
    const tolerance = client === null || client === void 0 ? void 0 : client[clockTolerance];
    return typeof tolerance === "number" && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;
}

function epochTime() {
    return Math.floor(Date.now() / 1e3);
}

function assertAs(as) {
    if (typeof as !== "object" || as === null) {
        throw CodedTypeError$1('"as" must be an object', ERR_INVALID_ARG_TYPE$1);
    }
    assertString$1(as.issuer, '"as.issuer"');
}

function assertClient(client) {
    if (typeof client !== "object" || client === null) {
        throw CodedTypeError$1('"client" must be an object', ERR_INVALID_ARG_TYPE$1);
    }
    assertString$1(client.client_id, '"client.client_id"');
}

function ClientSecretPost$1(clientSecret) {
    assertString$1(clientSecret, '"clientSecret"');
    return (_as, client, body, _headers) => {
        body.set("client_id", client.client_id);
        body.set("client_secret", clientSecret);
    };
}

function clientAssertionPayload(as, client) {
    const now = epochTime() + getClockSkew(client);
    return {
        jti: randomBytes(),
        aud: as.issuer,
        exp: now + 60,
        iat: now,
        nbf: now,
        iss: client.client_id,
        sub: client.client_id
    };
}

function PrivateKeyJwt$1(clientPrivateKey, options) {
    const {key: key, kid: kid} = getKeyAndKid(clientPrivateKey);
    assertPrivateKey(key, '"clientPrivateKey.key"');
    return async (as, client, body, _headers) => {
        var _options$modifyAssert;
        const header = {
            alg: keyToJws(key),
            kid: kid
        };
        const payload = clientAssertionPayload(as, client);
        options === null || options === void 0 || (_options$modifyAssert = options[modifyAssertion]) === null || _options$modifyAssert === void 0 || _options$modifyAssert.call(options, header, payload);
        body.set("client_id", client.client_id);
        body.set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer");
        body.set("client_assertion", await signJwt(header, payload, key));
    };
}

function None$1() {
    return (_as, client, body, _headers) => {
        body.set("client_id", client.client_id);
    };
}

function TlsClientAuth$1() {
    return None$1();
}

async function signJwt(header, payload, key) {
    if (!key.usages.includes("sign")) {
        throw CodedTypeError$1('CryptoKey instances used for signing assertions must include "sign" in their "usages"', ERR_INVALID_ARG_VALUE$1);
    }
    const input = "".concat(b64u(buf(JSON.stringify(header))), ".").concat(b64u(buf(JSON.stringify(payload))));
    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));
    return "".concat(input, ".").concat(signature);
}

const URLParse = URL.parse ? (url, base) => URL.parse(url, base) : (url, base) => {
    try {
        return new URL(url, base);
    } catch (_unused2) {
        return null;
    }
};

function checkProtocol(url, enforceHttps) {
    if (enforceHttps && url.protocol !== "https:") {
        throw OPE("only requests to HTTPS are allowed", HTTP_REQUEST_FORBIDDEN, url);
    }
    if (url.protocol !== "https:" && url.protocol !== "http:") {
        throw OPE("only HTTP and HTTPS requests are allowed", REQUEST_PROTOCOL_FORBIDDEN, url);
    }
}

function validateEndpoint(value, endpoint, useMtlsAlias, enforceHttps) {
    let url;
    if (typeof value !== "string" || !(url = URLParse(value))) {
        throw OPE("authorization server metadata does not contain a valid ".concat(useMtlsAlias ? '"as.mtls_endpoint_aliases.'.concat(endpoint, '"') : '"as.'.concat(endpoint, '"')), value === undefined ? MISSING_SERVER_METADATA : INVALID_SERVER_METADATA, {
            attribute: useMtlsAlias ? "mtls_endpoint_aliases.".concat(endpoint) : endpoint
        });
    }
    checkProtocol(url, enforceHttps);
    return url;
}

function resolveEndpoint(as, endpoint, useMtlsAlias, enforceHttps) {
    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {
        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias, enforceHttps);
    }
    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias, enforceHttps);
}

async function pushedAuthorizationRequest(as, client, clientAuthentication, parameters, options) {
    var _options$DPoP;
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, "pushed_authorization_request_endpoint", client.use_mtls_endpoint_aliases, (options === null || options === void 0 ? void 0 : options[allowInsecureRequests$1]) !== true);
    const body = new URLSearchParams(parameters);
    body.set("client_id", client.client_id);
    const headers = prepareHeaders(options === null || options === void 0 ? void 0 : options.headers);
    headers.set("accept", "application/json");
    if ((options === null || options === void 0 ? void 0 : options.DPoP) !== undefined) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, "POST");
    }
    const response = await authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
    options === null || options === void 0 || (_options$DPoP = options.DPoP) === null || _options$DPoP === void 0 || _options$DPoP.cacheNonce(response, url);
    return response;
}

function isDPoPNonceError(err) {
    if (err instanceof WWWAuthenticateChallengeError) {
        const {0: challenge, length: length} = err.cause;
        return length === 1 && challenge.scheme === "dpop" && challenge.parameters.error === "use_dpop_nonce";
    }
    if (err instanceof ResponseBodyError) {
        return err.error === "use_dpop_nonce";
    }
    return false;
}

class ResponseBodyError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr3;
        super(message, options);
        _defineProperty(this, "cause", void 0);
        _defineProperty(this, "code", void 0);
        _defineProperty(this, "error", void 0);
        _defineProperty(this, "status", void 0);
        _defineProperty(this, "error_description", void 0);
        _defineProperty(this, "response", void 0);
        this.name = this.constructor.name;
        this.code = RESPONSE_BODY_ERROR;
        this.cause = options.cause;
        this.error = options.cause.error;
        this.status = options.response.status;
        this.error_description = options.cause.error_description;
        Object.defineProperty(this, "response", {
            enumerable: false,
            value: options.response
        });
        (_Error$captureStackTr3 = Error.captureStackTrace) === null || _Error$captureStackTr3 === void 0 || _Error$captureStackTr3.call(Error, this, this.constructor);
    }
}

class AuthorizationResponseError extends Error {
    constructor(message, options) {
        var _options$cause$get, _Error$captureStackTr4;
        super(message, options);
        _defineProperty(this, "cause", void 0);
        _defineProperty(this, "code", void 0);
        _defineProperty(this, "error", void 0);
        _defineProperty(this, "error_description", void 0);
        this.name = this.constructor.name;
        this.code = AUTHORIZATION_RESPONSE_ERROR;
        this.cause = options.cause;
        this.error = options.cause.get("error");
        this.error_description = (_options$cause$get = options.cause.get("error_description")) !== null && _options$cause$get !== void 0 ? _options$cause$get : undefined;
        (_Error$captureStackTr4 = Error.captureStackTrace) === null || _Error$captureStackTr4 === void 0 || _Error$captureStackTr4.call(Error, this, this.constructor);
    }
}

class WWWAuthenticateChallengeError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr5;
        super(message, options);
        _defineProperty(this, "cause", void 0);
        _defineProperty(this, "code", void 0);
        _defineProperty(this, "response", void 0);
        _defineProperty(this, "status", void 0);
        this.name = this.constructor.name;
        this.code = WWW_AUTHENTICATE_CHALLENGE;
        this.cause = options.cause;
        this.status = options.response.status;
        this.response = options.response;
        Object.defineProperty(this, "response", {
            enumerable: false
        });
        (_Error$captureStackTr5 = Error.captureStackTrace) === null || _Error$captureStackTr5 === void 0 || _Error$captureStackTr5.call(Error, this, this.constructor);
    }
}

const tokenMatch = "[a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+";

const token68Match = "[a-zA-Z0-9\\-\\._\\~\\+\\/]+={0,2}";

const quotedMatch = '"((?:[^"\\\\]|\\\\[\\s\\S])*)"';

const quotedParamMatcher = "(" + tokenMatch + ")\\s*=\\s*" + quotedMatch;

const paramMatcher = "(" + tokenMatch + ")\\s*=\\s*(" + tokenMatch + ")";

const schemeRE = new RegExp("^[,\\s]*(" + tokenMatch + ")");

const quotedParamRE = new RegExp("^[,\\s]*" + quotedParamMatcher + "[,\\s]*(.*)");

const unquotedParamRE = new RegExp("^[,\\s]*" + paramMatcher + "[,\\s]*(.*)");

const token68ParamRE = new RegExp("^(" + token68Match + ")(?:$|[,\\s])(.*)");

function parseWwwAuthenticateChallenges(response) {
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError$1('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE$1);
    }
    const header = response.headers.get("www-authenticate");
    if (header === null) {
        return undefined;
    }
    const challenges = [];
    let rest = header;
    while (rest) {
        var _match;
        let match = rest.match(schemeRE);
        const scheme = (_match = match) === null || _match === void 0 ? void 0 : _match["1"].toLowerCase();
        if (!scheme) {
            return undefined;
        }
        const afterScheme = rest.substring(match[0].length);
        if (afterScheme && !afterScheme.match(/^[\s,]/)) {
            return undefined;
        }
        const spaceMatch = afterScheme.match(/^\s+(.*)$/);
        const hasParameters = !!spaceMatch;
        rest = spaceMatch ? spaceMatch[1] : undefined;
        const parameters = {};
        let token68;
        if (hasParameters) {
            while (rest) {
                let key;
                let value;
                if (match = rest.match(quotedParamRE)) {
                    [, key, value, rest] = match;
                    if (value.includes("\\")) {
                        try {
                            value = JSON.parse('"'.concat(value, '"'));
                        } catch (_unused4) {}
                    }
                    parameters[key.toLowerCase()] = value;
                    continue;
                }
                if (match = rest.match(unquotedParamRE)) {
                    [, key, value, rest] = match;
                    parameters[key.toLowerCase()] = value;
                    continue;
                }
                if (match = rest.match(token68ParamRE)) {
                    if (Object.keys(parameters).length) {
                        break;
                    }
                    [, token68, rest] = match;
                    break;
                }
                return undefined;
            }
        } else {
            rest = afterScheme || undefined;
        }
        const challenge = {
            scheme: scheme,
            parameters: parameters
        };
        if (token68) {
            challenge.token68 = token68;
        }
        challenges.push(challenge);
    }
    if (!challenges.length) {
        return undefined;
    }
    return challenges;
}

async function processPushedAuthorizationResponse(as, client, response) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError$1('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE$1);
    }
    await checkOAuthBodyError(response, 201, "Pushed Authorization Request Endpoint");
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString$1(json.request_uri, '"response" body "request_uri" property', INVALID_RESPONSE, {
        body: json
    });
    let expiresIn = typeof json.expires_in !== "number" ? parseFloat(json.expires_in) : json.expires_in;
    assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
        body: json
    });
    json.expires_in = expiresIn;
    return json;
}

async function parseOAuthResponseErrorBody(response) {
    if (response.status > 399 && response.status < 500) {
        assertReadableResponse(response);
        assertApplicationJson(response);
        try {
            const json = await response.clone().json();
            if (isJsonObject(json) && typeof json.error === "string" && json.error.length) {
                return json;
            }
        } catch (_unused5) {}
    }
    return undefined;
}

async function checkOAuthBodyError(response, expected, label) {
    if (response.status !== expected) {
        checkAuthenticationChallenges(response);
        let err;
        if (err = await parseOAuthResponseErrorBody(response)) {
            var _response$body;
            await ((_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.cancel());
            throw new ResponseBodyError("server responded with an error in the response body", {
                cause: err,
                response: response
            });
        }
        throw OPE('"response" is not a conform '.concat(label, " response (unexpected HTTP status code)"), RESPONSE_IS_NOT_CONFORM, response);
    }
}

function assertDPoP(option) {
    if (!branded.has(option)) {
        throw CodedTypeError$1('"options.DPoP" is not a valid DPoPHandle', ERR_INVALID_ARG_VALUE$1);
    }
}

function getContentType(input) {
    var _input$headers$get;
    return (_input$headers$get = input.headers.get("content-type")) === null || _input$headers$get === void 0 ? void 0 : _input$headers$get.split(";")[0];
}

async function authenticatedRequest(as, client, clientAuthentication, url, body, headers, options) {
    await clientAuthentication(as, client, body, headers);
    headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
    return ((options === null || options === void 0 ? void 0 : options[customFetch$2]) || fetch)(url.href, {
        body: body,
        headers: Object.fromEntries(headers.entries()),
        method: "POST",
        redirect: "manual",
        signal: signal$1(url, options === null || options === void 0 ? void 0 : options.signal)
    });
}

async function tokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {
    var _options$DPoP3;
    const url = resolveEndpoint(as, "token_endpoint", client.use_mtls_endpoint_aliases, (options === null || options === void 0 ? void 0 : options[allowInsecureRequests$1]) !== true);
    parameters.set("grant_type", grantType);
    const headers = prepareHeaders(options === null || options === void 0 ? void 0 : options.headers);
    headers.set("accept", "application/json");
    if ((options === null || options === void 0 ? void 0 : options.DPoP) !== undefined) {
        assertDPoP(options.DPoP);
        await options.DPoP.addProof(url, headers, "POST");
    }
    const response = await authenticatedRequest(as, client, clientAuthentication, url, parameters, headers, options);
    options === null || options === void 0 || (_options$DPoP3 = options.DPoP) === null || _options$DPoP3 === void 0 || _options$DPoP3.cacheNonce(response, url);
    return response;
}

async function refreshTokenGrantRequest(as, client, clientAuthentication, refreshToken, options) {
    assertAs(as);
    assertClient(client);
    assertString$1(refreshToken, '"refreshToken"');
    const parameters = new URLSearchParams(options === null || options === void 0 ? void 0 : options.additionalParameters);
    parameters.set("refresh_token", refreshToken);
    return tokenEndpointRequest(as, client, clientAuthentication, "refresh_token", parameters, options);
}

const idTokenClaims = new WeakMap;

const jwtRefs = new WeakMap;

function getValidatedIdTokenClaims(ref) {
    if (!ref.id_token) {
        return undefined;
    }
    const claims = idTokenClaims.get(ref);
    if (!claims) {
        throw CodedTypeError$1('"ref" was already garbage collected or did not resolve from the proper sources', ERR_INVALID_ARG_VALUE$1);
    }
    return claims;
}

async function processGenericAccessTokenResponse(as, client, response, additionalRequiredIdTokenClaims, decryptFn, recognizedTokenTypes) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError$1('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE$1);
    }
    await checkOAuthBodyError(response, 200, "Token Endpoint");
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString$1(json.access_token, '"response" body "access_token" property', INVALID_RESPONSE, {
        body: json
    });
    assertString$1(json.token_type, '"response" body "token_type" property', INVALID_RESPONSE, {
        body: json
    });
    json.token_type = json.token_type.toLowerCase();
    if (json.expires_in !== undefined) {
        let expiresIn = typeof json.expires_in !== "number" ? parseFloat(json.expires_in) : json.expires_in;
        assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
            body: json
        });
        json.expires_in = expiresIn;
    }
    if (json.refresh_token !== undefined) {
        assertString$1(json.refresh_token, '"response" body "refresh_token" property', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.scope !== undefined && typeof json.scope !== "string") {
        throw OPE('"response" body "scope" property must be a string', INVALID_RESPONSE, {
            body: json
        });
    }
    if (json.id_token !== undefined) {
        assertString$1(json.id_token, '"response" body "id_token" property', INVALID_RESPONSE, {
            body: json
        });
        const requiredClaims = [ "aud", "exp", "iat", "iss", "sub" ];
        if (client.require_auth_time === true) {
            requiredClaims.push("auth_time");
        }
        if (client.default_max_age !== undefined) {
            assertNumber(client.default_max_age, true, '"client.default_max_age"');
            requiredClaims.push("auth_time");
        }
        if (additionalRequiredIdTokenClaims !== null && additionalRequiredIdTokenClaims !== void 0 && additionalRequiredIdTokenClaims.length) {
            requiredClaims.push(...additionalRequiredIdTokenClaims);
        }
        const {claims: claims, jwt: jwt} = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported, "RS256"), getClockSkew(client), getClockTolerance(client), decryptFn).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as)).then(validateAudience.bind(undefined, client.client_id));
        if (Array.isArray(claims.aud) && claims.aud.length !== 1) {
            if (claims.azp === undefined) {
                throw OPE('ID Token "aud" (audience) claim includes additional untrusted audiences', JWT_CLAIM_COMPARISON, {
                    claims: claims,
                    claim: "aud"
                });
            }
            if (claims.azp !== client.client_id) {
                throw OPE('unexpected ID Token "azp" (authorized party) claim value', JWT_CLAIM_COMPARISON, {
                    expected: client.client_id,
                    claims: claims,
                    claim: "azp"
                });
            }
        }
        if (claims.auth_time !== undefined) {
            assertNumber(claims.auth_time, true, 'ID Token "auth_time" (authentication time)', INVALID_RESPONSE, {
                claims: claims
            });
        }
        jwtRefs.set(response, jwt);
        idTokenClaims.set(json, claims);
    }
    if ((recognizedTokenTypes === null || recognizedTokenTypes === void 0 ? void 0 : recognizedTokenTypes[json.token_type]) !== undefined) {
        recognizedTokenTypes[json.token_type](response, json);
    } else if (json.token_type !== "dpop" && json.token_type !== "bearer") {
        throw new UnsupportedOperationError("unsupported `token_type` value", {
            cause: {
                body: json
            }
        });
    }
    return json;
}

function checkAuthenticationChallenges(response) {
    let challenges;
    if (challenges = parseWwwAuthenticateChallenges(response)) {
        throw new WWWAuthenticateChallengeError("server responded with a challenge in the WWW-Authenticate HTTP Header", {
            cause: challenges,
            response: response
        });
    }
}

async function processRefreshTokenResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options === null || options === void 0 ? void 0 : options[jweDecrypt], options === null || options === void 0 ? void 0 : options.recognizedTokenTypes);
}

function validateAudience(expected, result) {
    if (Array.isArray(result.claims.aud)) {
        if (!result.claims.aud.includes(expected)) {
            throw OPE('unexpected JWT "aud" (audience) claim value', JWT_CLAIM_COMPARISON, {
                expected: expected,
                claims: result.claims,
                claim: "aud"
            });
        }
    } else if (result.claims.aud !== expected) {
        throw OPE('unexpected JWT "aud" (audience) claim value', JWT_CLAIM_COMPARISON, {
            expected: expected,
            claims: result.claims,
            claim: "aud"
        });
    }
    return result;
}

function validateIssuer(as, result) {
    var _as$_expectedIssuer, _as$_expectedIssuer2;
    const expected = (_as$_expectedIssuer = (_as$_expectedIssuer2 = as[_expectedIssuer]) === null || _as$_expectedIssuer2 === void 0 ? void 0 : _as$_expectedIssuer2.call(as, result)) !== null && _as$_expectedIssuer !== void 0 ? _as$_expectedIssuer : as.issuer;
    if (result.claims.iss !== expected) {
        throw OPE('unexpected JWT "iss" (issuer) claim value', JWT_CLAIM_COMPARISON, {
            expected: expected,
            claims: result.claims,
            claim: "iss"
        });
    }
    return result;
}

const branded = new WeakSet;

function brand(searchParams) {
    branded.add(searchParams);
    return searchParams;
}

const nopkce = Symbol();

async function authorizationCodeGrantRequest(as, client, clientAuthentication, callbackParameters, redirectUri, codeVerifier, options) {
    assertAs(as);
    assertClient(client);
    if (!branded.has(callbackParameters)) {
        throw CodedTypeError$1('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()', ERR_INVALID_ARG_VALUE$1);
    }
    assertString$1(redirectUri, '"redirectUri"');
    const code = getURLSearchParameter(callbackParameters, "code");
    if (!code) {
        throw OPE('no authorization code in "callbackParameters"', INVALID_RESPONSE);
    }
    const parameters = new URLSearchParams(options === null || options === void 0 ? void 0 : options.additionalParameters);
    parameters.set("redirect_uri", redirectUri);
    parameters.set("code", code);
    if (codeVerifier !== nopkce) {
        assertString$1(codeVerifier, '"codeVerifier"');
        parameters.set("code_verifier", codeVerifier);
    }
    return tokenEndpointRequest(as, client, clientAuthentication, "authorization_code", parameters, options);
}

const jwtClaimNames = {
    aud: "audience",
    c_hash: "code hash",
    client_id: "client id",
    exp: "expiration time",
    iat: "issued at",
    iss: "issuer",
    jti: "jwt id",
    nonce: "nonce",
    s_hash: "state hash",
    sub: "subject",
    ath: "access token hash",
    htm: "http method",
    htu: "http uri",
    cnf: "confirmation",
    auth_time: "authentication time"
};

function validatePresence(required, result) {
    for (const claim of required) {
        if (result.claims[claim] === undefined) {
            throw OPE('JWT "'.concat(claim, '" (').concat(jwtClaimNames[claim], ") claim missing"), INVALID_RESPONSE, {
                claims: result.claims
            });
        }
    }
    return result;
}

const expectNoNonce = Symbol();

const skipAuthTimeCheck = Symbol();

async function processAuthorizationCodeResponse(as, client, response, options) {
    if (typeof (options === null || options === void 0 ? void 0 : options.expectedNonce) === "string" || typeof (options === null || options === void 0 ? void 0 : options.maxAge) === "number" || options !== null && options !== void 0 && options.requireIdToken) {
        return processAuthorizationCodeOpenIDResponse(as, client, response, options.expectedNonce, options.maxAge, options[jweDecrypt], options.recognizedTokenTypes);
    }
    return processAuthorizationCodeOAuth2Response(as, client, response, options === null || options === void 0 ? void 0 : options[jweDecrypt], options === null || options === void 0 ? void 0 : options.recognizedTokenTypes);
}

async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge, decryptFn, recognizedTokenTypes) {
    const additionalRequiredClaims = [];
    switch (expectedNonce) {
      case undefined:
        expectedNonce = expectNoNonce;
        break;

      case expectNoNonce:
        break;

      default:
        assertString$1(expectedNonce, '"expectedNonce" argument');
        additionalRequiredClaims.push("nonce");
    }
    maxAge !== null && maxAge !== void 0 ? maxAge : maxAge = client.default_max_age;
    switch (maxAge) {
      case undefined:
        maxAge = skipAuthTimeCheck;
        break;

      case skipAuthTimeCheck:
        break;

      default:
        assertNumber(maxAge, true, '"maxAge" argument');
        additionalRequiredClaims.push("auth_time");
    }
    const result = await processGenericAccessTokenResponse(as, client, response, additionalRequiredClaims, decryptFn, recognizedTokenTypes);
    assertString$1(result.id_token, '"response" body "id_token" property', INVALID_RESPONSE, {
        body: result
    });
    const claims = getValidatedIdTokenClaims(result);
    if (maxAge !== skipAuthTimeCheck) {
        const now = epochTime() + getClockSkew(client);
        const tolerance = getClockTolerance(client);
        if (claims.auth_time + maxAge < now - tolerance) {
            throw OPE("too much time has elapsed since the last End-User authentication", JWT_TIMESTAMP_CHECK, {
                claims: claims,
                now: now,
                tolerance: tolerance,
                claim: "auth_time"
            });
        }
    }
    if (expectedNonce === expectNoNonce) {
        if (claims.nonce !== undefined) {
            throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
                expected: undefined,
                claims: claims,
                claim: "nonce"
            });
        }
    } else if (claims.nonce !== expectedNonce) {
        throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
            expected: expectedNonce,
            claims: claims,
            claim: "nonce"
        });
    }
    return result;
}

async function processAuthorizationCodeOAuth2Response(as, client, response, decryptFn, recognizedTokenTypes) {
    const result = await processGenericAccessTokenResponse(as, client, response, undefined, decryptFn, recognizedTokenTypes);
    const claims = getValidatedIdTokenClaims(result);
    if (claims) {
        if (client.default_max_age !== undefined) {
            assertNumber(client.default_max_age, true, '"client.default_max_age"');
            const now = epochTime() + getClockSkew(client);
            const tolerance = getClockTolerance(client);
            if (claims.auth_time + client.default_max_age < now - tolerance) {
                throw OPE("too much time has elapsed since the last End-User authentication", JWT_TIMESTAMP_CHECK, {
                    claims: claims,
                    now: now,
                    tolerance: tolerance,
                    claim: "auth_time"
                });
            }
        }
        if (claims.nonce !== undefined) {
            throw OPE('unexpected ID Token "nonce" claim value', JWT_CLAIM_COMPARISON, {
                expected: undefined,
                claims: claims,
                claim: "nonce"
            });
        }
    }
    return result;
}

const WWW_AUTHENTICATE_CHALLENGE = "OAUTH_WWW_AUTHENTICATE_CHALLENGE";

const RESPONSE_BODY_ERROR = "OAUTH_RESPONSE_BODY_ERROR";

const UNSUPPORTED_OPERATION = "OAUTH_UNSUPPORTED_OPERATION";

const AUTHORIZATION_RESPONSE_ERROR = "OAUTH_AUTHORIZATION_RESPONSE_ERROR";

const PARSE_ERROR = "OAUTH_PARSE_ERROR";

const INVALID_RESPONSE = "OAUTH_INVALID_RESPONSE";

const RESPONSE_IS_NOT_JSON = "OAUTH_RESPONSE_IS_NOT_JSON";

const RESPONSE_IS_NOT_CONFORM = "OAUTH_RESPONSE_IS_NOT_CONFORM";

const HTTP_REQUEST_FORBIDDEN = "OAUTH_HTTP_REQUEST_FORBIDDEN";

const REQUEST_PROTOCOL_FORBIDDEN = "OAUTH_REQUEST_PROTOCOL_FORBIDDEN";

const JWT_TIMESTAMP_CHECK = "OAUTH_JWT_TIMESTAMP_CHECK_FAILED";

const JWT_CLAIM_COMPARISON = "OAUTH_JWT_CLAIM_COMPARISON_FAILED";

const JSON_ATTRIBUTE_COMPARISON = "OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED";

const MISSING_SERVER_METADATA = "OAUTH_MISSING_SERVER_METADATA";

const INVALID_SERVER_METADATA = "OAUTH_INVALID_SERVER_METADATA";

async function clientCredentialsGrantRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    return tokenEndpointRequest(as, client, clientAuthentication, "client_credentials", new URLSearchParams(parameters), options);
}

async function genericTokenEndpointRequest(as, client, clientAuthentication, grantType, parameters, options) {
    assertAs(as);
    assertClient(client);
    assertString$1(grantType, '"grantType"');
    return tokenEndpointRequest(as, client, clientAuthentication, grantType, new URLSearchParams(parameters), options);
}

async function processGenericTokenEndpointResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options === null || options === void 0 ? void 0 : options[jweDecrypt], options === null || options === void 0 ? void 0 : options.recognizedTokenTypes);
}

async function processClientCredentialsResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options === null || options === void 0 ? void 0 : options[jweDecrypt], options === null || options === void 0 ? void 0 : options.recognizedTokenTypes);
}

function assertReadableResponse(response) {
    if (response.bodyUsed) {
        throw CodedTypeError$1('"response" body has been used already', ERR_INVALID_ARG_VALUE$1);
    }
}

function checkRsaKeyAlgorithm(key) {
    const {algorithm: algorithm} = key;
    if (typeof algorithm.modulusLength !== "number" || algorithm.modulusLength < 2048) {
        throw new UnsupportedOperationError("unsupported ".concat(algorithm.name, " modulusLength"), {
            cause: key
        });
    }
}

function ecdsaHashName(key) {
    const {algorithm: algorithm} = key;
    switch (algorithm.namedCurve) {
      case "P-256":
        return "SHA-256";

      case "P-384":
        return "SHA-384";

      case "P-521":
        return "SHA-512";

      default:
        throw new UnsupportedOperationError("unsupported ECDSA namedCurve", {
            cause: key
        });
    }
}

function keyToSubtle(key) {
    switch (key.algorithm.name) {
      case "ECDSA":
        return {
            name: key.algorithm.name,
            hash: ecdsaHashName(key)
        };

      case "RSA-PSS":
        {
            checkRsaKeyAlgorithm(key);
            switch (key.algorithm.hash.name) {
              case "SHA-256":
              case "SHA-384":
              case "SHA-512":
                return {
                    name: key.algorithm.name,
                    saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3
                };

              default:
                throw new UnsupportedOperationError("unsupported RSA-PSS hash name", {
                    cause: key
                });
            }
        }

      case "RSASSA-PKCS1-v1_5":
        checkRsaKeyAlgorithm(key);
        return key.algorithm.name;

      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
      case "Ed25519":
        return key.algorithm.name;
    }
    throw new UnsupportedOperationError("unsupported CryptoKey algorithm name", {
        cause: key
    });
}

async function validateJwt(jws, checkAlg, clockSkew, clockTolerance, decryptJwt) {
    let {0: protectedHeader, 1: payload, length: length} = jws.split(".");
    if (length === 5) {
        if (decryptJwt !== undefined) {
            jws = await decryptJwt(jws);
            ({0: protectedHeader, 1: payload, length: length} = jws.split("."));
        } else {
            throw new UnsupportedOperationError("JWE decryption is not configured", {
                cause: jws
            });
        }
    }
    if (length !== 3) {
        throw OPE("Invalid JWT", INVALID_RESPONSE, jws);
    }
    let header;
    try {
        header = JSON.parse(buf(b64u(protectedHeader)));
    } catch (cause) {
        throw OPE("failed to parse JWT Header body as base64url encoded JSON", PARSE_ERROR, cause);
    }
    if (!isJsonObject(header)) {
        throw OPE("JWT Header must be a top level object", INVALID_RESPONSE, jws);
    }
    checkAlg(header);
    if (header.crit !== undefined) {
        throw new UnsupportedOperationError('no JWT "crit" header parameter extensions are supported', {
            cause: {
                header: header
            }
        });
    }
    let claims;
    try {
        claims = JSON.parse(buf(b64u(payload)));
    } catch (cause) {
        throw OPE("failed to parse JWT Payload body as base64url encoded JSON", PARSE_ERROR, cause);
    }
    if (!isJsonObject(claims)) {
        throw OPE("JWT Payload must be a top level object", INVALID_RESPONSE, jws);
    }
    const now = epochTime() + clockSkew;
    if (claims.exp !== undefined) {
        if (typeof claims.exp !== "number") {
            throw OPE('unexpected JWT "exp" (expiration time) claim type', INVALID_RESPONSE, {
                claims: claims
            });
        }
        if (claims.exp <= now - clockTolerance) {
            throw OPE('unexpected JWT "exp" (expiration time) claim value, expiration is past current timestamp', JWT_TIMESTAMP_CHECK, {
                claims: claims,
                now: now,
                tolerance: clockTolerance,
                claim: "exp"
            });
        }
    }
    if (claims.iat !== undefined) {
        if (typeof claims.iat !== "number") {
            throw OPE('unexpected JWT "iat" (issued at) claim type', INVALID_RESPONSE, {
                claims: claims
            });
        }
    }
    if (claims.iss !== undefined) {
        if (typeof claims.iss !== "string") {
            throw OPE('unexpected JWT "iss" (issuer) claim type', INVALID_RESPONSE, {
                claims: claims
            });
        }
    }
    if (claims.nbf !== undefined) {
        if (typeof claims.nbf !== "number") {
            throw OPE('unexpected JWT "nbf" (not before) claim type', INVALID_RESPONSE, {
                claims: claims
            });
        }
        if (claims.nbf > now + clockTolerance) {
            throw OPE('unexpected JWT "nbf" (not before) claim value', JWT_TIMESTAMP_CHECK, {
                claims: claims,
                now: now,
                tolerance: clockTolerance,
                claim: "nbf"
            });
        }
    }
    if (claims.aud !== undefined) {
        if (typeof claims.aud !== "string" && !Array.isArray(claims.aud)) {
            throw OPE('unexpected JWT "aud" (audience) claim type', INVALID_RESPONSE, {
                claims: claims
            });
        }
    }
    return {
        header: header,
        claims: claims,
        jwt: jws
    };
}

async function consumeStream(request) {
    if (request.bodyUsed) {
        throw CodedTypeError$1("form_post Request instances must contain a readable body", ERR_INVALID_ARG_VALUE$1, {
            cause: request
        });
    }
    return request.text();
}

async function formPostResponse(request) {
    if (request.method !== "POST") {
        throw CodedTypeError$1("form_post responses are expected to use the POST method", ERR_INVALID_ARG_VALUE$1, {
            cause: request
        });
    }
    if (getContentType(request) !== "application/x-www-form-urlencoded") {
        throw CodedTypeError$1("form_post responses are expected to use the application/x-www-form-urlencoded content-type", ERR_INVALID_ARG_VALUE$1, {
            cause: request
        });
    }
    return consumeStream(request);
}

function checkSigningAlgorithm(client, issuer, fallback, header) {
    if (client !== undefined) {
        if (typeof client === "string" ? header.alg !== client : !client.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header: header,
                expected: client,
                reason: "client configuration"
            });
        }
        return;
    }
    if (Array.isArray(issuer)) {
        if (!issuer.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header: header,
                expected: issuer,
                reason: "authorization server metadata"
            });
        }
        return;
    }
    if (fallback !== undefined) {
        if (typeof fallback === "string" ? header.alg !== fallback : typeof fallback === "function" ? !fallback(header.alg) : !fallback.includes(header.alg)) {
            throw OPE('unexpected JWT "alg" header parameter', INVALID_RESPONSE, {
                header: header,
                expected: fallback,
                reason: "default value"
            });
        }
        return;
    }
    throw OPE('missing client or server configuration to verify used JWT "alg" header parameter', undefined, {
        client: client,
        issuer: issuer,
        fallback: fallback
    });
}

function getURLSearchParameter(parameters, name) {
    const {0: value, length: length} = parameters.getAll(name);
    if (length > 1) {
        throw OPE('"'.concat(name, '" parameter must be provided only once'), INVALID_RESPONSE);
    }
    return value;
}

const skipStateCheck = Symbol();

const expectNoState = Symbol();

function validateAuthResponse(as, client, parameters, expectedState) {
    assertAs(as);
    assertClient(client);
    if (parameters instanceof URL) {
        parameters = parameters.searchParams;
    }
    if (!(parameters instanceof URLSearchParams)) {
        throw CodedTypeError$1('"parameters" must be an instance of URLSearchParams, or URL', ERR_INVALID_ARG_TYPE$1);
    }
    if (getURLSearchParameter(parameters, "response")) {
        throw OPE('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', INVALID_RESPONSE, {
            parameters: parameters
        });
    }
    const iss = getURLSearchParameter(parameters, "iss");
    const state = getURLSearchParameter(parameters, "state");
    if (!iss && as.authorization_response_iss_parameter_supported) {
        throw OPE('response parameter "iss" (issuer) missing', INVALID_RESPONSE, {
            parameters: parameters
        });
    }
    if (iss && iss !== as.issuer) {
        throw OPE('unexpected "iss" (issuer) response parameter value', INVALID_RESPONSE, {
            expected: as.issuer,
            parameters: parameters
        });
    }
    switch (expectedState) {
      case undefined:
      case expectNoState:
        if (state !== undefined) {
            throw OPE('unexpected "state" response parameter encountered', INVALID_RESPONSE, {
                expected: undefined,
                parameters: parameters
            });
        }
        break;

      case skipStateCheck:
        break;

      default:
        assertString$1(expectedState, '"expectedState" argument');
        if (state !== expectedState) {
            throw OPE(state === undefined ? 'response parameter "state" missing' : 'unexpected "state" response parameter value', INVALID_RESPONSE, {
                expected: expectedState,
                parameters: parameters
            });
        }
    }
    const error = getURLSearchParameter(parameters, "error");
    if (error) {
        throw new AuthorizationResponseError("authorization response from the server is an error", {
            cause: parameters
        });
    }
    const id_token = getURLSearchParameter(parameters, "id_token");
    const token = getURLSearchParameter(parameters, "token");
    if (id_token !== undefined || token !== undefined) {
        throw new UnsupportedOperationError("implicit and hybrid flows are not supported");
    }
    return brand(new URLSearchParams(parameters));
}

async function backchannelAuthenticationRequest(as, client, clientAuthentication, parameters, options) {
    assertAs(as);
    assertClient(client);
    const url = resolveEndpoint(as, "backchannel_authentication_endpoint", client.use_mtls_endpoint_aliases, (options === null || options === void 0 ? void 0 : options[allowInsecureRequests$1]) !== true);
    const body = new URLSearchParams(parameters);
    body.set("client_id", client.client_id);
    const headers = prepareHeaders(options === null || options === void 0 ? void 0 : options.headers);
    headers.set("accept", "application/json");
    return authenticatedRequest(as, client, clientAuthentication, url, body, headers, options);
}

async function processBackchannelAuthenticationResponse(as, client, response) {
    assertAs(as);
    assertClient(client);
    if (!looseInstanceOf(response, Response)) {
        throw CodedTypeError$1('"response" must be an instance of Response', ERR_INVALID_ARG_TYPE$1);
    }
    await checkOAuthBodyError(response, 200, "Backchannel Authentication Endpoint");
    assertReadableResponse(response);
    const json = await getResponseJsonBody(response);
    assertString$1(json.auth_req_id, '"response" body "auth_req_id" property', INVALID_RESPONSE, {
        body: json
    });
    let expiresIn = typeof json.expires_in !== "number" ? parseFloat(json.expires_in) : json.expires_in;
    assertNumber(expiresIn, true, '"response" body "expires_in" property', INVALID_RESPONSE, {
        body: json
    });
    json.expires_in = expiresIn;
    if (json.interval !== undefined) {
        assertNumber(json.interval, false, '"response" body "interval" property', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}

async function backchannelAuthenticationGrantRequest(as, client, clientAuthentication, authReqId, options) {
    assertAs(as);
    assertClient(client);
    assertString$1(authReqId, '"authReqId"');
    const parameters = new URLSearchParams(options === null || options === void 0 ? void 0 : options.additionalParameters);
    parameters.set("auth_req_id", authReqId);
    return tokenEndpointRequest(as, client, clientAuthentication, "urn:openid:params:grant-type:ciba", parameters, options);
}

async function processBackchannelAuthenticationGrantResponse(as, client, response, options) {
    return processGenericAccessTokenResponse(as, client, response, undefined, options === null || options === void 0 ? void 0 : options[jweDecrypt], options === null || options === void 0 ? void 0 : options.recognizedTokenTypes);
}

async function getResponseJsonBody(response) {
    let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : assertApplicationJson;
    let json;
    try {
        json = await response.json();
    } catch (cause) {
        check(response);
        throw OPE('failed to parse "response" body as JSON', PARSE_ERROR, cause);
    }
    if (!isJsonObject(json)) {
        throw OPE('"response" body must be a top level object', INVALID_RESPONSE, {
            body: json
        });
    }
    return json;
}

const _nodiscoverycheck = Symbol();

const _expectedIssuer = Symbol();

const encoder = new TextEncoder;

const decoder = new TextDecoder;

function concat() {
    for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
        buffers[_key] = arguments[_key];
    }
    const size = buffers.reduce(((acc, _ref) => {
        let {length: length} = _ref;
        return acc + length;
    }), 0);
    const buf = new Uint8Array(size);
    let i = 0;
    for (const buffer of buffers) {
        buf.set(buffer, i);
        i += buffer.length;
    }
    return buf;
}

function encode(string) {
    const bytes = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
        const code = string.charCodeAt(i);
        if (code > 127) {
            throw new TypeError("non-ASCII string encountered in encode()");
        }
        bytes[i] = code;
    }
    return bytes;
}

function decodeBase64(encoded) {
    if (Uint8Array.fromBase64) {
        return Uint8Array.fromBase64(encoded);
    }
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

function decode(input) {
    if (Uint8Array.fromBase64) {
        return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
            alphabet: "base64url"
        });
    }
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
    }
    encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
    try {
        return decodeBase64(encoded);
    } catch (_unused) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
    }
}

class JOSEError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr;
        super(message, options);
        _defineProperty(this, "code", "ERR_JOSE_GENERIC");
        this.name = this.constructor.name;
        (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, this, this.constructor);
    }
}

_defineProperty(JOSEError, "code", "ERR_JOSE_GENERIC");

class JWTClaimValidationFailed extends JOSEError {
    constructor(message, payload) {
        let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "unspecified";
        let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "unspecified";
        super(message, {
            cause: {
                claim: claim,
                reason: reason,
                payload: payload
            }
        });
        _defineProperty(this, "code", "ERR_JWT_CLAIM_VALIDATION_FAILED");
        _defineProperty(this, "claim", void 0);
        _defineProperty(this, "reason", void 0);
        _defineProperty(this, "payload", void 0);
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
    }
}

_defineProperty(JWTClaimValidationFailed, "code", "ERR_JWT_CLAIM_VALIDATION_FAILED");

class JWTExpired extends JOSEError {
    constructor(message, payload) {
        let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "unspecified";
        let reason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "unspecified";
        super(message, {
            cause: {
                claim: claim,
                reason: reason,
                payload: payload
            }
        });
        _defineProperty(this, "code", "ERR_JWT_EXPIRED");
        _defineProperty(this, "claim", void 0);
        _defineProperty(this, "reason", void 0);
        _defineProperty(this, "payload", void 0);
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
    }
}

_defineProperty(JWTExpired, "code", "ERR_JWT_EXPIRED");

class JOSEAlgNotAllowed extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JOSE_ALG_NOT_ALLOWED");
    }
}

_defineProperty(JOSEAlgNotAllowed, "code", "ERR_JOSE_ALG_NOT_ALLOWED");

class JOSENotSupported extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JOSE_NOT_SUPPORTED");
    }
}

_defineProperty(JOSENotSupported, "code", "ERR_JOSE_NOT_SUPPORTED");

class JWEDecryptionFailed extends JOSEError {
    constructor() {
        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "decryption operation failed";
        let options = arguments.length > 1 ? arguments[1] : undefined;
        super(message, options);
        _defineProperty(this, "code", "ERR_JWE_DECRYPTION_FAILED");
    }
}

_defineProperty(JWEDecryptionFailed, "code", "ERR_JWE_DECRYPTION_FAILED");

class JWEInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JWE_INVALID");
    }
}

_defineProperty(JWEInvalid, "code", "ERR_JWE_INVALID");

class JWSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JWS_INVALID");
    }
}

_defineProperty(JWSInvalid, "code", "ERR_JWS_INVALID");

class JWTInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JWT_INVALID");
    }
}

_defineProperty(JWTInvalid, "code", "ERR_JWT_INVALID");

class JWKInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JWK_INVALID");
    }
}

_defineProperty(JWKInvalid, "code", "ERR_JWK_INVALID");

class JWKSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        _defineProperty(this, "code", "ERR_JWKS_INVALID");
    }
}

_defineProperty(JWKSInvalid, "code", "ERR_JWKS_INVALID");

class JWKSNoMatchingKey extends JOSEError {
    constructor() {
        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "no applicable key found in the JSON Web Key Set";
        let options = arguments.length > 1 ? arguments[1] : undefined;
        super(message, options);
        _defineProperty(this, "code", "ERR_JWKS_NO_MATCHING_KEY");
    }
}

_defineProperty(JWKSNoMatchingKey, "code", "ERR_JWKS_NO_MATCHING_KEY");

class JWKSMultipleMatchingKeys extends JOSEError {
    constructor() {
        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "multiple matching keys found in the JSON Web Key Set";
        let options = arguments.length > 1 ? arguments[1] : undefined;
        super(message, options);
        _defineProperty(this, Symbol.asyncIterator, void 0);
        _defineProperty(this, "code", "ERR_JWKS_MULTIPLE_MATCHING_KEYS");
    }
}

_defineProperty(JWKSMultipleMatchingKeys, "code", "ERR_JWKS_MULTIPLE_MATCHING_KEYS");

class JWKSTimeout extends JOSEError {
    constructor() {
        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "request timed out";
        let options = arguments.length > 1 ? arguments[1] : undefined;
        super(message, options);
        _defineProperty(this, "code", "ERR_JWKS_TIMEOUT");
    }
}

_defineProperty(JWKSTimeout, "code", "ERR_JWKS_TIMEOUT");

class JWSSignatureVerificationFailed extends JOSEError {
    constructor() {
        let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "signature verification failed";
        let options = arguments.length > 1 ? arguments[1] : undefined;
        super(message, options);
        _defineProperty(this, "code", "ERR_JWS_SIGNATURE_VERIFICATION_FAILED");
    }
}

_defineProperty(JWSSignatureVerificationFailed, "code", "ERR_JWS_SIGNATURE_VERIFICATION_FAILED");

const unusable = function unusable(name) {
    let prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "algorithm.name";
    return new TypeError("CryptoKey does not support this operation, its ".concat(prop, " must be ").concat(name));
};

const isAlgorithm = (algorithm, name) => algorithm.name === name;

function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}

function getNamedCurve(alg) {
    switch (alg) {
      case "ES256":
        return "P-256";

      case "ES384":
        return "P-384";

      case "ES512":
        return "P-521";

      default:
        throw new Error("unreachable");
    }
}

function checkUsage(key, usage) {
    if (usage && !key.usages.includes(usage)) {
        throw new TypeError("CryptoKey does not support this operation, its usages must include ".concat(usage, "."));
    }
}

function checkSigCryptoKey(key, alg, usage) {
    switch (alg) {
      case "HS256":
      case "HS384":
      case "HS512":
        {
            if (!isAlgorithm(key.algorithm, "HMAC")) throw unusable("HMAC");
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected) throw unusable("SHA-".concat(expected), "algorithm.hash");
            break;
        }

      case "RS256":
      case "RS384":
      case "RS512":
        {
            if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5")) throw unusable("RSASSA-PKCS1-v1_5");
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected) throw unusable("SHA-".concat(expected), "algorithm.hash");
            break;
        }

      case "PS256":
      case "PS384":
      case "PS512":
        {
            if (!isAlgorithm(key.algorithm, "RSA-PSS")) throw unusable("RSA-PSS");
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected) throw unusable("SHA-".concat(expected), "algorithm.hash");
            break;
        }

      case "Ed25519":
      case "EdDSA":
        {
            if (!isAlgorithm(key.algorithm, "Ed25519")) throw unusable("Ed25519");
            break;
        }

      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
        {
            if (!isAlgorithm(key.algorithm, alg)) throw unusable(alg);
            break;
        }

      case "ES256":
      case "ES384":
      case "ES512":
        {
            if (!isAlgorithm(key.algorithm, "ECDSA")) throw unusable("ECDSA");
            const expected = getNamedCurve(alg);
            const actual = key.algorithm.namedCurve;
            if (actual !== expected) throw unusable(expected, "algorithm.namedCurve");
            break;
        }

      default:
        throw new TypeError("CryptoKey does not support this operation");
    }
    checkUsage(key, usage);
}

function message(msg, actual) {
    for (var _len = arguments.length, types = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        types[_key - 2] = arguments[_key];
    }
    types = types.filter(Boolean);
    if (types.length > 2) {
        const last = types.pop();
        msg += "one of type ".concat(types.join(", "), ", or ").concat(last, ".");
    } else if (types.length === 2) {
        msg += "one of type ".concat(types[0], " or ").concat(types[1], ".");
    } else {
        msg += "of type ".concat(types[0], ".");
    }
    if (actual == null) {
        msg += " Received ".concat(actual);
    } else if (typeof actual === "function" && actual.name) {
        msg += " Received function ".concat(actual.name);
    } else if (typeof actual === "object" && actual != null) {
        var _actual$constructor;
        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += " Received an instance of ".concat(actual.constructor.name);
        }
    }
    return msg;
}

const invalidKeyInput = function invalidKeyInput(actual) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        types[_key2 - 1] = arguments[_key2];
    }
    return message("Key must be ", actual, ...types);
};

const withAlg = function withAlg(alg, actual) {
    for (var _len3 = arguments.length, types = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        types[_key3 - 2] = arguments[_key3];
    }
    return message("Key for the ".concat(alg, " algorithm must be "), actual, ...types);
};

const isCryptoKey = key => {
    if ((key === null || key === void 0 ? void 0 : key[Symbol.toStringTag]) === "CryptoKey") return true;
    try {
        return key instanceof CryptoKey;
    } catch (_unused) {
        return false;
    }
};

const isKeyObject = key => (key === null || key === void 0 ? void 0 : key[Symbol.toStringTag]) === "KeyObject";

const isKeyLike = key => isCryptoKey(key) || isKeyObject(key);

function isDisjoint() {
    for (var _len = arguments.length, headers = new Array(_len), _key = 0; _key < _len; _key++) {
        headers[_key] = arguments[_key];
    }
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters) {
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
}

const isObjectLike = value => typeof value === "object" && value !== null;

function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}

function checkKeyLength(alg, key) {
    if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const {modulusLength: modulusLength} = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
            throw new TypeError("".concat(alg, " requires key modulusLength to be 2048 bits or larger"));
        }
    }
}

const bytesEqual = (a, b) => {
    if (a.byteLength !== b.length) return false;
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) return false;
    }
    return true;
};

const createASN1State = data => ({
    data: data,
    pos: 0
});

const parseLength = state => {
    const first = state.data[state.pos++];
    if (first & 128) {
        const lengthOfLen = first & 127;
        let length = 0;
        for (let i = 0; i < lengthOfLen; i++) {
            length = length << 8 | state.data[state.pos++];
        }
        return length;
    }
    return first;
};

const expectTag = (state, expectedTag, errorMessage) => {
    if (state.data[state.pos++] !== expectedTag) {
        throw new Error(errorMessage);
    }
};

const getSubarray = (state, length) => {
    const result = state.data.subarray(state.pos, state.pos + length);
    state.pos += length;
    return result;
};

const parseAlgorithmOID = state => {
    expectTag(state, 6, "Expected algorithm OID");
    const oidLen = parseLength(state);
    return getSubarray(state, oidLen);
};

function parsePKCS8Header(state) {
    expectTag(state, 48, "Invalid PKCS#8 structure");
    parseLength(state);
    expectTag(state, 2, "Expected version field");
    const verLen = parseLength(state);
    state.pos += verLen;
    expectTag(state, 48, "Expected algorithm identifier");
    const algIdLen = parseLength(state);
    const algIdStart = state.pos;
    return {
        algIdStart: algIdStart,
        algIdLength: algIdLen
    };
}

const parseECAlgorithmIdentifier = state => {
    const algOid = parseAlgorithmOID(state);
    if (bytesEqual(algOid, [ 43, 101, 110 ])) {
        return "X25519";
    }
    if (!bytesEqual(algOid, [ 42, 134, 72, 206, 61, 2, 1 ])) {
        throw new Error("Unsupported key algorithm");
    }
    expectTag(state, 6, "Expected curve OID");
    const curveOidLen = parseLength(state);
    const curveOid = getSubarray(state, curveOidLen);
    for (const {name: name, oid: oid} of [ {
        name: "P-256",
        oid: [ 42, 134, 72, 206, 61, 3, 1, 7 ]
    }, {
        name: "P-384",
        oid: [ 43, 129, 4, 0, 34 ]
    }, {
        name: "P-521",
        oid: [ 43, 129, 4, 0, 35 ]
    } ]) {
        if (bytesEqual(curveOid, oid)) {
            return name;
        }
    }
    throw new Error("Unsupported named curve");
};

const genericImport = async (keyFormat, keyData, alg, options) => {
    var _options$extractable;
    let algorithm;
    let keyUsages;
    const isPublic = keyFormat === "spki";
    const getSigUsages = () => isPublic ? [ "verify" ] : [ "sign" ];
    const getEncUsages = () => isPublic ? [ "encrypt", "wrapKey" ] : [ "decrypt", "unwrapKey" ];
    switch (alg) {
      case "PS256":
      case "PS384":
      case "PS512":
        algorithm = {
            name: "RSA-PSS",
            hash: "SHA-".concat(alg.slice(-3))
        };
        keyUsages = getSigUsages();
        break;

      case "RS256":
      case "RS384":
      case "RS512":
        algorithm = {
            name: "RSASSA-PKCS1-v1_5",
            hash: "SHA-".concat(alg.slice(-3))
        };
        keyUsages = getSigUsages();
        break;

      case "RSA-OAEP":
      case "RSA-OAEP-256":
      case "RSA-OAEP-384":
      case "RSA-OAEP-512":
        algorithm = {
            name: "RSA-OAEP",
            hash: "SHA-".concat(parseInt(alg.slice(-3), 10) || 1)
        };
        keyUsages = getEncUsages();
        break;

      case "ES256":
      case "ES384":
      case "ES512":
        {
            const curveMap = {
                ES256: "P-256",
                ES384: "P-384",
                ES512: "P-521"
            };
            algorithm = {
                name: "ECDSA",
                namedCurve: curveMap[alg]
            };
            keyUsages = getSigUsages();
            break;
        }

      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        {
            try {
                const namedCurve = options.getNamedCurve(keyData);
                algorithm = namedCurve === "X25519" ? {
                    name: "X25519"
                } : {
                    name: "ECDH",
                    namedCurve: namedCurve
                };
            } catch (cause) {
                throw new JOSENotSupported("Invalid or unsupported key format");
            }
            keyUsages = isPublic ? [] : [ "deriveBits" ];
            break;
        }

      case "Ed25519":
      case "EdDSA":
        algorithm = {
            name: "Ed25519"
        };
        keyUsages = getSigUsages();
        break;

      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
        algorithm = {
            name: alg
        };
        keyUsages = getSigUsages();
        break;

      default:
        throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
    }
    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_options$extractable = options === null || options === void 0 ? void 0 : options.extractable) !== null && _options$extractable !== void 0 ? _options$extractable : isPublic ? true : false, keyUsages);
};

const processPEMData = (pem, pattern) => decodeBase64(pem.replace(pattern, ""));

const fromPKCS8 = (pem, alg, options) => {
    var _alg$startsWith;
    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g);
    let opts = options;
    if (alg !== null && alg !== void 0 && (_alg$startsWith = alg.startsWith) !== null && _alg$startsWith !== void 0 && _alg$startsWith.call(alg, "ECDH-ES")) {
        opts || (opts = {});
        opts.getNamedCurve = keyData => {
            const state = createASN1State(keyData);
            parsePKCS8Header(state);
            return parseECAlgorithmIdentifier(state);
        };
    }
    return genericImport("pkcs8", keyData, alg, opts);
};

function subtleMapping(jwk) {
    let algorithm;
    let keyUsages;
    switch (jwk.kty) {
      case "AKP":
        {
            switch (jwk.alg) {
              case "ML-DSA-44":
              case "ML-DSA-65":
              case "ML-DSA-87":
                algorithm = {
                    name: jwk.alg
                };
                keyUsages = jwk.priv ? [ "sign" ] : [ "verify" ];
                break;

              default:
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }

      case "RSA":
        {
            switch (jwk.alg) {
              case "PS256":
              case "PS384":
              case "PS512":
                algorithm = {
                    name: "RSA-PSS",
                    hash: "SHA-".concat(jwk.alg.slice(-3))
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "RS256":
              case "RS384":
              case "RS512":
                algorithm = {
                    name: "RSASSA-PKCS1-v1_5",
                    hash: "SHA-".concat(jwk.alg.slice(-3))
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "RSA-OAEP":
              case "RSA-OAEP-256":
              case "RSA-OAEP-384":
              case "RSA-OAEP-512":
                algorithm = {
                    name: "RSA-OAEP",
                    hash: "SHA-".concat(parseInt(jwk.alg.slice(-3), 10) || 1)
                };
                keyUsages = jwk.d ? [ "decrypt", "unwrapKey" ] : [ "encrypt", "wrapKey" ];
                break;

              default:
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }

      case "EC":
        {
            switch (jwk.alg) {
              case "ES256":
                algorithm = {
                    name: "ECDSA",
                    namedCurve: "P-256"
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "ES384":
                algorithm = {
                    name: "ECDSA",
                    namedCurve: "P-384"
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "ES512":
                algorithm = {
                    name: "ECDSA",
                    namedCurve: "P-521"
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "ECDH-ES":
              case "ECDH-ES+A128KW":
              case "ECDH-ES+A192KW":
              case "ECDH-ES+A256KW":
                algorithm = {
                    name: "ECDH",
                    namedCurve: jwk.crv
                };
                keyUsages = jwk.d ? [ "deriveBits" ] : [];
                break;

              default:
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }

      case "OKP":
        {
            switch (jwk.alg) {
              case "Ed25519":
              case "EdDSA":
                algorithm = {
                    name: "Ed25519"
                };
                keyUsages = jwk.d ? [ "sign" ] : [ "verify" ];
                break;

              case "ECDH-ES":
              case "ECDH-ES+A128KW":
              case "ECDH-ES+A192KW":
              case "ECDH-ES+A256KW":
                algorithm = {
                    name: jwk.crv
                };
                keyUsages = jwk.d ? [ "deriveBits" ] : [];
                break;

              default:
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }

      default:
        throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
    return {
        algorithm: algorithm,
        keyUsages: keyUsages
    };
}

async function jwkToKey(jwk) {
    var _jwk$ext, _jwk$key_ops;
    if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    }
    const {algorithm: algorithm, keyUsages: keyUsages} = subtleMapping(jwk);
    const keyData = _objectSpread2({}, jwk);
    if (keyData.kty !== "AKP") {
        delete keyData.alg;
    }
    delete keyData.use;
    return crypto.subtle.importKey("jwk", keyData, algorithm, (_jwk$ext = jwk.ext) !== null && _jwk$ext !== void 0 ? _jwk$ext : jwk.d || jwk.priv ? false : true, (_jwk$key_ops = jwk.key_ops) !== null && _jwk$key_ops !== void 0 ? _jwk$key_ops : keyUsages);
}

async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    }
    return fromPKCS8(pkcs8, alg, options);
}

async function importJWK(jwk, alg, options) {
    var _options$extractable;
    if (!isObject(jwk)) {
        throw new TypeError("JWK must be an object");
    }
    let ext;
    alg !== null && alg !== void 0 ? alg : alg = jwk.alg;
    ext !== null && ext !== void 0 ? ext : ext = (_options$extractable = options === null || options === void 0 ? void 0 : options.extractable) !== null && _options$extractable !== void 0 ? _options$extractable : jwk.ext;
    switch (jwk.kty) {
      case "oct":
        if (typeof jwk.k !== "string" || !jwk.k) {
            throw new TypeError('missing "k" (Key Value) Parameter value');
        }
        return decode(jwk.k);

      case "RSA":
        if ("oth" in jwk && jwk.oth !== undefined) {
            throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
        }
        return jwkToKey(_objectSpread2(_objectSpread2({}, jwk), {}, {
            alg: alg,
            ext: ext
        }));

      case "AKP":
        {
            if (typeof jwk.alg !== "string" || !jwk.alg) {
                throw new TypeError('missing "alg" (Algorithm) Parameter value');
            }
            if (alg !== undefined && alg !== jwk.alg) {
                throw new TypeError("JWK alg and alg option value mismatch");
            }
            return jwkToKey(_objectSpread2(_objectSpread2({}, jwk), {}, {
                ext: ext
            }));
        }

      case "EC":
      case "OKP":
        return jwkToKey(_objectSpread2(_objectSpread2({}, jwk), {}, {
            alg: alg,
            ext: ext
        }));

      default:
        throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}

function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && (protectedHeader === null || protectedHeader === void 0 ? void 0 : protectedHeader.crit) === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set;
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input => typeof input !== "string" || input.length === 0))) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([ ...Object.entries(recognizedOption), ...recognizedDefault.entries() ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported('Extension Header Parameter "'.concat(parameter, '" is not recognized'));
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err('Extension Header Parameter "'.concat(parameter, '" is missing'));
        }
        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err('Extension Header Parameter "'.concat(parameter, '" MUST be integrity protected'));
        }
    }
    return new Set(protectedHeader.crit);
}

function validateAlgorithms(option, algorithms) {
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s => typeof s !== "string")))) {
        throw new TypeError('"'.concat(option, '" option must be an array of strings'));
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
}

const isJWK = key => isObject(key) && typeof key.kty === "string";

const isPrivateJWK = key => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");

const isPublicJWK = key => key.kty !== "oct" && key.d === undefined && key.priv === undefined;

const isSecretJWK = key => key.kty === "oct" && typeof key.k === "string";

let cache;

const handleJWK = async function handleJWK(key, jwk, alg) {
    let freeze = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    cache || (cache = new WeakMap);
    let cached = cache.get(key);
    if (cached !== null && cached !== void 0 && cached[alg]) {
        return cached[alg];
    }
    const cryptoKey = await jwkToKey(_objectSpread2(_objectSpread2({}, jwk), {}, {
        alg: alg
    }));
    if (freeze) Object.freeze(key);
    if (!cached) {
        cache.set(key, {
            [alg]: cryptoKey
        });
    } else {
        cached[alg] = cryptoKey;
    }
    return cryptoKey;
};

const handleKeyObject = (keyObject, alg) => {
    cache || (cache = new WeakMap);
    let cached = cache.get(keyObject);
    if (cached !== null && cached !== void 0 && cached[alg]) {
        return cached[alg];
    }
    const isPublic = keyObject.type === "public";
    const extractable = isPublic ? true : false;
    let cryptoKey;
    if (keyObject.asymmetricKeyType === "x25519") {
        switch (alg) {
          case "ECDH-ES":
          case "ECDH-ES+A128KW":
          case "ECDH-ES+A192KW":
          case "ECDH-ES+A256KW":
            break;

          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : [ "deriveBits" ]);
    }
    if (keyObject.asymmetricKeyType === "ed25519") {
        if (alg !== "EdDSA" && alg !== "Ed25519") {
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [ isPublic ? "verify" : "sign" ]);
    }
    switch (keyObject.asymmetricKeyType) {
      case "ml-dsa-44":
      case "ml-dsa-65":
      case "ml-dsa-87":
        {
            if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
                throw new TypeError("given KeyObject instance cannot be used for this algorithm");
            }
            cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [ isPublic ? "verify" : "sign" ]);
        }
    }
    if (keyObject.asymmetricKeyType === "rsa") {
        let hash;
        switch (alg) {
          case "RSA-OAEP":
            hash = "SHA-1";
            break;

          case "RS256":
          case "PS256":
          case "RSA-OAEP-256":
            hash = "SHA-256";
            break;

          case "RS384":
          case "PS384":
          case "RSA-OAEP-384":
            hash = "SHA-384";
            break;

          case "RS512":
          case "PS512":
          case "RSA-OAEP-512":
            hash = "SHA-512";
            break;

          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg.startsWith("RSA-OAEP")) {
            return keyObject.toCryptoKey({
                name: "RSA-OAEP",
                hash: hash
            }, extractable, isPublic ? [ "encrypt" ] : [ "decrypt" ]);
        }
        cryptoKey = keyObject.toCryptoKey({
            name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
            hash: hash
        }, extractable, [ isPublic ? "verify" : "sign" ]);
    }
    if (keyObject.asymmetricKeyType === "ec") {
        var _keyObject$asymmetric;
        const nist = new Map([ [ "prime256v1", "P-256" ], [ "secp384r1", "P-384" ], [ "secp521r1", "P-521" ] ]);
        const namedCurve = nist.get((_keyObject$asymmetric = keyObject.asymmetricKeyDetails) === null || _keyObject$asymmetric === void 0 ? void 0 : _keyObject$asymmetric.namedCurve);
        if (!namedCurve) {
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg === "ES256" && namedCurve === "P-256") {
            cryptoKey = keyObject.toCryptoKey({
                name: "ECDSA",
                namedCurve: namedCurve
            }, extractable, [ isPublic ? "verify" : "sign" ]);
        }
        if (alg === "ES384" && namedCurve === "P-384") {
            cryptoKey = keyObject.toCryptoKey({
                name: "ECDSA",
                namedCurve: namedCurve
            }, extractable, [ isPublic ? "verify" : "sign" ]);
        }
        if (alg === "ES512" && namedCurve === "P-521") {
            cryptoKey = keyObject.toCryptoKey({
                name: "ECDSA",
                namedCurve: namedCurve
            }, extractable, [ isPublic ? "verify" : "sign" ]);
        }
        if (alg.startsWith("ECDH-ES")) {
            cryptoKey = keyObject.toCryptoKey({
                name: "ECDH",
                namedCurve: namedCurve
            }, extractable, isPublic ? [] : [ "deriveBits" ]);
        }
    }
    if (!cryptoKey) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (!cached) {
        cache.set(keyObject, {
            [alg]: cryptoKey
        });
    } else {
        cached[alg] = cryptoKey;
    }
    return cryptoKey;
};

async function normalizeKey(key, alg) {
    if (key instanceof Uint8Array) {
        return key;
    }
    if (isCryptoKey(key)) {
        return key;
    }
    if (isKeyObject(key)) {
        if (key.type === "secret") {
            return key.export();
        }
        if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
            try {
                return handleKeyObject(key, alg);
            } catch (err) {
                if (err instanceof TypeError) {
                    throw err;
                }
            }
        }
        let jwk = key.export({
            format: "jwk"
        });
        return handleJWK(key, jwk, alg);
    }
    if (isJWK(key)) {
        if (key.k) {
            return decode(key.k);
        }
        return handleJWK(key, key, alg, true);
    }
    throw new Error("unreachable");
}

const tag = key => key === null || key === void 0 ? void 0 : key[Symbol.toStringTag];

const jwkMatchesOp = (alg, key, usage) => {
    if (key.use !== undefined) {
        let expected;
        switch (usage) {
          case "sign":
          case "verify":
            expected = "sig";
            break;

          case "encrypt":
          case "decrypt":
            expected = "enc";
            break;
        }
        if (key.use !== expected) {
            throw new TypeError('Invalid key for this operation, its "use" must be "'.concat(expected, '" when present'));
        }
    }
    if (key.alg !== undefined && key.alg !== alg) {
        throw new TypeError('Invalid key for this operation, its "alg" must be "'.concat(alg, '" when present'));
    }
    if (Array.isArray(key.key_ops)) {
        var _key$key_ops, _key$key_ops$includes;
        let expectedKeyOp;
        switch (true) {
          case usage === "sign" || usage === "verify":
          case alg === "dir":
          case alg.includes("CBC-HS"):
            expectedKeyOp = usage;
            break;

          case alg.startsWith("PBES2"):
            expectedKeyOp = "deriveBits";
            break;

          case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
            if (!alg.includes("GCM") && alg.endsWith("KW")) {
                expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
            } else {
                expectedKeyOp = usage;
            }
            break;

          case usage === "encrypt" && alg.startsWith("RSA"):
            expectedKeyOp = "wrapKey";
            break;

          case usage === "decrypt":
            expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
            break;
        }
        if (expectedKeyOp && ((_key$key_ops = key.key_ops) === null || _key$key_ops === void 0 || (_key$key_ops$includes = _key$key_ops.includes) === null || _key$key_ops$includes === void 0 ? void 0 : _key$key_ops$includes.call(_key$key_ops, expectedKeyOp)) === false) {
            throw new TypeError('Invalid key for this operation, its "key_ops" must include "'.concat(expectedKeyOp, '" when present'));
        }
    }
    return true;
};

const symmetricTypeCheck = (alg, key, usage) => {
    if (key instanceof Uint8Array) return;
    if (isJWK(key)) {
        if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage)) return;
        throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present');
    }
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
    }
    if (key.type !== "secret") {
        throw new TypeError("".concat(tag(key), ' instances for symmetric algorithms must be of type "secret"'));
    }
};

const asymmetricTypeCheck = (alg, key, usage) => {
    if (isJWK(key)) {
        switch (usage) {
          case "decrypt":
          case "sign":
            if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage)) return;
            throw new TypeError("JSON Web Key for this operation must be a private JWK");

          case "encrypt":
          case "verify":
            if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage)) return;
            throw new TypeError("JSON Web Key for this operation must be a public JWK");
        }
    }
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    if (key.type === "secret") {
        throw new TypeError("".concat(tag(key), ' instances for asymmetric algorithms must not be of type "secret"'));
    }
    if (key.type === "public") {
        switch (usage) {
          case "sign":
            throw new TypeError("".concat(tag(key), ' instances for asymmetric algorithm signing must be of type "private"'));

          case "decrypt":
            throw new TypeError("".concat(tag(key), ' instances for asymmetric algorithm decryption must be of type "private"'));
        }
    }
    if (key.type === "private") {
        switch (usage) {
          case "verify":
            throw new TypeError("".concat(tag(key), ' instances for asymmetric algorithm verifying must be of type "public"'));

          case "encrypt":
            throw new TypeError("".concat(tag(key), ' instances for asymmetric algorithm encryption must be of type "public"'));
        }
    }
};

function checkKeyType(alg, key, usage) {
    switch (alg.substring(0, 2)) {
      case "A1":
      case "A2":
      case "di":
      case "HS":
      case "PB":
        symmetricTypeCheck(alg, key, usage);
        break;

      default:
        asymmetricTypeCheck(alg, key, usage);
    }
}

var _navigator$userAgent$1, _navigator$userAgent$$1;

let headers;

let USER_AGENT$1;

if (typeof navigator === "undefined" || !((_navigator$userAgent$1 = navigator.userAgent) !== null && _navigator$userAgent$1 !== void 0 && (_navigator$userAgent$$1 = _navigator$userAgent$1.startsWith) !== null && _navigator$userAgent$$1 !== void 0 && _navigator$userAgent$$1.call(_navigator$userAgent$1, "Mozilla/5.0 "))) {
    const NAME = "openid-client";
    const VERSION = "v6.8.1";
    USER_AGENT$1 = "".concat(NAME, "/").concat(VERSION);
    headers = {
        "user-agent": USER_AGENT$1
    };
}

const int = config => props.get(config);

let props;

let tbi;

function ClientSecretPost(clientSecret) {
    if (clientSecret !== undefined) {
        return ClientSecretPost$1(clientSecret);
    }
    tbi || (tbi = new WeakMap);
    return (as, client, body, headers) => {
        let auth;
        if (!(auth = tbi.get(client))) {
            assertString(client.client_secret, '"metadata.client_secret"');
            auth = ClientSecretPost$1(client.client_secret);
            tbi.set(client, auth);
        }
        return auth(as, client, body, headers);
    };
}

function assertString(input, it) {
    if (typeof input !== "string") {
        throw CodedTypeError("".concat(it, " must be a string"), ERR_INVALID_ARG_TYPE);
    }
    if (input.length === 0) {
        throw CodedTypeError("".concat(it, " must not be empty"), ERR_INVALID_ARG_VALUE);
    }
}

function None() {
    return None$1();
}

function PrivateKeyJwt(clientPrivateKey, options) {
    return PrivateKeyJwt$1(clientPrivateKey, options);
}

function TlsClientAuth() {
    return TlsClientAuth$1();
}

const customFetch$1 = customFetch$2;

const ERR_INVALID_ARG_VALUE = "ERR_INVALID_ARG_VALUE";

const ERR_INVALID_ARG_TYPE = "ERR_INVALID_ARG_TYPE";

function CodedTypeError(message, code, cause) {
    const err = new TypeError(message, {
        cause: cause
    });
    Object.assign(err, {
        code: code
    });
    return err;
}

function calculatePKCECodeChallenge(codeVerifier) {
    return calculatePKCECodeChallenge$1(codeVerifier);
}

function randomPKCECodeVerifier() {
    return generateRandomCodeVerifier();
}

class ClientError extends Error {
    constructor(message, options) {
        var _Error$captureStackTr;
        super(message, options);
        _defineProperty(this, "code", void 0);
        this.name = this.constructor.name;
        this.code = options === null || options === void 0 ? void 0 : options.code;
        (_Error$captureStackTr = Error.captureStackTrace) === null || _Error$captureStackTr === void 0 || _Error$captureStackTr.call(Error, this, this.constructor);
    }
}

new TextDecoder;

function e(msg, cause, code) {
    return new ClientError(msg, {
        cause: cause,
        code: code
    });
}

function errorHandler(err) {
    if (err instanceof TypeError || err instanceof ClientError || err instanceof ResponseBodyError || err instanceof AuthorizationResponseError || err instanceof WWWAuthenticateChallengeError) {
        throw err;
    }
    if (err instanceof OperationProcessingError) {
        switch (err.code) {
          case HTTP_REQUEST_FORBIDDEN:
            throw e("only requests to HTTPS are allowed", err, err.code);

          case REQUEST_PROTOCOL_FORBIDDEN:
            throw e("only requests to HTTP or HTTPS are allowed", err, err.code);

          case RESPONSE_IS_NOT_CONFORM:
            throw e("unexpected HTTP response status code", err.cause, err.code);

          case RESPONSE_IS_NOT_JSON:
            throw e("unexpected response content-type", err.cause, err.code);

          case PARSE_ERROR:
            throw e("parsing error occured", err, err.code);

          case INVALID_RESPONSE:
            throw e("invalid response encountered", err, err.code);

          case JWT_CLAIM_COMPARISON:
            throw e("unexpected JWT claim value encountered", err, err.code);

          case JSON_ATTRIBUTE_COMPARISON:
            throw e("unexpected JSON attribute value encountered", err, err.code);

          case JWT_TIMESTAMP_CHECK:
            throw e("JWT timestamp claim value failed validation", err, err.code);

          default:
            throw e(err.message, err, err.code);
        }
    }
    if (err instanceof UnsupportedOperationError) {
        throw e("unsupported operation", err, err.code);
    }
    if (err instanceof DOMException) {
        switch (err.name) {
          case "OperationError":
            throw e("runtime operation error", err, UNSUPPORTED_OPERATION);

          case "NotSupportedError":
            throw e("runtime unsupported operation", err, UNSUPPORTED_OPERATION);

          case "TimeoutError":
            throw e("operation timed out", err, "OAUTH_TIMEOUT");

          case "AbortError":
            throw e("operation aborted", err, "OAUTH_ABORT");
        }
    }
    throw new ClientError("something went wrong", {
        cause: err
    });
}

function handleEntraId(server, as, options) {
    if (server.origin === "https://login.microsoftonline.com" && (!(options !== null && options !== void 0 && options.algorithm) || options.algorithm === "oidc")) {
        as[kEntraId] = true;
        return true;
    }
    return false;
}

function handleB2Clogin(server, options) {
    if (server.hostname.endsWith(".b2clogin.com") && (!(options !== null && options !== void 0 && options.algorithm) || options.algorithm === "oidc")) {
        return true;
    }
    return false;
}

async function discovery(server, clientId, metadata, clientAuthentication, options) {
    const as = await performDiscovery(server, options);
    const instance = new Configuration(as, clientId, metadata, clientAuthentication);
    let internals = int(instance);
    if (options !== null && options !== void 0 && options[customFetch$1]) {
        internals.fetch = options[customFetch$1];
    }
    if (options !== null && options !== void 0 && options.timeout) {
        internals.timeout = options.timeout;
    }
    if (options !== null && options !== void 0 && options.execute) {
        for (const extension of options.execute) {
            extension(instance);
        }
    }
    return instance;
}

async function performDiscovery(server, options) {
    var _options$timeout2, _options$execute2;
    if (!(server instanceof URL)) {
        throw CodedTypeError('"server" must be an instance of URL', ERR_INVALID_ARG_TYPE);
    }
    const resolve = !server.href.includes("/.well-known/");
    const timeout = (_options$timeout2 = options === null || options === void 0 ? void 0 : options.timeout) !== null && _options$timeout2 !== void 0 ? _options$timeout2 : 30;
    const signal = AbortSignal.timeout(timeout * 1e3);
    const as = await (resolve ? discoveryRequest(server, {
        algorithm: options === null || options === void 0 ? void 0 : options.algorithm,
        [customFetch$2]: options === null || options === void 0 ? void 0 : options[customFetch$1],
        [allowInsecureRequests$1]: options === null || options === void 0 || (_options$execute2 = options.execute) === null || _options$execute2 === void 0 ? void 0 : _options$execute2.includes(allowInsecureRequests),
        signal: signal,
        headers: new Headers(headers)
    }) : ((options === null || options === void 0 ? void 0 : options[customFetch$1]) || fetch)((_options$execute3 => {
        checkProtocol(server, options !== null && options !== void 0 && (_options$execute3 = options.execute) !== null && _options$execute3 !== void 0 && _options$execute3.includes(allowInsecureRequests) ? false : true);
        return server.href;
    })(), {
        headers: Object.fromEntries(new Headers(_objectSpread2({
            accept: "application/json"
        }, headers)).entries()),
        body: undefined,
        method: "GET",
        redirect: "manual",
        signal: signal
    })).then((response => processDiscoveryResponse(_nodiscoverycheck, response))).catch(errorHandler);
    if (resolve && new URL(as.issuer).href !== server.href) {
        handleEntraId(server, as, options) || handleB2Clogin(server, options) || (() => {
            throw new ClientError("discovered metadata issuer does not match the expected issuer", {
                code: JSON_ATTRIBUTE_COMPARISON,
                cause: {
                    expected: server.href,
                    body: as,
                    attribute: "issuer"
                }
            });
        })();
    }
    return as;
}

function getServerHelpers(metadata) {
    return {
        supportsPKCE: {
            __proto__: null,
            value() {
                var _metadata$code_challe;
                let method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "S256";
                return ((_metadata$code_challe = metadata.code_challenge_methods_supported) === null || _metadata$code_challe === void 0 ? void 0 : _metadata$code_challe.includes(method)) === true;
            }
        }
    };
}

function addServerHelpers(metadata) {
    Object.defineProperties(metadata, getServerHelpers(metadata));
}

const kEntraId = Symbol();

class Configuration {
    constructor(server, clientId, metadata, clientAuthentication) {
        var _metadata, _metadata$oauth$clock3, _metadata2, _metadata$oauth$clock4, _metadata3;
        if (typeof clientId !== "string" || !clientId.length) {
            throw CodedTypeError('"clientId" must be a non-empty string', ERR_INVALID_ARG_TYPE);
        }
        if (typeof metadata === "string") {
            metadata = {
                client_secret: metadata
            };
        }
        if (((_metadata = metadata) === null || _metadata === void 0 ? void 0 : _metadata.client_id) !== undefined && clientId !== metadata.client_id) {
            throw CodedTypeError('"clientId" and "metadata.client_id" must be the same', ERR_INVALID_ARG_VALUE);
        }
        const client = _objectSpread2(_objectSpread2({}, structuredClone(metadata)), {}, {
            client_id: clientId
        });
        client[clockSkew] = (_metadata$oauth$clock3 = (_metadata2 = metadata) === null || _metadata2 === void 0 ? void 0 : _metadata2[clockSkew]) !== null && _metadata$oauth$clock3 !== void 0 ? _metadata$oauth$clock3 : 0;
        client[clockTolerance] = (_metadata$oauth$clock4 = (_metadata3 = metadata) === null || _metadata3 === void 0 ? void 0 : _metadata3[clockTolerance]) !== null && _metadata$oauth$clock4 !== void 0 ? _metadata$oauth$clock4 : 30;
        let auth;
        if (clientAuthentication) {
            auth = clientAuthentication;
        } else {
            if (typeof client.client_secret === "string" && client.client_secret.length) {
                auth = ClientSecretPost(client.client_secret);
            } else {
                auth = None();
            }
        }
        let c = Object.freeze(client);
        const clone = structuredClone(server);
        if (kEntraId in server) {
            clone[_expectedIssuer] = _ref => {
                let {claims: {tid: tid}} = _ref;
                return server.issuer.replace("{tenantid}", tid);
            };
        }
        let as = Object.freeze(clone);
        props || (props = new WeakMap);
        props.set(this, {
            __proto__: null,
            as: as,
            c: c,
            auth: auth,
            tlsOnly: true,
            jwksCache: {}
        });
    }
    serverMetadata() {
        const metadata = structuredClone(int(this).as);
        addServerHelpers(metadata);
        return metadata;
    }
    clientMetadata() {
        const metadata = structuredClone(int(this).c);
        return metadata;
    }
    get timeout() {
        return int(this).timeout;
    }
    set timeout(value) {
        int(this).timeout = value;
    }
    get [customFetch$1]() {
        return int(this).fetch;
    }
    set [customFetch$1](value) {
        int(this).fetch = value;
    }
}

Object.freeze(Configuration.prototype);

function getHelpers(response) {
    let exp = undefined;
    if (response.expires_in !== undefined) {
        const now = new Date;
        now.setSeconds(now.getSeconds() + response.expires_in);
        exp = now.getTime();
    }
    return {
        expiresIn: {
            __proto__: null,
            value() {
                if (exp) {
                    const now = Date.now();
                    if (exp > now) {
                        return Math.floor((exp - now) / 1e3);
                    }
                    return 0;
                }
                return undefined;
            }
        },
        claims: {
            __proto__: null,
            value() {
                try {
                    return getValidatedIdTokenClaims(this);
                } catch (_unused) {
                    return undefined;
                }
            }
        }
    };
}

function addHelpers(response) {
    Object.defineProperties(response, getHelpers(response));
}

async function handleRetryAfter(response, currentInterval, signal) {
    var _response$headers$get;
    let throwIfInvalid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const retryAfter = (_response$headers$get = response.headers.get("retry-after")) === null || _response$headers$get === void 0 ? void 0 : _response$headers$get.trim();
    if (retryAfter === undefined) return;
    let delaySeconds;
    if (/^\d+$/.test(retryAfter)) {
        delaySeconds = parseInt(retryAfter, 10);
    } else {
        const retryDate = new Date(retryAfter);
        if (Number.isFinite(retryDate.getTime())) {
            const now = new Date;
            const delayMs = retryDate.getTime() - now.getTime();
            if (delayMs > 0) {
                delaySeconds = Math.ceil(delayMs / 1e3);
            }
        }
    }
    if (throwIfInvalid && !Number.isFinite(delaySeconds)) {
        throw new OperationProcessingError("invalid Retry-After header value", {
            cause: response
        });
    }
    if (delaySeconds > currentInterval) {
        await wait(delaySeconds - currentInterval, signal);
    }
}

function wait(duration, signal) {
    return new Promise(((resolve, reject) => {
        const waitStep = remaining => {
            try {
                signal.throwIfAborted();
            } catch (err) {
                reject(err);
                return;
            }
            if (remaining <= 0) {
                resolve();
                return;
            }
            const currentWait = Math.min(remaining, 5);
            setTimeout((() => waitStep(remaining - currentWait)), currentWait * 1e3);
        };
        waitStep(duration);
    }));
}

async function initiateBackchannelAuthentication(config, parameters) {
    checkConfig(config);
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, timeout: timeout} = int(config);
    return backchannelAuthenticationRequest(as, c, auth, parameters, {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).then((response => processBackchannelAuthenticationResponse(as, c, response))).catch(errorHandler);
}

async function pollBackchannelAuthenticationGrant(config, backchannelAuthenticationResponse, parameters, options) {
    var _backchannelAuthentic, _options$signal2;
    checkConfig(config);
    parameters = new URLSearchParams(parameters);
    let interval = (_backchannelAuthentic = backchannelAuthenticationResponse.interval) !== null && _backchannelAuthentic !== void 0 ? _backchannelAuthentic : 5;
    const pollingSignal = (_options$signal2 = options === null || options === void 0 ? void 0 : options.signal) !== null && _options$signal2 !== void 0 ? _options$signal2 : AbortSignal.timeout(backchannelAuthenticationResponse.expires_in * 1e3);
    try {
        await wait(interval, pollingSignal);
    } catch (err) {
        errorHandler(err);
    }
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, nonRepudiation: nonRepudiation, timeout: timeout, decrypt: decrypt} = int(config);
    const retryPoll = (updatedInterval, flag) => pollBackchannelAuthenticationGrant(config, _objectSpread2(_objectSpread2({}, backchannelAuthenticationResponse), {}, {
        interval: updatedInterval
    }), parameters, _objectSpread2(_objectSpread2({}, options), {}, {
        signal: pollingSignal,
        flag: flag
    }));
    const response = await backchannelAuthenticationGrantRequest(as, c, auth, backchannelAuthenticationResponse.auth_req_id, {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        additionalParameters: parameters,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: pollingSignal.aborted ? pollingSignal : signal(timeout)
    }).catch(errorHandler);
    if (response.status === 503 && response.headers.has("retry-after")) {
        var _response$body2;
        await handleRetryAfter(response, interval, pollingSignal, true);
        await ((_response$body2 = response.body) === null || _response$body2 === void 0 ? void 0 : _response$body2.cancel());
        return retryPoll(interval);
    }
    const p = processBackchannelAuthenticationGrantResponse(as, c, response, {
        [jweDecrypt]: decrypt
    });
    let result;
    try {
        result = await p;
    } catch (err) {
        if (retryable(err, options)) {
            return retryPoll(interval, retry);
        }
        if (err instanceof ResponseBodyError) {
            switch (err.error) {
              case "slow_down":
                interval += 5;

              case "authorization_pending":
                await handleRetryAfter(err.response, interval, pollingSignal);
                return retryPoll(interval);
            }
        }
        errorHandler(err);
    }
    result.id_token && await (nonRepudiation === null || nonRepudiation === void 0 ? void 0 : nonRepudiation(response));
    addHelpers(result);
    return result;
}

function allowInsecureRequests(config) {
    int(config).tlsOnly = false;
}

function stripParams(url) {
    url = new URL(url);
    url.search = "";
    url.hash = "";
    return url.href;
}

function webInstanceOf(input, toStringTag) {
    try {
        return Object.getPrototypeOf(input)[Symbol.toStringTag] === toStringTag;
    } catch (_unused2) {
        return false;
    }
}

async function authorizationCodeGrant(config, currentUrl, checks, tokenEndpointParameters, options) {
    checkConfig(config);
    if ((options === null || options === void 0 ? void 0 : options.flag) !== retry && !(currentUrl instanceof URL) && !webInstanceOf(currentUrl, "Request")) {
        throw CodedTypeError('"currentUrl" must be an instance of URL, or Request', ERR_INVALID_ARG_TYPE);
    }
    let authResponse;
    let redirectUri;
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, jarm: jarm, hybrid: hybrid, nonRepudiation: nonRepudiation, timeout: timeout, decrypt: decrypt, implicit: implicit} = int(config);
    if ((options === null || options === void 0 ? void 0 : options.flag) === retry) {
        authResponse = options.authResponse;
        redirectUri = options.redirectUri;
    } else {
        if (!(currentUrl instanceof URL)) {
            const request = currentUrl;
            currentUrl = new URL(currentUrl.url);
            switch (request.method) {
              case "GET":
                break;

              case "POST":
                const params = new URLSearchParams(await formPostResponse(request));
                if (hybrid) {
                    currentUrl.hash = params.toString();
                } else {
                    for (const [k, v] of params.entries()) {
                        currentUrl.searchParams.append(k, v);
                    }
                }
                break;

              default:
                throw CodedTypeError("unexpected Request HTTP method", ERR_INVALID_ARG_VALUE);
            }
        }
        redirectUri = stripParams(currentUrl);
        switch (true) {
          case !!jarm:
            authResponse = await jarm(currentUrl, checks === null || checks === void 0 ? void 0 : checks.expectedState);
            break;

          case !!hybrid:
            authResponse = await hybrid(currentUrl, checks === null || checks === void 0 ? void 0 : checks.expectedNonce, checks === null || checks === void 0 ? void 0 : checks.expectedState, checks === null || checks === void 0 ? void 0 : checks.maxAge);
            break;

          case !!implicit:
            throw new TypeError("authorizationCodeGrant() cannot be used by response_type=id_token clients");

          default:
            try {
                authResponse = validateAuthResponse(as, c, currentUrl.searchParams, checks === null || checks === void 0 ? void 0 : checks.expectedState);
            } catch (err) {
                errorHandler(err);
            }
        }
    }
    const response = await authorizationCodeGrantRequest(as, c, auth, authResponse, redirectUri, (checks === null || checks === void 0 ? void 0 : checks.pkceCodeVerifier) || nopkce, {
        additionalParameters: tokenEndpointParameters,
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).catch(errorHandler);
    if (typeof (checks === null || checks === void 0 ? void 0 : checks.expectedNonce) === "string" || typeof (checks === null || checks === void 0 ? void 0 : checks.maxAge) === "number") {
        checks.idTokenExpected = true;
    }
    const p = processAuthorizationCodeResponse(as, c, response, {
        expectedNonce: checks === null || checks === void 0 ? void 0 : checks.expectedNonce,
        maxAge: checks === null || checks === void 0 ? void 0 : checks.maxAge,
        requireIdToken: checks === null || checks === void 0 ? void 0 : checks.idTokenExpected,
        [jweDecrypt]: decrypt
    });
    let result;
    try {
        result = await p;
    } catch (err) {
        if (retryable(err, options)) {
            return authorizationCodeGrant(config, undefined, checks, tokenEndpointParameters, _objectSpread2(_objectSpread2({}, options), {}, {
                flag: retry,
                authResponse: authResponse,
                redirectUri: redirectUri
            }));
        }
        errorHandler(err);
    }
    result.id_token && await (nonRepudiation === null || nonRepudiation === void 0 ? void 0 : nonRepudiation(response));
    addHelpers(result);
    return result;
}

async function refreshTokenGrant(config, refreshToken, parameters, options) {
    checkConfig(config);
    parameters = new URLSearchParams(parameters);
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, nonRepudiation: nonRepudiation, timeout: timeout, decrypt: decrypt} = int(config);
    const response = await refreshTokenGrantRequest(as, c, auth, refreshToken, {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        additionalParameters: parameters,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).catch(errorHandler);
    const p = processRefreshTokenResponse(as, c, response, {
        [jweDecrypt]: decrypt
    });
    let result;
    try {
        result = await p;
    } catch (err) {
        if (retryable(err, options)) {
            return refreshTokenGrant(config, refreshToken, parameters, _objectSpread2(_objectSpread2({}, options), {}, {
                flag: retry
            }));
        }
        errorHandler(err);
    }
    result.id_token && await (nonRepudiation === null || nonRepudiation === void 0 ? void 0 : nonRepudiation(response));
    addHelpers(result);
    return result;
}

async function clientCredentialsGrant(config, parameters, options) {
    checkConfig(config);
    parameters = new URLSearchParams(parameters);
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, timeout: timeout} = int(config);
    const response = await clientCredentialsGrantRequest(as, c, auth, parameters, {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).catch(errorHandler);
    const p = processClientCredentialsResponse(as, c, response);
    let result;
    try {
        result = await p;
    } catch (err) {
        if (retryable(err, options)) {
            return clientCredentialsGrant(config, parameters, _objectSpread2(_objectSpread2({}, options), {}, {
                flag: retry
            }));
        }
        errorHandler(err);
    }
    addHelpers(result);
    return result;
}

function buildAuthorizationUrl(config, parameters) {
    checkConfig(config);
    const {as: as, c: c, tlsOnly: tlsOnly, hybrid: hybrid, jarm: jarm, implicit: implicit} = int(config);
    const authorizationEndpoint = resolveEndpoint(as, "authorization_endpoint", false, tlsOnly);
    parameters = new URLSearchParams(parameters);
    if (!parameters.has("client_id")) {
        parameters.set("client_id", c.client_id);
    }
    if (!parameters.has("request_uri") && !parameters.has("request")) {
        if (!parameters.has("response_type")) {
            parameters.set("response_type", hybrid ? "code id_token" : implicit ? "id_token" : "code");
        }
        if (implicit && !parameters.has("nonce")) {
            throw CodedTypeError("response_type=id_token clients must provide a nonce parameter in their authorization request parameters", ERR_INVALID_ARG_VALUE);
        }
        if (jarm) {
            parameters.set("response_mode", "jwt");
        }
    }
    for (const [k, v] of parameters.entries()) {
        authorizationEndpoint.searchParams.append(k, v);
    }
    return authorizationEndpoint;
}

async function buildAuthorizationUrlWithPAR(config, parameters, options) {
    checkConfig(config);
    const authorizationEndpoint = buildAuthorizationUrl(config, parameters);
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, timeout: timeout} = int(config);
    const response = await pushedAuthorizationRequest(as, c, auth, authorizationEndpoint.searchParams, {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).catch(errorHandler);
    const p = processPushedAuthorizationResponse(as, c, response);
    let result;
    try {
        result = await p;
    } catch (err) {
        if (retryable(err, options)) {
            return buildAuthorizationUrlWithPAR(config, parameters, _objectSpread2(_objectSpread2({}, options), {}, {
                flag: retry
            }));
        }
        errorHandler(err);
    }
    return buildAuthorizationUrl(config, {
        request_uri: result.request_uri
    });
}

function buildEndSessionUrl(config, parameters) {
    checkConfig(config);
    const {as: as, c: c, tlsOnly: tlsOnly} = int(config);
    const endSessionEndpoint = resolveEndpoint(as, "end_session_endpoint", false, tlsOnly);
    parameters = new URLSearchParams(parameters);
    if (!parameters.has("client_id")) {
        parameters.set("client_id", c.client_id);
    }
    for (const [k, v] of parameters.entries()) {
        endSessionEndpoint.searchParams.append(k, v);
    }
    return endSessionEndpoint;
}

function checkConfig(input) {
    if (!(input instanceof Configuration)) {
        throw CodedTypeError('"config" must be an instance of Configuration', ERR_INVALID_ARG_TYPE);
    }
    if (Object.getPrototypeOf(input) !== Configuration.prototype) {
        throw CodedTypeError("subclassing Configuration is not allowed", ERR_INVALID_ARG_VALUE);
    }
}

function signal(timeout) {
    return timeout ? AbortSignal.timeout(timeout * 1e3) : undefined;
}

function retryable(err, options) {
    if (options !== null && options !== void 0 && options.DPoP && options.flag !== retry) {
        return isDPoPNonceError(err);
    }
    return false;
}

const retry = Symbol();

async function genericGrantRequest(config, grantType, parameters, options) {
    checkConfig(config);
    const {as: as, c: c, auth: auth, fetch: fetch, tlsOnly: tlsOnly, timeout: timeout, decrypt: decrypt} = int(config);
    const result = await genericTokenEndpointRequest(as, c, auth, grantType, new URLSearchParams(parameters), {
        [customFetch$2]: fetch,
        [allowInsecureRequests$1]: !tlsOnly,
        DPoP: options === null || options === void 0 ? void 0 : options.DPoP,
        headers: new Headers(headers),
        signal: signal(timeout)
    }).then((response => {
        let recognizedTokenTypes;
        if (grantType === "urn:ietf:params:oauth:grant-type:token-exchange") {
            recognizedTokenTypes = {
                n_a: () => {}
            };
        }
        return processGenericTokenEndpointResponse(as, c, response, {
            [jweDecrypt]: decrypt,
            recognizedTokenTypes: recognizedTokenTypes
        });
    })).catch(errorHandler);
    addHelpers(result);
    return result;
}

function subtleAlgorithm(alg, algorithm) {
    const hash = "SHA-".concat(alg.slice(-3));
    switch (alg) {
      case "HS256":
      case "HS384":
      case "HS512":
        return {
            hash: hash,
            name: "HMAC"
        };

      case "PS256":
      case "PS384":
      case "PS512":
        return {
            hash: hash,
            name: "RSA-PSS",
            saltLength: parseInt(alg.slice(-3), 10) >> 3
        };

      case "RS256":
      case "RS384":
      case "RS512":
        return {
            hash: hash,
            name: "RSASSA-PKCS1-v1_5"
        };

      case "ES256":
      case "ES384":
      case "ES512":
        return {
            hash: hash,
            name: "ECDSA",
            namedCurve: algorithm.namedCurve
        };

      case "Ed25519":
      case "EdDSA":
        return {
            name: "Ed25519"
        };

      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
        return {
            name: alg
        };

      default:
        throw new JOSENotSupported("alg ".concat(alg, " is not supported either by JOSE or your javascript runtime"));
    }
}

async function getSigKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith("HS")) {
            throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
        }
        return crypto.subtle.importKey("raw", key, {
            hash: "SHA-".concat(alg.slice(-3)),
            name: "HMAC"
        }, false, [ usage ]);
    }
    checkSigCryptoKey(key, alg, usage);
    return key;
}

async function verify(alg, key, signature, data) {
    const cryptoKey = await getSigKey(alg, key, "verify");
    checkKeyLength(alg, cryptoKey);
    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);
    try {
        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
    } catch (_unused) {
        return false;
    }
}

async function flattenedVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid("Flattened JWS must be an object");
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== "string") {
        throw new JWSInvalid("JWS Protected Header incorrect type");
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid("JWS Payload missing");
    }
    if (typeof jws.signature !== "string") {
        throw new JWSInvalid("JWS Signature missing or incorrect type");
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid("JWS Unprotected Header incorrect type");
    }
    let parsedProt = {};
    if (jws.protected) {
        try {
            const protectedHeader = decode(jws.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        } catch (_unused) {
            throw new JWSInvalid("JWS Protected Header is invalid");
        }
    }
    if (!isDisjoint(parsedProt, jws.header)) {
        throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = _objectSpread2(_objectSpread2({}, parsedProt), jws.header);
    const extensions = validateCrit(JWSInvalid, new Map([ [ "b64", true ] ]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
        b64 = parsedProt.b64;
        if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const {alg: alg} = joseHeader;
    if (typeof alg !== "string" || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== "string") {
            throw new JWSInvalid("JWS Payload must be a string");
        }
    } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
    }
    let resolvedKey = false;
    if (typeof key === "function") {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    checkKeyType(alg, key, "verify");
    const data = concat(jws.protected !== undefined ? encode(jws.protected) : new Uint8Array, encode("."), typeof jws.payload === "string" ? b64 ? encode(jws.payload) : encoder.encode(jws.payload) : jws.payload);
    let signature;
    try {
        signature = decode(jws.signature);
    } catch (_unused2) {
        throw new JWSInvalid("Failed to base64url decode the signature");
    }
    const k = await normalizeKey(key, alg);
    const verified = await verify(alg, k, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed;
    }
    let payload;
    if (b64) {
        try {
            payload = decode(jws.payload);
        } catch (_unused3) {
            throw new JWSInvalid("Failed to base64url decode the payload");
        }
    } else if (typeof jws.payload === "string") {
        payload = encoder.encode(jws.payload);
    } else {
        payload = jws.payload;
    }
    const result = {
        payload: payload
    };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return _objectSpread2(_objectSpread2({}, result), {}, {
            key: k
        });
    }
    return result;
}

async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
    }
    if (typeof jws !== "string") {
        throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
    }
    const {0: protectedHeader, 1: payload, 2: signature, length: length} = jws.split(".");
    if (length !== 3) {
        throw new JWSInvalid("Invalid Compact JWS");
    }
    const verified = await flattenedVerify({
        payload: payload,
        protected: protectedHeader,
        signature: signature
    }, key, options);
    const result = {
        payload: verified.payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === "function") {
        return _objectSpread2(_objectSpread2({}, result), {}, {
            key: verified.key
        });
    }
    return result;
}

const epoch = date => Math.floor(date.getTime() / 1e3);

const minute = 60;

const hour = minute * 60;

const day = hour * 24;

const week = day * 7;

const year = day * 365.25;

const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;

function secs(str) {
    const matched = REGEX.exec(str);
    if (!matched || matched[4] && matched[1]) {
        throw new TypeError("Invalid time period format");
    }
    const value = parseFloat(matched[2]);
    const unit = matched[3].toLowerCase();
    let numericDate;
    switch (unit) {
      case "sec":
      case "secs":
      case "second":
      case "seconds":
      case "s":
        numericDate = Math.round(value);
        break;

      case "minute":
      case "minutes":
      case "min":
      case "mins":
      case "m":
        numericDate = Math.round(value * minute);
        break;

      case "hour":
      case "hours":
      case "hr":
      case "hrs":
      case "h":
        numericDate = Math.round(value * hour);
        break;

      case "day":
      case "days":
      case "d":
        numericDate = Math.round(value * day);
        break;

      case "week":
      case "weeks":
      case "w":
        numericDate = Math.round(value * week);
        break;

      default:
        numericDate = Math.round(value * year);
        break;
    }
    if (matched[1] === "-" || matched[4] === "ago") {
        return -numericDate;
    }
    return numericDate;
}

const normalizeTyp = value => {
    if (value.includes("/")) {
        return value.toLowerCase();
    }
    return "application/".concat(value.toLowerCase());
};

const checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};

function validateClaimsSet(protectedHeader, encodedPayload) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let payload;
    try {
        payload = JSON.parse(decoder.decode(encodedPayload));
    } catch (_unused) {}
    if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
    }
    const {typ: typ} = options;
    if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
    }
    const {requiredClaims: requiredClaims = [], issuer: issuer, subject: subject, audience: audience, maxTokenAge: maxTokenAge} = options;
    const presenceCheck = [ ...requiredClaims ];
    if (maxTokenAge !== undefined) presenceCheck.push("iat");
    if (audience !== undefined) presenceCheck.push("aud");
    if (subject !== undefined) presenceCheck.push("sub");
    if (issuer !== undefined) presenceCheck.push("iss");
    for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
            throw new JWTClaimValidationFailed('missing required "'.concat(claim, '" claim'), payload, claim, "missing");
        }
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [ issuer ]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
    }
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
    }
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [ audience ] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
      case "string":
        tolerance = secs(options.clockTolerance);
        break;

      case "number":
        tolerance = options.clockTolerance;
        break;

      case "undefined":
        tolerance = 0;
        break;

      default:
        throw new TypeError("Invalid clockTolerance option type");
    }
    const {currentDate: currentDate} = options;
    const now = epoch(currentDate || new Date);
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== "number") {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== "number") {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
        }
    }
    if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
        }
    }
    return payload;
}

async function jwtVerify(jwt, key, options) {
    var _verified$protectedHe;
    const verified = await compactVerify(jwt, key, options);
    if ((_verified$protectedHe = verified.protectedHeader.crit) !== null && _verified$protectedHe !== void 0 && _verified$protectedHe.includes("b64") && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
    const result = {
        payload: payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === "function") {
        return _objectSpread2(_objectSpread2({}, result), {}, {
            key: verified.key
        });
    }
    return result;
}

function getKtyFromAlg(alg) {
    switch (typeof alg === "string" && alg.slice(0, 2)) {
      case "RS":
      case "PS":
        return "RSA";

      case "ES":
        return "EC";

      case "Ed":
        return "OKP";

      case "ML":
        return "AKP";

      default:
        throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
}

function isJWKSLike(jwks) {
    return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}

function isJWKLike(key) {
    return isObject(key);
}

var _jwks$1 = new WeakMap;

var _cached2 = new WeakMap;

class LocalJWKSet {
    constructor(jwks) {
        _classPrivateFieldInitSpec(this, _jwks$1, void 0);
        _classPrivateFieldInitSpec(this, _cached2, new WeakMap);
        if (!isJWKSLike(jwks)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        _classPrivateFieldSet2(_jwks$1, this, structuredClone(jwks));
    }
    jwks() {
        return _classPrivateFieldGet2(_jwks$1, this);
    }
    async getKey(protectedHeader, token) {
        const {alg: alg, kid: kid} = _objectSpread2(_objectSpread2({}, protectedHeader), token === null || token === void 0 ? void 0 : token.header);
        const kty = getKtyFromAlg(alg);
        const candidates = _classPrivateFieldGet2(_jwks$1, this).keys.filter((jwk => {
            let candidate = kty === jwk.kty;
            if (candidate && typeof kid === "string") {
                candidate = kid === jwk.kid;
            }
            if (candidate && (typeof jwk.alg === "string" || kty === "AKP")) {
                candidate = alg === jwk.alg;
            }
            if (candidate && typeof jwk.use === "string") {
                candidate = jwk.use === "sig";
            }
            if (candidate && Array.isArray(jwk.key_ops)) {
                candidate = jwk.key_ops.includes("verify");
            }
            if (candidate) {
                switch (alg) {
                  case "ES256":
                    candidate = jwk.crv === "P-256";
                    break;

                  case "ES384":
                    candidate = jwk.crv === "P-384";
                    break;

                  case "ES512":
                    candidate = jwk.crv === "P-521";
                    break;

                  case "Ed25519":
                  case "EdDSA":
                    candidate = jwk.crv === "Ed25519";
                    break;
                }
            }
            return candidate;
        }));
        const {0: jwk, length: length} = candidates;
        if (length === 0) {
            throw new JWKSNoMatchingKey;
        }
        if (length !== 1) {
            const error = new JWKSMultipleMatchingKeys;
            const _cached = _classPrivateFieldGet2(_cached2, this);
            error[Symbol.asyncIterator] = _wrapAsyncGenerator((function*() {
                for (const jwk of candidates) {
                    try {
                        yield yield _awaitAsyncGenerator(importWithAlgCache(_cached, jwk, alg));
                    } catch (_unused) {}
                }
            }));
            throw error;
        }
        return importWithAlgCache(_classPrivateFieldGet2(_cached2, this), jwk, alg);
    }
}

async function importWithAlgCache(cache, jwk, alg) {
    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
    if (cached[alg] === undefined) {
        const key = await importJWK(_objectSpread2(_objectSpread2({}, jwk), {}, {
            ext: true
        }), alg);
        if (key instanceof Uint8Array || key.type !== "public") {
            throw new JWKSInvalid("JSON Web Key Set members must be public keys");
        }
        cached[alg] = key;
    }
    return cached[alg];
}

function createLocalJWKSet(jwks) {
    const set = new LocalJWKSet(jwks);
    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
    Object.defineProperties(localJWKSet, {
        jwks: {
            value: () => structuredClone(set.jwks()),
            enumerable: false,
            configurable: false,
            writable: false
        }
    });
    return localJWKSet;
}

var _navigator$userAgent, _navigator$userAgent$;

function isCloudflareWorkers() {
    return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}

let USER_AGENT;

if (typeof navigator === "undefined" || !((_navigator$userAgent = navigator.userAgent) !== null && _navigator$userAgent !== void 0 && (_navigator$userAgent$ = _navigator$userAgent.startsWith) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$.call(_navigator$userAgent, "Mozilla/5.0 "))) {
    const NAME = "jose";
    const VERSION = "v6.1.3";
    USER_AGENT = "".concat(NAME, "/").concat(VERSION);
}

const customFetch = Symbol();

async function fetchJwks(url, headers, signal) {
    let fetchImpl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fetch;
    const response = await fetchImpl(url, {
        method: "GET",
        signal: signal,
        redirect: "manual",
        headers: headers
    }).catch((err => {
        if (err.name === "TimeoutError") {
            throw new JWKSTimeout;
        }
        throw err;
    }));
    if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
    }
    try {
        return await response.json();
    } catch (_unused) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
    }
}

const jwksCache = Symbol();

function isFreshJwksCache(input, cacheMaxAge) {
    if (typeof input !== "object" || input === null) {
        return false;
    }
    if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
        return false;
    }
    if (!("jwks" in input) || !isObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject)) {
        return false;
    }
    return true;
}

var _url = new WeakMap;

var _timeoutDuration = new WeakMap;

var _cooldownDuration = new WeakMap;

var _cacheMaxAge = new WeakMap;

var _jwksTimestamp = new WeakMap;

var _pendingFetch = new WeakMap;

var _headers = new WeakMap;

var _customFetch$1 = new WeakMap;

var _local = new WeakMap;

var _cache = new WeakMap;

class RemoteJWKSet {
    constructor(url, options) {
        _classPrivateFieldInitSpec(this, _url, void 0);
        _classPrivateFieldInitSpec(this, _timeoutDuration, void 0);
        _classPrivateFieldInitSpec(this, _cooldownDuration, void 0);
        _classPrivateFieldInitSpec(this, _cacheMaxAge, void 0);
        _classPrivateFieldInitSpec(this, _jwksTimestamp, void 0);
        _classPrivateFieldInitSpec(this, _pendingFetch, void 0);
        _classPrivateFieldInitSpec(this, _headers, void 0);
        _classPrivateFieldInitSpec(this, _customFetch$1, void 0);
        _classPrivateFieldInitSpec(this, _local, void 0);
        _classPrivateFieldInitSpec(this, _cache, void 0);
        if (!(url instanceof URL)) {
            throw new TypeError("url must be an instance of URL");
        }
        _classPrivateFieldSet2(_url, this, new URL(url.href));
        _classPrivateFieldSet2(_timeoutDuration, this, typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3);
        _classPrivateFieldSet2(_cooldownDuration, this, typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4);
        _classPrivateFieldSet2(_cacheMaxAge, this, typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5);
        _classPrivateFieldSet2(_headers, this, new Headers(options === null || options === void 0 ? void 0 : options.headers));
        if (USER_AGENT && !_classPrivateFieldGet2(_headers, this).has("User-Agent")) {
            _classPrivateFieldGet2(_headers, this).set("User-Agent", USER_AGENT);
        }
        if (!_classPrivateFieldGet2(_headers, this).has("accept")) {
            _classPrivateFieldGet2(_headers, this).set("accept", "application/json");
            _classPrivateFieldGet2(_headers, this).append("accept", "application/jwk-set+json");
        }
        _classPrivateFieldSet2(_customFetch$1, this, options === null || options === void 0 ? void 0 : options[customFetch]);
        if ((options === null || options === void 0 ? void 0 : options[jwksCache]) !== undefined) {
            _classPrivateFieldSet2(_cache, this, options === null || options === void 0 ? void 0 : options[jwksCache]);
            if (isFreshJwksCache(options === null || options === void 0 ? void 0 : options[jwksCache], _classPrivateFieldGet2(_cacheMaxAge, this))) {
                _classPrivateFieldSet2(_jwksTimestamp, this, _classPrivateFieldGet2(_cache, this).uat);
                _classPrivateFieldSet2(_local, this, createLocalJWKSet(_classPrivateFieldGet2(_cache, this).jwks));
            }
        }
    }
    pendingFetch() {
        return !!_classPrivateFieldGet2(_pendingFetch, this);
    }
    coolingDown() {
        return typeof _classPrivateFieldGet2(_jwksTimestamp, this) === "number" ? Date.now() < _classPrivateFieldGet2(_jwksTimestamp, this) + _classPrivateFieldGet2(_cooldownDuration, this) : false;
    }
    fresh() {
        return typeof _classPrivateFieldGet2(_jwksTimestamp, this) === "number" ? Date.now() < _classPrivateFieldGet2(_jwksTimestamp, this) + _classPrivateFieldGet2(_cacheMaxAge, this) : false;
    }
    jwks() {
        var _classPrivateFieldGet2$1;
        return (_classPrivateFieldGet2$1 = _classPrivateFieldGet2(_local, this)) === null || _classPrivateFieldGet2$1 === void 0 ? void 0 : _classPrivateFieldGet2$1.jwks();
    }
    async getKey(protectedHeader, token) {
        if (!_classPrivateFieldGet2(_local, this) || !this.fresh()) {
            await this.reload();
        }
        try {
            return await _classPrivateFieldGet2(_local, this).call(this, protectedHeader, token);
        } catch (err) {
            if (err instanceof JWKSNoMatchingKey) {
                if (this.coolingDown() === false) {
                    await this.reload();
                    return _classPrivateFieldGet2(_local, this).call(this, protectedHeader, token);
                }
            }
            throw err;
        }
    }
    async reload() {
        if (_classPrivateFieldGet2(_pendingFetch, this) && isCloudflareWorkers()) {
            _classPrivateFieldSet2(_pendingFetch, this, undefined);
        }
        _classPrivateFieldGet2(_pendingFetch, this) || _classPrivateFieldSet2(_pendingFetch, this, fetchJwks(_classPrivateFieldGet2(_url, this).href, _classPrivateFieldGet2(_headers, this), AbortSignal.timeout(_classPrivateFieldGet2(_timeoutDuration, this)), _classPrivateFieldGet2(_customFetch$1, this)).then((json => {
            _classPrivateFieldSet2(_local, this, createLocalJWKSet(json));
            if (_classPrivateFieldGet2(_cache, this)) {
                _classPrivateFieldGet2(_cache, this).uat = Date.now();
                _classPrivateFieldGet2(_cache, this).jwks = json;
            }
            _classPrivateFieldSet2(_jwksTimestamp, this, Date.now());
            _classPrivateFieldSet2(_pendingFetch, this, undefined);
        })).catch((err => {
            _classPrivateFieldSet2(_pendingFetch, this, undefined);
            throw err;
        })));
        await _classPrivateFieldGet2(_pendingFetch, this);
    }
}

function createRemoteJWKSet(url, options) {
    const set = new RemoteJWKSet(url, options);
    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);
    Object.defineProperties(remoteJWKSet, {
        coolingDown: {
            get: () => set.coolingDown(),
            enumerable: true,
            configurable: false
        },
        fresh: {
            get: () => set.fresh(),
            enumerable: true,
            configurable: false
        },
        reload: {
            value: () => set.reload(),
            enumerable: true,
            configurable: false,
            writable: false
        },
        reloading: {
            get: () => set.pendingFetch(),
            enumerable: true,
            configurable: false
        },
        jwks: {
            value: () => set.jwks(),
            enumerable: true,
            configurable: false,
            writable: false
        }
    });
    return remoteJWKSet;
}

const _excluded = [ "mfaToken" ], _excluded2 = [ "mfaToken" ];

var _baseUrl, _clientId, _customFetch, _configuration, _serverMetadata, _options, _jwks, _Class8_brand;

var NotSupportedError = class NotSupportedError extends Error {
    constructor(code, message) {
        super(message);
        _defineProperty(this, "code", void 0);
        this.name = "NotSupportedError";
        this.code = code;
    }
};

var ApiError = class ApiError extends Error {
    constructor(code, message, cause) {
        super(message);
        _defineProperty(this, "cause", void 0);
        _defineProperty(this, "code", void 0);
        this.code = code;
        this.cause = cause && {
            error: cause.error,
            error_description: cause.error_description,
            message: cause.message
        };
    }
};

var TokenByCodeError = class extends ApiError {
    constructor(message, cause) {
        super("token_by_code_error", message, cause);
        this.name = "TokenByCodeError";
    }
};

var TokenByClientCredentialsError = class extends ApiError {
    constructor(message, cause) {
        super("token_by_client_credentials_error", message, cause);
        this.name = "TokenByClientCredentialsError";
    }
};

var TokenByRefreshTokenError = class extends ApiError {
    constructor(message, cause) {
        super("token_by_refresh_token_error", message, cause);
        this.name = "TokenByRefreshTokenError";
    }
};

var TokenForConnectionError = class extends ApiError {
    constructor(message, cause) {
        super("token_for_connection_error", message, cause);
        this.name = "TokenForConnectionErrorCode";
    }
};

var TokenExchangeError = class extends ApiError {
    constructor(message, cause) {
        super("token_exchange_error", message, cause);
        this.name = "TokenExchangeError";
    }
};

var VerifyLogoutTokenError = class VerifyLogoutTokenError extends Error {
    constructor(message) {
        super(message);
        _defineProperty(this, "code", "verify_logout_token_error");
        this.name = "VerifyLogoutTokenError";
    }
};

var BackchannelAuthenticationError = class BackchannelAuthenticationError extends ApiError {
    constructor(cause) {
        super("backchannel_authentication_error", "There was an error when trying to use Client-Initiated Backchannel Authentication.", cause);
        _defineProperty(this, "code", "backchannel_authentication_error");
        this.name = "BackchannelAuthenticationError";
    }
};

var BuildAuthorizationUrlError = class extends ApiError {
    constructor(cause) {
        super("build_authorization_url_error", "There was an error when trying to build the authorization URL.", cause);
        this.name = "BuildAuthorizationUrlError";
    }
};

var BuildLinkUserUrlError = class extends ApiError {
    constructor(cause) {
        super("build_link_user_url_error", "There was an error when trying to build the Link User URL.", cause);
        this.name = "BuildLinkUserUrlError";
    }
};

var BuildUnlinkUserUrlError = class extends ApiError {
    constructor(cause) {
        super("build_unlink_user_url_error", "There was an error when trying to build the Unlink User URL.", cause);
        this.name = "BuildUnlinkUserUrlError";
    }
};

var MissingClientAuthError = class MissingClientAuthError extends Error {
    constructor() {
        super("The client secret or client assertion signing key must be provided.");
        _defineProperty(this, "code", "missing_client_auth_error");
        this.name = "MissingClientAuthError";
    }
};

function stripUndefinedProperties(value) {
    return Object.entries(value).filter((_ref => {
        let [, value2] = _ref;
        return typeof value2 !== "undefined";
    })).reduce(((acc, curr) => _objectSpread2(_objectSpread2({}, acc), {}, {
        [curr[0]]: curr[1]
    })), {});
}

var MfaError$1 = class MfaError extends Error {
    constructor(code, message, cause) {
        super(message);
        _defineProperty(this, "cause", void 0);
        _defineProperty(this, "code", void 0);
        this.code = code;
        this.cause = cause && {
            error: cause.error,
            error_description: cause.error_description,
            message: cause.message
        };
    }
};

var MfaListAuthenticatorsError$1 = class extends MfaError$1 {
    constructor(message, cause) {
        super("mfa_list_authenticators_error", message, cause);
        this.name = "MfaListAuthenticatorsError";
    }
};

var MfaEnrollmentError$1 = class extends MfaError$1 {
    constructor(message, cause) {
        super("mfa_enrollment_error", message, cause);
        this.name = "MfaEnrollmentError";
    }
};

var MfaDeleteAuthenticatorError = class extends MfaError$1 {
    constructor(message, cause) {
        super("mfa_delete_authenticator_error", message, cause);
        this.name = "MfaDeleteAuthenticatorError";
    }
};

var MfaChallengeError$1 = class extends MfaError$1 {
    constructor(message, cause) {
        super("mfa_challenge_error", message, cause);
        this.name = "MfaChallengeError";
    }
};

function transformAuthenticatorResponse(api) {
    return {
        id: api.id,
        authenticatorType: api.authenticator_type,
        active: api.active,
        name: api.name,
        oobChannels: api.oob_channels,
        type: api.type
    };
}

function transformEnrollmentResponse(api) {
    if (api.authenticator_type === "otp") {
        return {
            authenticatorType: "otp",
            secret: api.secret,
            barcodeUri: api.barcode_uri,
            recoveryCodes: api.recovery_codes,
            id: api.id
        };
    }
    if (api.authenticator_type === "oob") {
        return {
            authenticatorType: "oob",
            oobChannel: api.oob_channel,
            oobCode: api.oob_code,
            bindingMethod: api.binding_method,
            id: api.id
        };
    }
    throw new Error("Unexpected authenticator type: ".concat(api.authenticator_type));
}

function transformChallengeResponse(api) {
    const result = {
        challengeType: api.challenge_type
    };
    if (api.oob_code !== void 0) {
        result.oobCode = api.oob_code;
    }
    if (api.binding_method !== void 0) {
        result.bindingMethod = api.binding_method;
    }
    return result;
}

var MfaClient = (_baseUrl = new WeakMap, _clientId = new WeakMap, _customFetch = new WeakMap, 
class MfaClient {
    constructor(options) {
        var _options$customFetch;
        _classPrivateFieldInitSpec(this, _baseUrl, void 0);
        _classPrivateFieldInitSpec(this, _clientId, void 0);
        _classPrivateFieldInitSpec(this, _customFetch, void 0);
        _classPrivateFieldSet2(_baseUrl, this, "https://".concat(options.domain));
        _classPrivateFieldSet2(_clientId, this, options.clientId);
        _classPrivateFieldSet2(_customFetch, this, (_options$customFetch = options.customFetch) !== null && _options$customFetch !== void 0 ? _options$customFetch : function() {
            return fetch(...arguments);
        });
    }
    async listAuthenticators(options) {
        const url = "".concat(_classPrivateFieldGet2(_baseUrl, this), "/mfa/authenticators");
        const {mfaToken: mfaToken} = options;
        const response = await _classPrivateFieldGet2(_customFetch, this).call(this, url, {
            method: "GET",
            headers: {
                Authorization: "Bearer ".concat(mfaToken),
                "Content-Type": "application/json"
            }
        });
        if (!response.ok) {
            const error = await response.json();
            throw new MfaListAuthenticatorsError$1(error.error_description || "Failed to list authenticators", error);
        }
        const apiResponse = await response.json();
        return apiResponse.map(transformAuthenticatorResponse);
    }
    async enrollAuthenticator(options) {
        const url = "".concat(_classPrivateFieldGet2(_baseUrl, this), "/mfa/associate");
        const {mfaToken: mfaToken} = options, sdkParams = _objectWithoutProperties(options, _excluded);
        const apiParams = {
            authenticator_types: sdkParams.authenticatorTypes
        };
        if ("oobChannels" in sdkParams) {
            apiParams.oob_channels = sdkParams.oobChannels;
        }
        if ("phoneNumber" in sdkParams && sdkParams.phoneNumber) {
            apiParams.phone_number = sdkParams.phoneNumber;
        }
        if ("email" in sdkParams && sdkParams.email) {
            apiParams.email = sdkParams.email;
        }
        const response = await _classPrivateFieldGet2(_customFetch, this).call(this, url, {
            method: "POST",
            headers: {
                Authorization: "Bearer ".concat(mfaToken),
                "Content-Type": "application/json"
            },
            body: JSON.stringify(apiParams)
        });
        if (!response.ok) {
            const error = await response.json();
            throw new MfaEnrollmentError$1(error.error_description || "Failed to enroll authenticator", error);
        }
        const apiResponse = await response.json();
        return transformEnrollmentResponse(apiResponse);
    }
    async deleteAuthenticator(options) {
        const {authenticatorId: authenticatorId, mfaToken: mfaToken} = options;
        const url = "".concat(_classPrivateFieldGet2(_baseUrl, this), "/mfa/authenticators/").concat(encodeURIComponent(authenticatorId));
        const response = await _classPrivateFieldGet2(_customFetch, this).call(this, url, {
            method: "DELETE",
            headers: {
                Authorization: "Bearer ".concat(mfaToken),
                "Content-Type": "application/json"
            }
        });
        if (!response.ok) {
            const error = await response.json();
            throw new MfaDeleteAuthenticatorError(error.error_description || "Failed to delete authenticator", error);
        }
    }
    async challengeAuthenticator(options) {
        const url = "".concat(_classPrivateFieldGet2(_baseUrl, this), "/mfa/challenge");
        const {mfaToken: mfaToken} = options, challengeParams = _objectWithoutProperties(options, _excluded2);
        const body = {
            mfa_token: mfaToken,
            client_id: _classPrivateFieldGet2(_clientId, this),
            challenge_type: challengeParams.challengeType
        };
        if (challengeParams.authenticatorId) {
            body.authenticator_id = challengeParams.authenticatorId;
        }
        const response = await _classPrivateFieldGet2(_customFetch, this).call(this, url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
        });
        if (!response.ok) {
            const error = await response.json();
            throw new MfaChallengeError$1(error.error_description || "Failed to challenge authenticator", error);
        }
        const apiResponse = await response.json();
        return transformChallengeResponse(apiResponse);
    }
});

var TokenResponse = class _TokenResponse {
    constructor(accessToken, expiresAt, idToken, refreshToken, scope, claims, authorizationDetails) {
        _defineProperty(this, "accessToken", void 0);
        _defineProperty(this, "idToken", void 0);
        _defineProperty(this, "refreshToken", void 0);
        _defineProperty(this, "expiresAt", void 0);
        _defineProperty(this, "scope", void 0);
        _defineProperty(this, "claims", void 0);
        _defineProperty(this, "authorizationDetails", void 0);
        _defineProperty(this, "tokenType", void 0);
        _defineProperty(this, "issuedTokenType", void 0);
        this.accessToken = accessToken;
        this.idToken = idToken;
        this.refreshToken = refreshToken;
        this.expiresAt = expiresAt;
        this.scope = scope;
        this.claims = claims;
        this.authorizationDetails = authorizationDetails;
    }
    static fromTokenEndpointResponse(response) {
        const claims = response.id_token ? response.claims() : void 0;
        const tokenResponse = new _TokenResponse(response.access_token, Math.floor(Date.now() / 1e3) + Number(response.expires_in), response.id_token, response.refresh_token, response.scope, claims, response.authorization_details);
        tokenResponse.tokenType = response.token_type;
        tokenResponse.issuedTokenType = response.issued_token_type;
        return tokenResponse;
    }
};

var DEFAULT_SCOPES = "openid profile email offline_access";

var MAX_ARRAY_VALUES_PER_KEY = 20;

var PARAM_DENYLIST = Object.freeze(new Set([ "grant_type", "client_id", "client_secret", "client_assertion", "client_assertion_type", "subject_token", "subject_token_type", "requested_token_type", "actor_token", "actor_token_type", "audience", "aud", "resource", "resources", "resource_indicator", "scope", "connection", "login_hint", "organization", "assertion" ]));

function validateSubjectToken(token) {
    if (token == null) {
        throw new TokenExchangeError("subject_token is required");
    }
    if (typeof token !== "string") {
        throw new TokenExchangeError("subject_token must be a string");
    }
    if (token.trim().length === 0) {
        throw new TokenExchangeError("subject_token cannot be blank or whitespace");
    }
    if (token !== token.trim()) {
        throw new TokenExchangeError("subject_token must not include leading or trailing whitespace");
    }
    if (/^bearer\s+/i.test(token)) {
        throw new TokenExchangeError("subject_token must not include the 'Bearer ' prefix");
    }
}

function appendExtraParams(params, extra) {
    if (!extra) return;
    for (const [parameterKey, parameterValue] of Object.entries(extra)) {
        if (PARAM_DENYLIST.has(parameterKey)) continue;
        if (Array.isArray(parameterValue)) {
            if (parameterValue.length > MAX_ARRAY_VALUES_PER_KEY) {
                throw new TokenExchangeError("Parameter '".concat(parameterKey, "' exceeds maximum array size of ").concat(MAX_ARRAY_VALUES_PER_KEY));
            }
            parameterValue.forEach((arrayItem => {
                params.append(parameterKey, arrayItem);
            }));
        } else {
            params.append(parameterKey, parameterValue);
        }
    }
}

var GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token";

var TOKEN_EXCHANGE_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";

var SUBJECT_TYPE_REFRESH_TOKEN = "urn:ietf:params:oauth:token-type:refresh_token";

var SUBJECT_TYPE_ACCESS_TOKEN = "urn:ietf:params:oauth:token-type:access_token";

var REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN = "http://auth0.com/oauth/token-type/federated-connection-access-token";

var AuthClient = (_configuration = new WeakMap, _serverMetadata = new WeakMap, _options = new WeakMap, 
_jwks = new WeakMap, _Class8_brand = new WeakSet, class AuthClient {
    constructor(_options2) {
        _classPrivateMethodInitSpec(this, _Class8_brand);
        _classPrivateFieldInitSpec(this, _configuration, void 0);
        _classPrivateFieldInitSpec(this, _serverMetadata, void 0);
        _classPrivateFieldInitSpec(this, _options, void 0);
        _classPrivateFieldInitSpec(this, _jwks, void 0);
        _defineProperty(this, "mfa", void 0);
        _classPrivateFieldSet2(_options, this, _options2);
        if (_options2.useMtls && !_options2.customFetch) {
            throw new NotSupportedError("mtls_without_custom_fetch_not_supported", "Using mTLS without a custom fetch implementation is not supported");
        }
        this.mfa = new MfaClient({
            domain: _classPrivateFieldGet2(_options, this).domain,
            clientId: _classPrivateFieldGet2(_options, this).clientId,
            customFetch: _classPrivateFieldGet2(_options, this).customFetch
        });
    }
    async buildAuthorizationUrl(options) {
        const {serverMetadata: serverMetadata} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        if (options !== null && options !== void 0 && options.pushedAuthorizationRequests && !serverMetadata.pushed_authorization_request_endpoint) {
            throw new NotSupportedError("par_not_supported_error", "The Auth0 tenant does not have pushed authorization requests enabled. Learn how to enable it here: https://auth0.com/docs/get-started/applications/configure-par");
        }
        try {
            return await _assertClassBrand(_Class8_brand, this, _buildAuthorizationUrl).call(this, options);
        } catch (e) {
            throw new BuildAuthorizationUrlError(e);
        }
    }
    async buildLinkUserUrl(options) {
        try {
            const result = await _assertClassBrand(_Class8_brand, this, _buildAuthorizationUrl).call(this, {
                authorizationParams: _objectSpread2(_objectSpread2({}, options.authorizationParams), {}, {
                    requested_connection: options.connection,
                    requested_connection_scope: options.connectionScope,
                    scope: "openid link_account offline_access",
                    id_token_hint: options.idToken
                })
            });
            return {
                linkUserUrl: result.authorizationUrl,
                codeVerifier: result.codeVerifier
            };
        } catch (e) {
            throw new BuildLinkUserUrlError(e);
        }
    }
    async buildUnlinkUserUrl(options) {
        try {
            const result = await _assertClassBrand(_Class8_brand, this, _buildAuthorizationUrl).call(this, {
                authorizationParams: _objectSpread2(_objectSpread2({}, options.authorizationParams), {}, {
                    requested_connection: options.connection,
                    scope: "openid unlink_account",
                    id_token_hint: options.idToken
                })
            });
            return {
                unlinkUserUrl: result.authorizationUrl,
                codeVerifier: result.codeVerifier
            };
        } catch (e) {
            throw new BuildUnlinkUserUrlError(e);
        }
    }
    async backchannelAuthentication(options) {
        const {configuration: configuration, serverMetadata: serverMetadata} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        const additionalParams = stripUndefinedProperties(_objectSpread2(_objectSpread2({}, _classPrivateFieldGet2(_options, this).authorizationParams), options === null || options === void 0 ? void 0 : options.authorizationParams));
        const params = new URLSearchParams(_objectSpread2(_objectSpread2({
            scope: DEFAULT_SCOPES
        }, additionalParams), {}, {
            client_id: _classPrivateFieldGet2(_options, this).clientId,
            binding_message: options.bindingMessage,
            login_hint: JSON.stringify({
                format: "iss_sub",
                iss: serverMetadata.issuer,
                sub: options.loginHint.sub
            })
        }));
        if (options.requestedExpiry) {
            params.append("requested_expiry", options.requestedExpiry.toString());
        }
        if (options.authorizationDetails) {
            params.append("authorization_details", JSON.stringify(options.authorizationDetails));
        }
        try {
            const backchannelAuthenticationResponse = await initiateBackchannelAuthentication(configuration, params);
            const tokenEndpointResponse = await pollBackchannelAuthenticationGrant(configuration, backchannelAuthenticationResponse);
            return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
        } catch (e) {
            throw new BackchannelAuthenticationError(e);
        }
    }
    async initiateBackchannelAuthentication(options) {
        const {configuration: configuration, serverMetadata: serverMetadata} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        const additionalParams = stripUndefinedProperties(_objectSpread2(_objectSpread2({}, _classPrivateFieldGet2(_options, this).authorizationParams), options === null || options === void 0 ? void 0 : options.authorizationParams));
        const params = new URLSearchParams(_objectSpread2(_objectSpread2({
            scope: DEFAULT_SCOPES
        }, additionalParams), {}, {
            client_id: _classPrivateFieldGet2(_options, this).clientId,
            binding_message: options.bindingMessage,
            login_hint: JSON.stringify({
                format: "iss_sub",
                iss: serverMetadata.issuer,
                sub: options.loginHint.sub
            })
        }));
        if (options.requestedExpiry) {
            params.append("requested_expiry", options.requestedExpiry.toString());
        }
        if (options.authorizationDetails) {
            params.append("authorization_details", JSON.stringify(options.authorizationDetails));
        }
        try {
            const backchannelAuthenticationResponse = await initiateBackchannelAuthentication(configuration, params);
            return {
                authReqId: backchannelAuthenticationResponse.auth_req_id,
                expiresIn: backchannelAuthenticationResponse.expires_in,
                interval: backchannelAuthenticationResponse.interval
            };
        } catch (e) {
            throw new BackchannelAuthenticationError(e);
        }
    }
    async backchannelAuthenticationGrant(_ref2) {
        let {authReqId: authReqId} = _ref2;
        const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        const params = new URLSearchParams({
            auth_req_id: authReqId
        });
        try {
            const tokenEndpointResponse = await genericGrantRequest(configuration, "urn:openid:params:grant-type:ciba", params);
            return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
        } catch (e) {
            throw new BackchannelAuthenticationError(e);
        }
    }
    async getTokenForConnection(options) {
        var _options$accessToken;
        if (options.refreshToken && options.accessToken) {
            throw new TokenForConnectionError("Either a refresh or access token should be specified, but not both.");
        }
        const subjectTokenValue = (_options$accessToken = options.accessToken) !== null && _options$accessToken !== void 0 ? _options$accessToken : options.refreshToken;
        if (!subjectTokenValue) {
            throw new TokenForConnectionError("Either a refresh or access token must be specified.");
        }
        try {
            return await this.exchangeToken({
                connection: options.connection,
                subjectToken: subjectTokenValue,
                subjectTokenType: options.accessToken ? SUBJECT_TYPE_ACCESS_TOKEN : SUBJECT_TYPE_REFRESH_TOKEN,
                loginHint: options.loginHint
            });
        } catch (e) {
            if (e instanceof TokenExchangeError) {
                throw new TokenForConnectionError(e.message, e.cause);
            }
            throw e;
        }
    }
    async exchangeToken(options) {
        return "connection" in options ? _assertClassBrand(_Class8_brand, this, _exchangeTokenVaultToken).call(this, options) : _assertClassBrand(_Class8_brand, this, _exchangeProfileToken).call(this, options);
    }
    async getTokenByCode(url, options) {
        const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        try {
            const tokenEndpointResponse = await authorizationCodeGrant(configuration, url, {
                pkceCodeVerifier: options.codeVerifier
            });
            return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
        } catch (e) {
            throw new TokenByCodeError("There was an error while trying to request a token.", e);
        }
    }
    async getTokenByRefreshToken(options) {
        const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        try {
            const tokenEndpointResponse = await refreshTokenGrant(configuration, options.refreshToken);
            return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
        } catch (e) {
            throw new TokenByRefreshTokenError("The access token has expired and there was an error while trying to refresh it.", e);
        }
    }
    async getTokenByClientCredentials(options) {
        const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        try {
            const params = new URLSearchParams({
                audience: options.audience
            });
            if (options.organization) {
                params.append("organization", options.organization);
            }
            const tokenEndpointResponse = await clientCredentialsGrant(configuration, params);
            return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
        } catch (e) {
            throw new TokenByClientCredentialsError("There was an error while trying to request a token.", e);
        }
    }
    async buildLogoutUrl(options) {
        const {configuration: configuration, serverMetadata: serverMetadata} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        if (!serverMetadata.end_session_endpoint) {
            const url = new URL("https://".concat(_classPrivateFieldGet2(_options, this).domain, "/v2/logout"));
            url.searchParams.set("returnTo", options.returnTo);
            url.searchParams.set("client_id", _classPrivateFieldGet2(_options, this).clientId);
            return url;
        }
        return buildEndSessionUrl(configuration, {
            post_logout_redirect_uri: options.returnTo
        });
    }
    async verifyLogoutToken(options) {
        const {serverMetadata: serverMetadata} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
        _classPrivateFieldGet2(_jwks, this) || _classPrivateFieldSet2(_jwks, this, createRemoteJWKSet(new URL(serverMetadata.jwks_uri), {
            [customFetch]: _classPrivateFieldGet2(_options, this).customFetch
        }));
        const {payload: payload} = await jwtVerify(options.logoutToken, _classPrivateFieldGet2(_jwks, this), {
            issuer: serverMetadata.issuer,
            audience: _classPrivateFieldGet2(_options, this).clientId,
            algorithms: [ "RS256" ],
            requiredClaims: [ "iat" ]
        });
        if (!("sid" in payload) && !("sub" in payload)) {
            throw new VerifyLogoutTokenError('either "sid" or "sub" (or both) claims must be present');
        }
        if ("sid" in payload && typeof payload.sid !== "string") {
            throw new VerifyLogoutTokenError('"sid" claim must be a string');
        }
        if ("sub" in payload && typeof payload.sub !== "string") {
            throw new VerifyLogoutTokenError('"sub" claim must be a string');
        }
        if ("nonce" in payload) {
            throw new VerifyLogoutTokenError('"nonce" claim is prohibited');
        }
        if (!("events" in payload)) {
            throw new VerifyLogoutTokenError('"events" claim is missing');
        }
        if (typeof payload.events !== "object" || payload.events === null) {
            throw new VerifyLogoutTokenError('"events" claim must be an object');
        }
        if (!("http://schemas.openid.net/event/backchannel-logout" in payload.events)) {
            throw new VerifyLogoutTokenError('"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim');
        }
        if (typeof payload.events["http://schemas.openid.net/event/backchannel-logout"] !== "object") {
            throw new VerifyLogoutTokenError('"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object');
        }
        return {
            sid: payload.sid,
            sub: payload.sub
        };
    }
});

async function _discover() {
    if (_classPrivateFieldGet2(_configuration, this) && _classPrivateFieldGet2(_serverMetadata, this)) {
        return {
            configuration: _classPrivateFieldGet2(_configuration, this),
            serverMetadata: _classPrivateFieldGet2(_serverMetadata, this)
        };
    }
    const clientAuth = await _assertClassBrand(_Class8_brand, this, _getClientAuth).call(this);
    _classPrivateFieldSet2(_configuration, this, await discovery(new URL("https://".concat(_classPrivateFieldGet2(_options, this).domain)), _classPrivateFieldGet2(_options, this).clientId, {
        use_mtls_endpoint_aliases: _classPrivateFieldGet2(_options, this).useMtls
    }, clientAuth, {
        [customFetch$1]: _classPrivateFieldGet2(_options, this).customFetch
    }));
    _classPrivateFieldSet2(_serverMetadata, this, _classPrivateFieldGet2(_configuration, this).serverMetadata());
    _classPrivateFieldGet2(_configuration, this)[customFetch$1] = _classPrivateFieldGet2(_options, this).customFetch || fetch;
    return {
        configuration: _classPrivateFieldGet2(_configuration, this),
        serverMetadata: _classPrivateFieldGet2(_serverMetadata, this)
    };
}

async function _exchangeTokenVaultToken(options) {
    var _options$subjectToken, _options$requestedTok;
    const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
    if ("audience" in options || "resource" in options) {
        throw new TokenExchangeError("audience and resource parameters are not supported for Token Vault exchanges");
    }
    validateSubjectToken(options.subjectToken);
    const tokenRequestParams = new URLSearchParams({
        connection: options.connection,
        subject_token: options.subjectToken,
        subject_token_type: (_options$subjectToken = options.subjectTokenType) !== null && _options$subjectToken !== void 0 ? _options$subjectToken : SUBJECT_TYPE_ACCESS_TOKEN,
        requested_token_type: (_options$requestedTok = options.requestedTokenType) !== null && _options$requestedTok !== void 0 ? _options$requestedTok : REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN
    });
    if (options.loginHint) {
        tokenRequestParams.append("login_hint", options.loginHint);
    }
    if (options.scope) {
        tokenRequestParams.append("scope", options.scope);
    }
    appendExtraParams(tokenRequestParams, options.extra);
    try {
        const tokenEndpointResponse = await genericGrantRequest(configuration, GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN, tokenRequestParams);
        return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
    } catch (e) {
        throw new TokenExchangeError("Failed to exchange token for connection '".concat(options.connection, "'."), e);
    }
}

async function _exchangeProfileToken(options) {
    const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
    validateSubjectToken(options.subjectToken);
    const tokenRequestParams = new URLSearchParams({
        subject_token_type: options.subjectTokenType,
        subject_token: options.subjectToken
    });
    if (options.audience) {
        tokenRequestParams.append("audience", options.audience);
    }
    if (options.scope) {
        tokenRequestParams.append("scope", options.scope);
    }
    if (options.requestedTokenType) {
        tokenRequestParams.append("requested_token_type", options.requestedTokenType);
    }
    if (options.organization) {
        tokenRequestParams.append("organization", options.organization);
    }
    appendExtraParams(tokenRequestParams, options.extra);
    try {
        const tokenEndpointResponse = await genericGrantRequest(configuration, TOKEN_EXCHANGE_GRANT_TYPE, tokenRequestParams);
        return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);
    } catch (e) {
        throw new TokenExchangeError("Failed to exchange token of type '".concat(options.subjectTokenType, "'").concat(options.audience ? " for audience '".concat(options.audience, "'") : "", "."), e);
    }
}

async function _getClientAuth() {
    if (!_classPrivateFieldGet2(_options, this).clientSecret && !_classPrivateFieldGet2(_options, this).clientAssertionSigningKey && !_classPrivateFieldGet2(_options, this).useMtls) {
        throw new MissingClientAuthError;
    }
    if (_classPrivateFieldGet2(_options, this).useMtls) {
        return TlsClientAuth();
    }
    let clientPrivateKey = _classPrivateFieldGet2(_options, this).clientAssertionSigningKey;
    if (clientPrivateKey && !(clientPrivateKey instanceof CryptoKey)) {
        clientPrivateKey = await importPKCS8(clientPrivateKey, _classPrivateFieldGet2(_options, this).clientAssertionSigningAlg || "RS256");
    }
    return clientPrivateKey ? PrivateKeyJwt(clientPrivateKey) : ClientSecretPost(_classPrivateFieldGet2(_options, this).clientSecret);
}

async function _buildAuthorizationUrl(options) {
    const {configuration: configuration} = await _assertClassBrand(_Class8_brand, this, _discover).call(this);
    const codeChallengeMethod = "S256";
    const codeVerifier = randomPKCECodeVerifier();
    const codeChallenge = await calculatePKCECodeChallenge(codeVerifier);
    const additionalParams = stripUndefinedProperties(_objectSpread2(_objectSpread2({}, _classPrivateFieldGet2(_options, this).authorizationParams), options === null || options === void 0 ? void 0 : options.authorizationParams));
    const params = new URLSearchParams(_objectSpread2(_objectSpread2({
        scope: DEFAULT_SCOPES
    }, additionalParams), {}, {
        client_id: _classPrivateFieldGet2(_options, this).clientId,
        code_challenge: codeChallenge,
        code_challenge_method: codeChallengeMethod
    }));
    const authorizationUrl = options !== null && options !== void 0 && options.pushedAuthorizationRequests ? await buildAuthorizationUrlWithPAR(configuration, params) : await buildAuthorizationUrl(configuration, params);
    return {
        authorizationUrl: authorizationUrl,
        codeVerifier: codeVerifier
    };
}

class MfaError extends GenericError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaError.prototype);
    }
    static fromPayload(_ref) {
        let {error: error, error_description: error_description} = _ref;
        return new MfaError(error, error_description);
    }
}

class MfaListAuthenticatorsError extends MfaError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaListAuthenticatorsError.prototype);
    }
}

class MfaEnrollmentError extends MfaError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaEnrollmentError.prototype);
    }
}

class MfaChallengeError extends MfaError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaChallengeError.prototype);
    }
}

class MfaVerifyError extends MfaError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaVerifyError.prototype);
    }
}

class MfaEnrollmentFactorsError extends MfaError {
    constructor(error, error_description) {
        super(error, error_description);
        Object.setPrototypeOf(this, MfaEnrollmentFactorsError.prototype);
    }
}

const DEFAULT_TTL_MS = 10 * 60 * 1e3;

class MfaContextManager {
    constructor() {
        let ttlMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_TTL_MS;
        this.contexts = new Map;
        this.ttlMs = ttlMs;
    }
    set(mfaToken, context) {
        this.cleanup();
        this.contexts.set(mfaToken, Object.assign(Object.assign({}, context), {
            createdAt: Date.now()
        }));
    }
    get(mfaToken) {
        const context = this.contexts.get(mfaToken);
        if (!context) {
            return undefined;
        }
        if (Date.now() - context.createdAt > this.ttlMs) {
            this.contexts.delete(mfaToken);
            return undefined;
        }
        return context;
    }
    remove(mfaToken) {
        this.contexts.delete(mfaToken);
    }
    cleanup() {
        const now = Date.now();
        for (const [key, value] of this.contexts) {
            if (now - value.createdAt > this.ttlMs) {
                this.contexts.delete(key);
            }
        }
    }
    get size() {
        return this.contexts.size;
    }
}

class MfaApiClient {
    constructor(authJsMfaClient, auth0Client) {
        this.authJsMfaClient = authJsMfaClient;
        this.auth0Client = auth0Client;
        this.contextManager = new MfaContextManager;
    }
    setMFAAuthDetails(mfaToken, scope, audience, mfaRequirements) {
        this.contextManager.set(mfaToken, {
            scope: scope,
            audience: audience,
            mfaRequirements: mfaRequirements
        });
    }
    async getAuthenticators(mfaToken) {
        var _a, _b;
        const context = this.contextManager.get(mfaToken);
        if (!((_a = context === null || context === void 0 ? void 0 : context.mfaRequirements) === null || _a === void 0 ? void 0 : _a.challenge) || context.mfaRequirements.challenge.length === 0) {
            throw new MfaListAuthenticatorsError("invalid_request", "challengeType is required and must contain at least one challenge type, please check mfa_required error payload");
        }
        const challengeTypes = context.mfaRequirements.challenge.map((c => c.type));
        try {
            const allAuthenticators = await this.authJsMfaClient.listAuthenticators({
                mfaToken: mfaToken
            });
            return allAuthenticators.filter((auth => {
                if (!auth.type) return false;
                return challengeTypes.includes(auth.type);
            }));
        } catch (error) {
            if (error instanceof MfaListAuthenticatorsError$1) {
                throw new MfaListAuthenticatorsError((_b = error.cause) === null || _b === void 0 ? void 0 : _b.error, error.message);
            }
            throw error;
        }
    }
    async enroll(params) {
        var _a;
        const authJsParams = getAuthJsEnrollParams(params);
        try {
            return await this.authJsMfaClient.enrollAuthenticator(authJsParams);
        } catch (error) {
            if (error instanceof MfaEnrollmentError$1) {
                throw new MfaEnrollmentError((_a = error.cause) === null || _a === void 0 ? void 0 : _a.error, error.message);
            }
            throw error;
        }
    }
    async challenge(params) {
        var _a;
        try {
            const authJsParams = {
                challengeType: params.challengeType,
                mfaToken: params.mfaToken
            };
            if (params.authenticatorId) {
                authJsParams.authenticatorId = params.authenticatorId;
            }
            return await this.authJsMfaClient.challengeAuthenticator(authJsParams);
        } catch (error) {
            if (error instanceof MfaChallengeError$1) {
                throw new MfaChallengeError((_a = error.cause) === null || _a === void 0 ? void 0 : _a.error, error.message);
            }
            throw error;
        }
    }
    async getEnrollmentFactors(mfaToken) {
        const context = this.contextManager.get(mfaToken);
        if (!context || !context.mfaRequirements) {
            throw new MfaEnrollmentFactorsError("mfa_context_not_found", "MFA context not found for this MFA token. Please retry the original request to get a new MFA token.");
        }
        if (!context.mfaRequirements.enroll || context.mfaRequirements.enroll.length === 0) {
            return [];
        }
        return context.mfaRequirements.enroll;
    }
    async verify(params) {
        const context = this.contextManager.get(params.mfaToken);
        if (!context) {
            throw new MfaVerifyError("mfa_context_not_found", "MFA context not found for this MFA token. Please retry the original request to get a new MFA token.");
        }
        const grantType = getGrantType(params);
        if (!grantType) {
            throw new MfaVerifyError("invalid_request", "Unable to determine grant type. Provide one of: otp, oobCode, or recoveryCode.");
        }
        const scope = context.scope;
        const audience = context.audience;
        try {
            const result = await this.auth0Client._requestTokenForMfa({
                grant_type: grantType,
                mfaToken: params.mfaToken,
                scope: scope,
                audience: audience,
                otp: params.otp,
                oob_code: params.oobCode,
                binding_code: params.bindingCode,
                recovery_code: params.recoveryCode
            });
            this.contextManager.remove(params.mfaToken);
            return result;
        } catch (error) {
            if (error instanceof MfaRequiredError) {
                this.setMFAAuthDetails(error.mfa_token, scope, audience, error.mfa_requirements);
            } else if (error instanceof MfaVerifyError) {
                throw new MfaVerifyError(error.error, error.error_description);
            }
            throw error;
        }
    }
}

class Auth0Client {
    constructor(options) {
        this.userCache = (new InMemoryCache).enclosedCache;
        this.defaultOptions = {
            authorizationParams: {
                scope: DEFAULT_SCOPE
            },
            useRefreshTokensFallback: false,
            useFormData: true
        };
        this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), {
            authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), options.authorizationParams)
        });
        typeof window !== "undefined" && validateCrypto();
        this.lockManager = getLockManager();
        if (options.cache && options.cacheLocation) {
            console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`.");
        }
        let cacheLocation;
        let cache;
        if (options.cache) {
            cache = options.cache;
        } else {
            cacheLocation = options.cacheLocation || CACHE_LOCATION_MEMORY;
            if (!cacheFactory(cacheLocation)) {
                throw new Error('Invalid cache location "'.concat(cacheLocation, '"'));
            }
            cache = cacheFactory(cacheLocation)();
        }
        this.httpTimeoutMs = options.httpTimeoutInSeconds ? options.httpTimeoutInSeconds * 1e3 : DEFAULT_FETCH_TIMEOUT_MS;
        this.cookieStorage = options.legacySameSiteCookie === false ? CookieStorage : CookieStorageWithLegacySameSite;
        this.orgHintCookieName = buildOrganizationHintCookieName(this.options.clientId);
        this.isAuthenticatedCookieName = buildIsAuthenticatedCookieName(this.options.clientId);
        this.sessionCheckExpiryDays = options.sessionCheckExpiryDays || DEFAULT_SESSION_CHECK_EXPIRY_DAYS;
        const transactionStorage = options.useCookiesForTransactions ? this.cookieStorage : SessionStorage;
        this.scope = injectDefaultScopes(this.options.authorizationParams.scope, "openid", this.options.useRefreshTokens ? "offline_access" : "");
        this.transactionManager = new TransactionManager(transactionStorage, this.options.clientId, this.options.cookieDomain);
        this.nowProvider = this.options.nowProvider || DEFAULT_NOW_PROVIDER;
        this.cacheManager = new CacheManager(cache, !cache.allKeys ? new CacheKeyManifest(cache, this.options.clientId) : undefined, this.nowProvider);
        this.dpop = this.options.useDpop ? new Dpop(this.options.clientId) : undefined;
        this.domainUrl = getDomain(this.options.domain);
        this.tokenIssuer = getTokenIssuer(this.options.issuer, this.domainUrl);
        const myAccountApiIdentifier = "".concat(this.domainUrl, "/me/");
        const myAccountFetcher = this.createFetcher(Object.assign(Object.assign({}, this.options.useDpop && {
            dpopNonceId: "__auth0_my_account_api__"
        }), {
            getAccessToken: () => this.getTokenSilently({
                authorizationParams: {
                    scope: "create:me:connected_accounts",
                    audience: myAccountApiIdentifier
                },
                detailedResponse: true
            })
        }));
        this.myAccountApi = new MyAccountApiClient(myAccountFetcher, myAccountApiIdentifier);
        this.authJsClient = new AuthClient({
            domain: this.options.domain,
            clientId: this.options.clientId
        });
        this.mfa = new MfaApiClient(this.authJsClient.mfa, this);
        if (typeof window !== "undefined" && window.Worker && this.options.useRefreshTokens && cacheLocation === CACHE_LOCATION_MEMORY) {
            if (this.options.workerUrl) {
                this.worker = new Worker(this.options.workerUrl);
            } else {
                this.worker = new WorkerFactory;
            }
        }
    }
    getConfiguration() {
        return Object.freeze({
            domain: this.options.domain,
            clientId: this.options.clientId
        });
    }
    _url(path) {
        const auth0ClientObj = this.options.auth0Client || DEFAULT_AUTH0_CLIENT;
        const strippedAuth0Client = stripAuth0Client(auth0ClientObj, true);
        const auth0Client = encodeURIComponent(btoa(JSON.stringify(strippedAuth0Client)));
        return "".concat(this.domainUrl).concat(path, "&auth0Client=").concat(auth0Client);
    }
    _authorizeUrl(authorizeOptions) {
        return this._url("/authorize?".concat(createQueryParams(authorizeOptions)));
    }
    async _verifyIdToken(id_token, nonce, organization) {
        const now = await this.nowProvider();
        return verify$1({
            iss: this.tokenIssuer,
            aud: this.options.clientId,
            id_token: id_token,
            nonce: nonce,
            organization: organization,
            leeway: this.options.leeway,
            max_age: parseNumber(this.options.authorizationParams.max_age),
            now: now
        });
    }
    _processOrgHint(organization) {
        if (organization) {
            this.cookieStorage.save(this.orgHintCookieName, organization, {
                daysUntilExpire: this.sessionCheckExpiryDays,
                cookieDomain: this.options.cookieDomain
            });
        } else {
            this.cookieStorage.remove(this.orgHintCookieName, {
                cookieDomain: this.options.cookieDomain
            });
        }
    }
    async _prepareAuthorizeUrl(authorizationParams, authorizeOptions, fallbackRedirectUri) {
        var _a;
        const state = encode$2(createRandomString());
        const nonce = encode$2(createRandomString());
        const code_verifier = createRandomString();
        const code_challengeBuffer = await sha256(code_verifier);
        const code_challenge = bufferToBase64UrlEncoded(code_challengeBuffer);
        const thumbprint = await ((_a = this.dpop) === null || _a === void 0 ? void 0 : _a.calculateThumbprint());
        const params = getAuthorizeParams(this.options, this.scope, authorizationParams, state, nonce, code_challenge, authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || fallbackRedirectUri, authorizeOptions === null || authorizeOptions === void 0 ? void 0 : authorizeOptions.response_mode, thumbprint);
        const url = this._authorizeUrl(params);
        return {
            nonce: nonce,
            code_verifier: code_verifier,
            scope: params.scope,
            audience: params.audience || DEFAULT_AUDIENCE,
            redirect_uri: params.redirect_uri,
            state: state,
            url: url
        };
    }
    async loginWithPopup(options, config) {
        var _a;
        options = options || {};
        config = config || {};
        if (!config.popup) {
            config.popup = openPopup("");
            if (!config.popup) {
                throw new PopupOpenError;
            }
        }
        const params = await this._prepareAuthorizeUrl(options.authorizationParams || {}, {
            response_mode: "web_message"
        }, window.location.origin);
        config.popup.location.href = params.url;
        const codeResult = await runPopup(Object.assign(Object.assign({}, config), {
            timeoutInSeconds: config.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS
        }));
        if (params.state !== codeResult.state) {
            throw new GenericError("state_mismatch", "Invalid state");
        }
        const organization = ((_a = options.authorizationParams) === null || _a === void 0 ? void 0 : _a.organization) || this.options.authorizationParams.organization;
        await this._requestToken({
            audience: params.audience,
            scope: params.scope,
            code_verifier: params.code_verifier,
            grant_type: "authorization_code",
            code: codeResult.code,
            redirect_uri: params.redirect_uri
        }, {
            nonceIn: params.nonce,
            organization: organization
        });
    }
    async getUser() {
        var _a;
        const cache = await this._getIdTokenFromCache();
        return (_a = cache === null || cache === void 0 ? void 0 : cache.decodedToken) === null || _a === void 0 ? void 0 : _a.user;
    }
    async getIdTokenClaims() {
        var _a;
        const cache = await this._getIdTokenFromCache();
        return (_a = cache === null || cache === void 0 ? void 0 : cache.decodedToken) === null || _a === void 0 ? void 0 : _a.claims;
    }
    async loginWithRedirect() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        const _b = patchOpenUrlWithOnRedirect(options), {openUrl: openUrl, fragment: fragment, appState: appState} = _b, urlOptions = __rest(_b, [ "openUrl", "fragment", "appState" ]);
        const organization = ((_a = urlOptions.authorizationParams) === null || _a === void 0 ? void 0 : _a.organization) || this.options.authorizationParams.organization;
        const _c = await this._prepareAuthorizeUrl(urlOptions.authorizationParams || {}), {url: url} = _c, transaction = __rest(_c, [ "url" ]);
        this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, transaction), {
            appState: appState,
            response_type: exports.ResponseType.Code
        }), organization && {
            organization: organization
        }));
        const urlWithFragment = fragment ? "".concat(url, "#").concat(fragment) : url;
        if (openUrl) {
            await openUrl(urlWithFragment);
        } else {
            window.location.assign(urlWithFragment);
        }
    }
    async handleRedirectCallback() {
        let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;
        const queryStringFragments = url.split("?").slice(1);
        if (queryStringFragments.length === 0) {
            throw new Error("There are no query params available for parsing.");
        }
        const transaction = this.transactionManager.get();
        if (!transaction) {
            throw new GenericError("missing_transaction", "Invalid state");
        }
        this.transactionManager.remove();
        const authenticationResult = parseAuthenticationResult(queryStringFragments.join(""));
        if (transaction.response_type === exports.ResponseType.ConnectCode) {
            return this._handleConnectAccountRedirectCallback(authenticationResult, transaction);
        }
        return this._handleLoginRedirectCallback(authenticationResult, transaction);
    }
    async _handleLoginRedirectCallback(authenticationResult, transaction) {
        const {code: code, state: state, error: error, error_description: error_description} = authenticationResult;
        if (error) {
            throw new AuthenticationError(error, error_description || error, state, transaction.appState);
        }
        if (!transaction.code_verifier || transaction.state && transaction.state !== state) {
            throw new GenericError("state_mismatch", "Invalid state");
        }
        const organization = transaction.organization;
        const nonceIn = transaction.nonce;
        const redirect_uri = transaction.redirect_uri;
        await this._requestToken(Object.assign({
            audience: transaction.audience,
            scope: transaction.scope,
            code_verifier: transaction.code_verifier,
            grant_type: "authorization_code",
            code: code
        }, redirect_uri ? {
            redirect_uri: redirect_uri
        } : {}), {
            nonceIn: nonceIn,
            organization: organization
        });
        return {
            appState: transaction.appState,
            response_type: exports.ResponseType.Code
        };
    }
    async _handleConnectAccountRedirectCallback(connectResult, transaction) {
        const {connect_code: connect_code, state: state, error: error, error_description: error_description} = connectResult;
        if (error) {
            throw new ConnectError(error, error_description || error, transaction.connection, state, transaction.appState);
        }
        if (!connect_code) {
            throw new GenericError("missing_connect_code", "Missing connect code");
        }
        if (!transaction.code_verifier || !transaction.state || !transaction.auth_session || !transaction.redirect_uri || transaction.state !== state) {
            throw new GenericError("state_mismatch", "Invalid state");
        }
        const data = await this.myAccountApi.completeAccount({
            auth_session: transaction.auth_session,
            connect_code: connect_code,
            redirect_uri: transaction.redirect_uri,
            code_verifier: transaction.code_verifier
        });
        return Object.assign(Object.assign({}, data), {
            appState: transaction.appState,
            response_type: exports.ResponseType.ConnectCode
        });
    }
    async checkSession(options) {
        if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
            if (!this.cookieStorage.get(OLD_IS_AUTHENTICATED_COOKIE_NAME)) {
                return;
            } else {
                this.cookieStorage.save(this.isAuthenticatedCookieName, true, {
                    daysUntilExpire: this.sessionCheckExpiryDays,
                    cookieDomain: this.options.cookieDomain
                });
                this.cookieStorage.remove(OLD_IS_AUTHENTICATED_COOKIE_NAME);
            }
        }
        try {
            await this.getTokenSilently(options);
        } catch (_) {}
    }
    async getTokenSilently() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a, _b;
        const localOptions = Object.assign(Object.assign({
            cacheMode: "on"
        }, options), {
            authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), options.authorizationParams), {
                scope: scopesToRequest(this.scope, (_a = options.authorizationParams) === null || _a === void 0 ? void 0 : _a.scope, ((_b = options.authorizationParams) === null || _b === void 0 ? void 0 : _b.audience) || this.options.authorizationParams.audience)
            })
        });
        const result = await singlePromise((() => this._getTokenSilently(localOptions)), "".concat(this.options.clientId, "::").concat(localOptions.authorizationParams.audience, "::").concat(localOptions.authorizationParams.scope));
        return options.detailedResponse ? result : result === null || result === void 0 ? void 0 : result.access_token;
    }
    async _getTokenSilently(options) {
        const {cacheMode: cacheMode} = options, getTokenOptions = __rest(options, [ "cacheMode" ]);
        if (cacheMode !== "off") {
            const entry = await this._getEntryFromCache({
                scope: getTokenOptions.authorizationParams.scope,
                audience: getTokenOptions.authorizationParams.audience || DEFAULT_AUDIENCE,
                clientId: this.options.clientId,
                cacheMode: cacheMode
            });
            if (entry) {
                return entry;
            }
        }
        if (cacheMode === "cache-only") {
            return;
        }
        const lockKey = buildGetTokenSilentlyLockKey(this.options.clientId, getTokenOptions.authorizationParams.audience || "default");
        try {
            return await this.lockManager.runWithLock(lockKey, 5e3, (async () => {
                if (cacheMode !== "off") {
                    const entry = await this._getEntryFromCache({
                        scope: getTokenOptions.authorizationParams.scope,
                        audience: getTokenOptions.authorizationParams.audience || DEFAULT_AUDIENCE,
                        clientId: this.options.clientId
                    });
                    if (entry) {
                        return entry;
                    }
                }
                const authResult = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(getTokenOptions) : await this._getTokenFromIFrame(getTokenOptions);
                const {id_token: id_token, token_type: token_type, access_token: access_token, oauthTokenScope: oauthTokenScope, expires_in: expires_in} = authResult;
                return Object.assign(Object.assign({
                    id_token: id_token,
                    token_type: token_type,
                    access_token: access_token
                }, oauthTokenScope ? {
                    scope: oauthTokenScope
                } : null), {
                    expires_in: expires_in
                });
            }));
        } catch (error) {
            if (this._isInteractiveError(error) && this.options.interactiveErrorHandler === "popup") {
                return await this._handleInteractiveErrorWithPopup(getTokenOptions);
            }
            throw error;
        }
    }
    _isInteractiveError(error) {
        return error instanceof MfaRequiredError || error instanceof GenericError && this._isIframeMfaError(error);
    }
    _isIframeMfaError(error) {
        return error.error === "login_required" && error.error_description === MFA_STEP_UP_ERROR_DESCRIPTION;
    }
    async _handleInteractiveErrorWithPopup(options) {
        try {
            await this.loginWithPopup({
                authorizationParams: options.authorizationParams
            });
            const entry = await this._getEntryFromCache({
                scope: options.authorizationParams.scope,
                audience: options.authorizationParams.audience || DEFAULT_AUDIENCE,
                clientId: this.options.clientId
            });
            if (!entry) {
                throw new GenericError("interactive_handler_cache_miss", "Token not found in cache after interactive authentication");
            }
            return entry;
        } catch (error) {
            throw error;
        }
    }
    async getTokenWithPopup() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _a, _b;
        const localOptions = Object.assign(Object.assign({}, options), {
            authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), options.authorizationParams), {
                scope: scopesToRequest(this.scope, (_a = options.authorizationParams) === null || _a === void 0 ? void 0 : _a.scope, ((_b = options.authorizationParams) === null || _b === void 0 ? void 0 : _b.audience) || this.options.authorizationParams.audience)
            })
        });
        config = Object.assign(Object.assign({}, DEFAULT_POPUP_CONFIG_OPTIONS), config);
        await this.loginWithPopup(localOptions, config);
        const cache = await this.cacheManager.get(new CacheKey({
            scope: localOptions.authorizationParams.scope,
            audience: localOptions.authorizationParams.audience || DEFAULT_AUDIENCE,
            clientId: this.options.clientId
        }), undefined, this.options.useMrrt);
        return cache.access_token;
    }
    async isAuthenticated() {
        const user = await this.getUser();
        return !!user;
    }
    _buildLogoutUrl(options) {
        if (options.clientId !== null) {
            options.clientId = options.clientId || this.options.clientId;
        } else {
            delete options.clientId;
        }
        const _a = options.logoutParams || {}, {federated: federated} = _a, logoutOptions = __rest(_a, [ "federated" ]);
        const federatedQuery = federated ? "&federated" : "";
        const url = this._url("/v2/logout?".concat(createQueryParams(Object.assign({
            clientId: options.clientId
        }, logoutOptions))));
        return url + federatedQuery;
    }
    async logout() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        const _b = patchOpenUrlWithOnRedirect(options), {openUrl: openUrl} = _b, logoutOptions = __rest(_b, [ "openUrl" ]);
        if (options.clientId === null) {
            await this.cacheManager.clear();
        } else {
            await this.cacheManager.clear(options.clientId || this.options.clientId);
        }
        this.cookieStorage.remove(this.orgHintCookieName, {
            cookieDomain: this.options.cookieDomain
        });
        this.cookieStorage.remove(this.isAuthenticatedCookieName, {
            cookieDomain: this.options.cookieDomain
        });
        this.userCache.remove(CACHE_KEY_ID_TOKEN_SUFFIX);
        await ((_a = this.dpop) === null || _a === void 0 ? void 0 : _a.clear());
        const url = this._buildLogoutUrl(logoutOptions);
        if (openUrl) {
            await openUrl(url);
        } else if (openUrl !== false) {
            window.location.assign(url);
        }
    }
    async _getTokenFromIFrame(options) {
        const iframeLockKey = buildIframeLockKey(this.options.clientId);
        try {
            return await this.lockManager.runWithLock(iframeLockKey, 5e3, (async () => {
                const params = Object.assign(Object.assign({}, options.authorizationParams), {
                    prompt: "none"
                });
                const orgHint = this.cookieStorage.get(this.orgHintCookieName);
                if (orgHint && !params.organization) {
                    params.organization = orgHint;
                }
                const {url: url, state: stateIn, nonce: nonceIn, code_verifier: code_verifier, redirect_uri: redirect_uri, scope: scope, audience: audience} = await this._prepareAuthorizeUrl(params, {
                    response_mode: "web_message"
                }, window.location.origin);
                if (window.crossOriginIsolated) {
                    throw new GenericError("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
                }
                const authorizeTimeout = options.timeoutInSeconds || this.options.authorizeTimeoutInSeconds;
                let eventOrigin;
                try {
                    eventOrigin = new URL(this.domainUrl).origin;
                } catch (_a) {
                    eventOrigin = this.domainUrl;
                }
                const codeResult = await runIframe(url, eventOrigin, authorizeTimeout);
                if (stateIn !== codeResult.state) {
                    throw new GenericError("state_mismatch", "Invalid state");
                }
                const tokenResult = await this._requestToken(Object.assign(Object.assign({}, options.authorizationParams), {
                    code_verifier: code_verifier,
                    code: codeResult.code,
                    grant_type: "authorization_code",
                    redirect_uri: redirect_uri,
                    timeout: options.authorizationParams.timeout || this.httpTimeoutMs
                }), {
                    nonceIn: nonceIn,
                    organization: params.organization
                });
                return Object.assign(Object.assign({}, tokenResult), {
                    scope: scope,
                    oauthTokenScope: tokenResult.scope,
                    audience: audience
                });
            }));
        } catch (e) {
            if (e.error === "login_required") {
                const shouldSkipLogoutForMfaStepUp = e instanceof GenericError && this._isIframeMfaError(e) && this.options.interactiveErrorHandler === "popup";
                if (!shouldSkipLogoutForMfaStepUp) {
                    this.logout({
                        openUrl: false
                    });
                }
            }
            throw e;
        }
    }
    async _getTokenUsingRefreshToken(options) {
        var _a, _b;
        const cache = await this.cacheManager.get(new CacheKey({
            scope: options.authorizationParams.scope,
            audience: options.authorizationParams.audience || DEFAULT_AUDIENCE,
            clientId: this.options.clientId
        }), undefined, this.options.useMrrt);
        if ((!cache || !cache.refresh_token) && !this.worker) {
            if (this.options.useRefreshTokensFallback) {
                return await this._getTokenFromIFrame(options);
            }
            throw new MissingRefreshTokenError(options.authorizationParams.audience || DEFAULT_AUDIENCE, options.authorizationParams.scope);
        }
        const redirect_uri = options.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin;
        const timeout = typeof options.timeoutInSeconds === "number" ? options.timeoutInSeconds * 1e3 : null;
        const scopesToRequest = getScopeToRequest(this.options.useMrrt, options.authorizationParams, cache === null || cache === void 0 ? void 0 : cache.audience, cache === null || cache === void 0 ? void 0 : cache.scope);
        try {
            const tokenResult = await this._requestToken(Object.assign(Object.assign(Object.assign({}, options.authorizationParams), {
                grant_type: "refresh_token",
                refresh_token: cache && cache.refresh_token,
                redirect_uri: redirect_uri
            }), timeout && {
                timeout: timeout
            }), {
                scopesToRequest: scopesToRequest
            });
            if (tokenResult.refresh_token && (cache === null || cache === void 0 ? void 0 : cache.refresh_token)) {
                await this.cacheManager.updateEntry(cache.refresh_token, tokenResult.refresh_token);
            }
            if (this.options.useMrrt) {
                const isRefreshMrrt = isRefreshWithMrrt(cache === null || cache === void 0 ? void 0 : cache.audience, cache === null || cache === void 0 ? void 0 : cache.scope, options.authorizationParams.audience, options.authorizationParams.scope);
                if (isRefreshMrrt) {
                    const tokenHasAllScopes = allScopesAreIncluded(scopesToRequest, tokenResult.scope);
                    if (!tokenHasAllScopes) {
                        if (this.options.useRefreshTokensFallback) {
                            return await this._getTokenFromIFrame(options);
                        }
                        await this.cacheManager.remove(this.options.clientId, options.authorizationParams.audience, options.authorizationParams.scope);
                        const missingScopes = getMissingScopes(scopesToRequest, tokenResult.scope);
                        throw new MissingScopesError(options.authorizationParams.audience || "default", missingScopes);
                    }
                }
            }
            return Object.assign(Object.assign({}, tokenResult), {
                scope: options.authorizationParams.scope,
                oauthTokenScope: tokenResult.scope,
                audience: options.authorizationParams.audience || DEFAULT_AUDIENCE
            });
        } catch (e) {
            if (e.message) {
                if (e.message.includes(USER_BLOCKED_ERROR_MESSAGE)) {
                    await this.logout({
                        openUrl: false
                    });
                    throw e;
                }
                if ((e.message.includes(MISSING_REFRESH_TOKEN_ERROR_MESSAGE) || e.message.includes(INVALID_REFRESH_TOKEN_ERROR_MESSAGE)) && this.options.useRefreshTokensFallback) {
                    return await this._getTokenFromIFrame(options);
                }
            }
            if (e instanceof MfaRequiredError) {
                this.mfa.setMFAAuthDetails(e.mfa_token, (_a = options.authorizationParams) === null || _a === void 0 ? void 0 : _a.scope, (_b = options.authorizationParams) === null || _b === void 0 ? void 0 : _b.audience, e.mfa_requirements);
            }
            throw e;
        }
    }
    async _saveEntryInCache(entry) {
        const {id_token: id_token, decodedToken: decodedToken} = entry, entryWithoutIdToken = __rest(entry, [ "id_token", "decodedToken" ]);
        this.userCache.set(CACHE_KEY_ID_TOKEN_SUFFIX, {
            id_token: id_token,
            decodedToken: decodedToken
        });
        await this.cacheManager.setIdToken(this.options.clientId, entry.id_token, entry.decodedToken);
        await this.cacheManager.set(entryWithoutIdToken);
    }
    async _getIdTokenFromCache() {
        const audience = this.options.authorizationParams.audience || DEFAULT_AUDIENCE;
        const scope = this.scope[audience];
        const cache = await this.cacheManager.getIdToken(new CacheKey({
            clientId: this.options.clientId,
            audience: audience,
            scope: scope
        }));
        const currentCache = this.userCache.get(CACHE_KEY_ID_TOKEN_SUFFIX);
        if (cache && cache.id_token === (currentCache === null || currentCache === void 0 ? void 0 : currentCache.id_token)) {
            return currentCache;
        }
        this.userCache.set(CACHE_KEY_ID_TOKEN_SUFFIX, cache);
        return cache;
    }
    async _getEntryFromCache(_ref) {
        let {scope: scope, audience: audience, clientId: clientId, cacheMode: cacheMode} = _ref;
        const entry = await this.cacheManager.get(new CacheKey({
            scope: scope,
            audience: audience,
            clientId: clientId
        }), 60, this.options.useMrrt, cacheMode);
        if (entry && entry.access_token) {
            const {token_type: token_type, access_token: access_token, oauthTokenScope: oauthTokenScope, expires_in: expires_in} = entry;
            const cache = await this._getIdTokenFromCache();
            return cache && Object.assign(Object.assign({
                id_token: cache.id_token,
                token_type: token_type ? token_type : "Bearer",
                access_token: access_token
            }, oauthTokenScope ? {
                scope: oauthTokenScope
            } : null), {
                expires_in: expires_in
            });
        }
    }
    async _requestToken(options, additionalParameters) {
        var _a, _b;
        const {nonceIn: nonceIn, organization: organization, scopesToRequest: scopesToRequest} = additionalParameters || {};
        const authResult = await oauthToken(Object.assign(Object.assign({
            baseUrl: this.domainUrl,
            client_id: this.options.clientId,
            auth0Client: this.options.auth0Client,
            useFormData: this.options.useFormData,
            timeout: this.httpTimeoutMs,
            useMrrt: this.options.useMrrt,
            dpop: this.dpop
        }, options), {
            scope: scopesToRequest || options.scope
        }), this.worker);
        const decodedToken = await this._verifyIdToken(authResult.id_token, nonceIn, organization);
        if (options.grant_type === "authorization_code") {
            const existingIdToken = await this._getIdTokenFromCache();
            if (((_b = (_a = existingIdToken === null || existingIdToken === void 0 ? void 0 : existingIdToken.decodedToken) === null || _a === void 0 ? void 0 : _a.claims) === null || _b === void 0 ? void 0 : _b.sub) && existingIdToken.decodedToken.claims.sub !== decodedToken.claims.sub) {
                await this.cacheManager.clear(this.options.clientId);
                this.userCache.remove(CACHE_KEY_ID_TOKEN_SUFFIX);
            }
        }
        await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, authResult), {
            decodedToken: decodedToken,
            scope: options.scope,
            audience: options.audience || DEFAULT_AUDIENCE
        }), authResult.scope ? {
            oauthTokenScope: authResult.scope
        } : null), {
            client_id: this.options.clientId
        }));
        this.cookieStorage.save(this.isAuthenticatedCookieName, true, {
            daysUntilExpire: this.sessionCheckExpiryDays,
            cookieDomain: this.options.cookieDomain
        });
        this._processOrgHint(organization || decodedToken.claims.org_id);
        return Object.assign(Object.assign({}, authResult), {
            decodedToken: decodedToken
        });
    }
    async loginWithCustomTokenExchange(options) {
        return this._requestToken(Object.assign(Object.assign({}, options), {
            grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
            subject_token: options.subject_token,
            subject_token_type: options.subject_token_type,
            scope: scopesToRequest(this.scope, options.scope, options.audience || this.options.authorizationParams.audience),
            audience: options.audience || this.options.authorizationParams.audience,
            organization: options.organization || this.options.authorizationParams.organization
        }));
    }
    async exchangeToken(options) {
        return this.loginWithCustomTokenExchange(options);
    }
    _assertDpop(dpop) {
        if (!dpop) {
            throw new Error("`useDpop` option must be enabled before using DPoP.");
        }
    }
    getDpopNonce(id) {
        this._assertDpop(this.dpop);
        return this.dpop.getNonce(id);
    }
    setDpopNonce(nonce, id) {
        this._assertDpop(this.dpop);
        return this.dpop.setNonce(nonce, id);
    }
    generateDpopProof(params) {
        this._assertDpop(this.dpop);
        return this.dpop.generateProof(params);
    }
    createFetcher() {
        let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return new Fetcher(config, {
            isDpopEnabled: () => !!this.options.useDpop,
            getAccessToken: authParams => {
                var _a;
                return this.getTokenSilently({
                    authorizationParams: {
                        scope: (_a = authParams === null || authParams === void 0 ? void 0 : authParams.scope) === null || _a === void 0 ? void 0 : _a.join(" "),
                        audience: authParams === null || authParams === void 0 ? void 0 : authParams.audience
                    },
                    detailedResponse: true
                });
            },
            getDpopNonce: () => this.getDpopNonce(config.dpopNonceId),
            setDpopNonce: nonce => this.setDpopNonce(nonce, config.dpopNonceId),
            generateDpopProof: params => this.generateDpopProof(params)
        });
    }
    async connectAccountWithRedirect(options) {
        const {openUrl: openUrl, appState: appState, connection: connection, scopes: scopes, authorization_params: authorization_params, redirectUri: redirectUri = this.options.authorizationParams.redirect_uri || window.location.origin} = options;
        if (!connection) {
            throw new Error("connection is required");
        }
        const state = encode$2(createRandomString());
        const code_verifier = createRandomString();
        const code_challengeBuffer = await sha256(code_verifier);
        const code_challenge = bufferToBase64UrlEncoded(code_challengeBuffer);
        const {connect_uri: connect_uri, connect_params: connect_params, auth_session: auth_session} = await this.myAccountApi.connectAccount({
            connection: connection,
            scopes: scopes,
            redirect_uri: redirectUri,
            state: state,
            code_challenge: code_challenge,
            code_challenge_method: "S256",
            authorization_params: authorization_params
        });
        this.transactionManager.create({
            state: state,
            code_verifier: code_verifier,
            auth_session: auth_session,
            redirect_uri: redirectUri,
            appState: appState,
            connection: connection,
            response_type: exports.ResponseType.ConnectCode
        });
        const url = new URL(connect_uri);
        url.searchParams.set("ticket", connect_params.ticket);
        if (openUrl) {
            await openUrl(url.toString());
        } else {
            window.location.assign(url);
        }
    }
    async _requestTokenForMfa(options, additionalParameters) {
        const {mfaToken: mfaToken} = options, restOptions = __rest(options, [ "mfaToken" ]);
        return this._requestToken(Object.assign(Object.assign({}, restOptions), {
            mfa_token: mfaToken
        }), additionalParameters);
    }
}

async function createAuth0Client(options) {
    const auth0 = new Auth0Client(options);
    await auth0.checkSession();
    return auth0;
}

exports.Auth0Client = Auth0Client;

exports.AuthenticationError = AuthenticationError;

exports.CacheKey = CacheKey;

exports.ConnectError = ConnectError;

exports.GenericError = GenericError;

exports.InMemoryCache = InMemoryCache;

exports.LocalStorageCache = LocalStorageCache;

exports.MfaApiClient = MfaApiClient;

exports.MfaChallengeError = MfaChallengeError;

exports.MfaEnrollmentError = MfaEnrollmentError;

exports.MfaEnrollmentFactorsError = MfaEnrollmentFactorsError;

exports.MfaError = MfaError;

exports.MfaListAuthenticatorsError = MfaListAuthenticatorsError;

exports.MfaRequiredError = MfaRequiredError;

exports.MfaVerifyError = MfaVerifyError;

exports.MissingRefreshTokenError = MissingRefreshTokenError;

exports.MyAccountApiError = MyAccountApiError;

exports.PopupCancelledError = PopupCancelledError;

exports.PopupOpenError = PopupOpenError;

exports.PopupTimeoutError = PopupTimeoutError;

exports.TimeoutError = TimeoutError;

exports.UseDpopNonceError = UseDpopNonceError;

exports.User = User;

exports.createAuth0Client = createAuth0Client;
//# sourceMappingURL=auth0-spa-js.cjs.js.map
