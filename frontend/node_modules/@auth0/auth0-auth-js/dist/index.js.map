{"version":3,"sources":["../src/auth-client.ts","../src/errors.ts","../src/utils.ts","../src/mfa/errors.ts","../src/mfa/utils.ts","../src/mfa/mfa-client.ts","../src/types.ts"],"sourcesContent":["import * as client from 'openid-client';\nimport { createRemoteJWKSet, importPKCS8, jwtVerify, customFetch } from 'jose';\nimport {\n  BackchannelAuthenticationError,\n  BuildAuthorizationUrlError,\n  BuildLinkUserUrlError,\n  BuildUnlinkUserUrlError,\n  TokenExchangeError,\n  MissingClientAuthError,\n  NotSupportedError,\n  NotSupportedErrorCode,\n  OAuth2Error,\n  TokenByClientCredentialsError,\n  TokenByCodeError,\n  TokenByRefreshTokenError,\n  TokenForConnectionError,\n  VerifyLogoutTokenError,\n} from './errors.js';\nimport { stripUndefinedProperties } from './utils.js';\nimport { MfaClient } from './mfa/mfa-client.js';\nimport {\n  AuthClientOptions,\n  BackchannelAuthenticationOptions,\n  BuildAuthorizationUrlOptions,\n  BuildAuthorizationUrlResult,\n  BuildLinkUserUrlOptions,\n  BuildLinkUserUrlResult,\n  BuildLogoutUrlOptions,\n  BuildUnlinkUserUrlOptions,\n  BuildUnlinkUserUrlResult,\n  ExchangeProfileOptions,\n  TokenVaultExchangeOptions,\n  TokenByClientCredentialsOptions,\n  TokenByCodeOptions,\n  TokenByRefreshTokenOptions,\n  TokenForConnectionOptions,\n  TokenResponse,\n  VerifyLogoutTokenOptions,\n  VerifyLogoutTokenResult,\n} from './types.js';\n\nconst DEFAULT_SCOPES = 'openid profile email offline_access';\n\n/**\n * Maximum number of values allowed per parameter key in extras.\n *\n * This limit prevents potential DoS attacks from maliciously large arrays and ensures\n * reasonable payload sizes. If you have a legitimate use case requiring more than 20\n * values for a single parameter, consider:\n * - Aggregating the data into a single structured value (e.g., JSON string)\n * - Splitting the request across multiple token exchanges\n * - Using a different parameter design that doesn't require arrays\n *\n * This limit is not currently configurable. If you need a higher limit, please open\n * an issue describing your use case.\n */\nconst MAX_ARRAY_VALUES_PER_KEY = 20;\n\n/**\n * OAuth parameter denylist - parameters that cannot be overridden via extras.\n *\n * These parameters are denied to prevent security issues and maintain API contract clarity:\n *\n * - grant_type: Core protocol parameter, modifying breaks OAuth flow integrity\n * - client_id, client_secret, client_assertion, client_assertion_type: Client authentication\n *   credentials must be managed through configuration, not request parameters\n * - subject_token, subject_token_type: Core token exchange parameters, overriding creates\n *   ambiguity about which token is being exchanged\n * - requested_token_type: Determines the type of token returned, must be explicit\n * - actor_token, actor_token_type: Delegation parameters that affect authorization context\n * - audience, aud, resource, resources, resource_indicator: Target API parameters must use\n *   explicit API parameters to prevent confusion about precedence and ensure correct routing\n * - scope: Overriding via extras bypasses the explicit scope parameter and creates ambiguity\n *   about which scope takes precedence, potentially granting unintended permissions\n * - connection: Determines token source for Token Vault, must be explicit\n * - login_hint: Affects user identity resolution, must be explicit\n * - organization: Affects tenant context, must be explicit\n * - assertion: SAML assertion parameter, must be managed separately\n *\n * These restrictions ensure that security-critical and routing parameters are always\n * set through explicit, typed API parameters rather than untyped extras.\n */\nconst PARAM_DENYLIST = Object.freeze(\n  new Set([\n    'grant_type',\n    'client_id',\n    'client_secret',\n    'client_assertion',\n    'client_assertion_type',\n    'subject_token',\n    'subject_token_type',\n    'requested_token_type',\n    'actor_token',\n    'actor_token_type',\n    'audience',\n    'aud',\n    'resource',\n    'resources',\n    'resource_indicator',\n    'scope',\n    'connection',\n    'login_hint',\n    'organization',\n    'assertion',\n  ])\n);\n\n/**\n * Validates subject token input to fail fast with clear error messages.\n * Detects common footguns like whitespace, Bearer prefix, and empty values.\n */\nfunction validateSubjectToken(token: string): void {\n  if (token == null) {\n    throw new TokenExchangeError('subject_token is required');\n  }\n  if (typeof token !== 'string') {\n    throw new TokenExchangeError('subject_token must be a string');\n  }\n  // Fail fast on blank or whitespace-only\n  if (token.trim().length === 0) {\n    throw new TokenExchangeError('subject_token cannot be blank or whitespace');\n  }\n  // Be explicit about surrounding spaces\n  if (token !== token.trim()) {\n    throw new TokenExchangeError(\n      'subject_token must not include leading or trailing whitespace'\n    );\n  }\n  // Very common copy paste mistake (case-insensitive check)\n  if (/^bearer\\s+/i.test(token)) {\n    throw new TokenExchangeError(\n      \"subject_token must not include the 'Bearer ' prefix\"\n    );\n  }\n}\n\n/**\n * Appends extra parameters to URLSearchParams while enforcing security constraints.\n */\nfunction appendExtraParams(\n  params: URLSearchParams,\n  extra?: Record<string, string | string[]>\n): void {\n  if (!extra) return;\n\n  for (const [parameterKey, parameterValue] of Object.entries(extra)) {\n    if (PARAM_DENYLIST.has(parameterKey)) continue;\n\n    if (Array.isArray(parameterValue)) {\n      if (parameterValue.length > MAX_ARRAY_VALUES_PER_KEY) {\n        throw new TokenExchangeError(\n          `Parameter '${parameterKey}' exceeds maximum array size of ${MAX_ARRAY_VALUES_PER_KEY}`\n        );\n      }\n      parameterValue.forEach((arrayItem) => {\n        params.append(parameterKey, arrayItem);\n      });\n    } else {\n      params.append(parameterKey, parameterValue);\n    }\n  }\n}\n\n/**\n * A constant representing the grant type for federated connection access token exchange.\n *\n * This grant type is used in OAuth token exchange scenarios where a federated connection\n * access token is required. It is specific to Auth0's implementation and follows the\n * \"urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token\" format.\n */\nconst GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN =\n  'urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token' as const;\n\n/**\n * RFC 8693 grant type for OAuth 2.0 Token Exchange.\n *\n * @see {@link https://datatracker.ietf.org/doc/html/rfc8693 RFC 8693: OAuth 2.0 Token Exchange}\n */\nconst TOKEN_EXCHANGE_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange' as const;\n\n/**\n * Constant representing the subject type for a refresh token.\n * This is used in OAuth 2.0 token exchange to specify that the token being exchanged is a refresh token.\n *\n * @see {@link https://tools.ietf.org/html/rfc8693#section-3.1 RFC 8693 Section 3.1}\n */\nconst SUBJECT_TYPE_REFRESH_TOKEN =\n  'urn:ietf:params:oauth:token-type:refresh_token';\n\n/**\n * Constant representing the subject type for an access token.\n * This is used in OAuth 2.0 token exchange to specify that the token being exchanged is an access token.\n *\n * @see {@link https://tools.ietf.org/html/rfc8693#section-3.1 RFC 8693 Section 3.1}\n */\nconst SUBJECT_TYPE_ACCESS_TOKEN =\n  'urn:ietf:params:oauth:token-type:access_token';\n\n/**\n * A constant representing the token type for federated connection access tokens.\n * This is used to specify the type of token being requested from Auth0.\n *\n * @constant\n * @type {string}\n */\nconst REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN =\n  'http://auth0.com/oauth/token-type/federated-connection-access-token';\n\n/**\n * Auth0 authentication client for handling OAuth 2.0 and OIDC flows.\n *\n * Provides methods for authorization, token exchange, token refresh, and verification\n * of tokens issued by Auth0. Supports multiple authentication methods including\n * client_secret_post, private_key_jwt, and mTLS.\n */\nexport class AuthClient {\n  #configuration: client.Configuration | undefined;\n  #serverMetadata: client.ServerMetadata | undefined;\n  readonly #options: AuthClientOptions;\n  #jwks?: ReturnType<typeof createRemoteJWKSet>;\n  public mfa: MfaClient;\n\n  constructor(options: AuthClientOptions) {\n    this.#options = options;\n\n    // When mTLS is being used, a custom fetch implementation is required.\n    if (options.useMtls && !options.customFetch) {\n      throw new NotSupportedError(\n        NotSupportedErrorCode.MTLS_WITHOUT_CUSTOMFETCH_NOT_SUPPORT,\n        'Using mTLS without a custom fetch implementation is not supported'\n      );\n    }\n    this.mfa = new MfaClient({\n      domain: this.#options.domain,\n      clientId: this.#options.clientId,\n      customFetch: this.#options.customFetch,\n    });\n  }\n\n  /**\n   * Initializes the SDK by performing Metadata Discovery.\n   *\n   * Discovers and caches the OAuth 2.0 Authorization Server metadata from the\n   * Auth0 tenant's well-known endpoint. This metadata is required for subsequent\n   * operations and is cached for the lifetime of the AuthClient instance.\n   *\n   * @private\n   * @returns Promise resolving to the cached configuration and server metadata\n   */\n  async #discover() {\n    if (this.#configuration && this.#serverMetadata) {\n      return {\n        configuration: this.#configuration,\n        serverMetadata: this.#serverMetadata,\n      };\n    }\n\n    const clientAuth = await this.#getClientAuth();\n\n    this.#configuration = await client.discovery(\n      new URL(`https://${this.#options.domain}`),\n      this.#options.clientId,\n      { use_mtls_endpoint_aliases: this.#options.useMtls },\n      clientAuth,\n      {\n        [client.customFetch]: this.#options.customFetch,     \n      }\n    );\n\n    this.#serverMetadata = this.#configuration.serverMetadata();\n    this.#configuration[client.customFetch] =\n      this.#options.customFetch || fetch;\n\n    return {\n      configuration: this.#configuration,\n      serverMetadata: this.#serverMetadata,\n    };\n  }\n\n  /**\n   * Builds the URL to redirect the user-agent to to request authorization at Auth0.\n   * @param options Options used to configure the authorization URL.\n   *\n   * @throws {BuildAuthorizationUrlError} If there was an issue when building the Authorization URL.\n   *\n   * @returns A promise resolving to an object, containing the authorizationUrl and codeVerifier.\n   */\n  async buildAuthorizationUrl(\n    options?: BuildAuthorizationUrlOptions\n  ): Promise<BuildAuthorizationUrlResult> {\n    const { serverMetadata } = await this.#discover();\n\n    if (\n      options?.pushedAuthorizationRequests &&\n      !serverMetadata.pushed_authorization_request_endpoint\n    ) {\n      throw new NotSupportedError(\n        NotSupportedErrorCode.PAR_NOT_SUPPORTED,\n        'The Auth0 tenant does not have pushed authorization requests enabled. Learn how to enable it here: https://auth0.com/docs/get-started/applications/configure-par'\n      );\n    }\n\n    try {\n      return await this.#buildAuthorizationUrl(options);\n    } catch (e) {\n      throw new BuildAuthorizationUrlError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Builds the URL to redirect the user-agent to to link a user account at Auth0.\n   * @param options Options used to configure the link user URL.\n   *\n   * @throws {BuildLinkUserUrlError} If there was an issue when building the Link User URL.\n   *\n   * @returns A promise resolving to an object, containing the linkUserUrl and codeVerifier.\n   */\n  public async buildLinkUserUrl(\n    options: BuildLinkUserUrlOptions\n  ): Promise<BuildLinkUserUrlResult> {\n    try {\n      const result = await this.#buildAuthorizationUrl({\n        authorizationParams: {\n          ...options.authorizationParams,\n          requested_connection: options.connection,\n          requested_connection_scope: options.connectionScope,\n          scope: 'openid link_account offline_access',\n          id_token_hint: options.idToken,\n        },\n      });\n\n      return {\n        linkUserUrl: result.authorizationUrl,\n        codeVerifier: result.codeVerifier,\n      };\n    } catch (e) {\n      throw new BuildLinkUserUrlError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Builds the URL to redirect the user-agent to to unlink a user account at Auth0.\n   * @param options Options used to configure the unlink user URL.\n   *\n   * @throws {BuildUnlinkUserUrlError} If there was an issue when building the Unlink User URL.\n   *\n   * @returns A promise resolving to an object, containing the unlinkUserUrl and codeVerifier.\n   */\n  public async buildUnlinkUserUrl(\n    options: BuildUnlinkUserUrlOptions\n  ): Promise<BuildUnlinkUserUrlResult> {\n    try {\n      const result = await this.#buildAuthorizationUrl({\n        authorizationParams: {\n          ...options.authorizationParams,\n          requested_connection: options.connection,\n          scope: 'openid unlink_account',\n          id_token_hint: options.idToken,\n        },\n      });\n\n      return {\n        unlinkUserUrl: result.authorizationUrl,\n        codeVerifier: result.codeVerifier,\n      };\n    } catch (e) {\n      throw new BuildUnlinkUserUrlError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Authenticates using Client-Initiated Backchannel Authentication.\n   *\n   * This method will initialize the backchannel authentication process with Auth0, and poll the token endpoint until the authentication is complete.\n   *\n   * Using Client-Initiated Backchannel Authentication requires the feature to be enabled in the Auth0 dashboard.\n   * @see https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow\n   * @param options Options used to configure the backchannel authentication process.\n   *\n   * @throws {BackchannelAuthenticationError} If there was an issue when doing backchannel authentication.\n   *\n   * @returns A Promise, resolving to the TokenResponse as returned from Auth0.\n   */\n  async backchannelAuthentication(\n    options: BackchannelAuthenticationOptions\n  ): Promise<TokenResponse> {\n    const { configuration, serverMetadata } = await this.#discover();\n\n    const additionalParams = stripUndefinedProperties({\n      ...this.#options.authorizationParams,\n      ...options?.authorizationParams,\n    });\n\n    const params = new URLSearchParams({\n      scope: DEFAULT_SCOPES,\n      ...additionalParams,\n      client_id: this.#options.clientId,\n      binding_message: options.bindingMessage,\n      login_hint: JSON.stringify({\n        format: 'iss_sub',\n        iss: serverMetadata.issuer,\n        sub: options.loginHint.sub,\n      }),\n    });\n\n    if (options.requestedExpiry) {\n      params.append('requested_expiry', options.requestedExpiry.toString());\n    }\n\n    if (options.authorizationDetails) {\n      params.append(\n        'authorization_details',\n        JSON.stringify(options.authorizationDetails)\n      );\n    }\n\n    try {\n      const backchannelAuthenticationResponse =\n        await client.initiateBackchannelAuthentication(configuration, params);\n\n      const tokenEndpointResponse =\n        await client.pollBackchannelAuthenticationGrant(\n          configuration,\n          backchannelAuthenticationResponse\n        );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new BackchannelAuthenticationError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Initiates Client-Initiated Backchannel Authentication flow by calling the `/bc-authorize` endpoint.\n   * This method only initiates the authentication request and returns the `auth_req_id` to be used in subsequent calls to `backchannelAuthenticationGrant`.\n   * \n   * Typically, you would call this method to start the authentication process, then use the returned `auth_req_id` to poll for the token using `backchannelAuthenticationGrant`.\n   * \n   * @param options Options used to configure the backchannel authentication initiation.\n   * \n   * @throws {BackchannelAuthenticationError} If there was an issue when initiating backchannel authentication.\n   * \n   * @returns An object containing `authReqId`, `expiresIn`, and `interval` for polling.\n   */\n  async initiateBackchannelAuthentication(options: BackchannelAuthenticationOptions) {\n    const { configuration, serverMetadata } = await this.#discover();\n\n    const additionalParams = stripUndefinedProperties({\n      ...this.#options.authorizationParams,\n      ...options?.authorizationParams,\n    });\n\n    const params = new URLSearchParams({\n      scope: DEFAULT_SCOPES,\n      ...additionalParams,\n      client_id: this.#options.clientId,\n      binding_message: options.bindingMessage,\n      login_hint: JSON.stringify({\n        format: 'iss_sub',\n        iss: serverMetadata.issuer,\n        sub: options.loginHint.sub,\n      }),\n    });\n\n    if (options.requestedExpiry) {\n      params.append('requested_expiry', options.requestedExpiry.toString());\n    }\n\n    if (options.authorizationDetails) {\n      params.append(\n        'authorization_details',\n        JSON.stringify(options.authorizationDetails)\n      );\n    }\n\n    try {\n      const backchannelAuthenticationResponse =\n        await client.initiateBackchannelAuthentication(configuration, params);\n\n      return {\n        authReqId: backchannelAuthenticationResponse.auth_req_id,\n        expiresIn: backchannelAuthenticationResponse.expires_in,\n        interval: backchannelAuthenticationResponse.interval,\n      };\n    } catch (e) {\n      throw new BackchannelAuthenticationError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Exchanges the `auth_req_id` obtained from `initiateBackchannelAuthentication` for tokens.\n   * \n   * @param authReqId The `auth_req_id` obtained from `initiateBackchannelAuthentication`.\n   * \n   * @throws {BackchannelAuthenticationError} If there was an issue when exchanging the `auth_req_id` for tokens.\n   * \n   * @returns A Promise, resolving to the TokenResponse as returned from Auth0.\n   */\n  async backchannelAuthenticationGrant({ authReqId }: { authReqId: string }) {\n    const { configuration } = await this.#discover();\n    const params = new URLSearchParams({\n      auth_req_id: authReqId,\n    });\n\n    try {\n      const tokenEndpointResponse = await client.genericGrantRequest(\n        configuration,\n        'urn:openid:params:grant-type:ciba',\n        params\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new BackchannelAuthenticationError(e as OAuth2Error);\n    }\n  }\n\n  /**\n   * Retrieves a token for a connection using Token Vault.\n   *\n   * @deprecated Since v1.2.0. Use {@link exchangeToken} with a Token Vault payload:\n   *   `exchangeToken({ connection, subjectToken, subjectTokenType, loginHint?, scope?, extra? })`.\n   * This method remains for backward compatibility and is planned for removal in v2.0.\n   *\n   * This is a convenience wrapper around exchangeToken() for Token Vault scenarios,\n   * providing a simpler API for the common use case of exchanging Auth0 tokens for\n   * federated access tokens.\n   *\n   * Either a refresh token or access token must be provided, but not both. The method\n   * automatically determines the correct subject_token_type based on which token is provided.\n   *\n   * @param options Options for retrieving an access token for a connection.\n   *\n   * @throws {TokenForConnectionError} If there was an issue requesting the access token,\n   *                                    or if both/neither token types are provided.\n   *\n   * @returns The access token for the connection\n   *\n   * @see {@link exchangeToken} for the unified token exchange method with more options\n   *\n   * @example Using an access token (deprecated, use exchangeToken instead)\n   * ```typescript\n   * const response = await authClient.getTokenForConnection({\n   *   connection: 'google-oauth2',\n   *   accessToken: auth0AccessToken,\n   *   loginHint: 'user@example.com'\n   * });\n   * ```\n   *\n   * @example Using a refresh token (deprecated, use exchangeToken instead)\n   * ```typescript\n   * const response = await authClient.getTokenForConnection({\n   *   connection: 'salesforce',\n   *   refreshToken: auth0RefreshToken\n   * });\n   * ```\n   */\n  public async getTokenForConnection(\n    options: TokenForConnectionOptions\n  ): Promise<TokenResponse> {\n    if (options.refreshToken && options.accessToken) {\n      throw new TokenForConnectionError(\n        'Either a refresh or access token should be specified, but not both.'\n      );\n    }\n\n    const subjectTokenValue = options.accessToken ?? options.refreshToken;\n    if (!subjectTokenValue) {\n      throw new TokenForConnectionError(\n        'Either a refresh or access token must be specified.'\n      );\n    }\n\n    try {\n      return await this.exchangeToken({\n        connection: options.connection,\n        subjectToken: subjectTokenValue,\n        subjectTokenType: options.accessToken\n          ? SUBJECT_TYPE_ACCESS_TOKEN\n          : SUBJECT_TYPE_REFRESH_TOKEN,\n        loginHint: options.loginHint,\n      } as TokenVaultExchangeOptions);\n    } catch (e) {\n      // Wrap TokenExchangeError in TokenForConnectionError for backward compatibility\n      if (e instanceof TokenExchangeError) {\n        throw new TokenForConnectionError(e.message, e.cause);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Internal implementation for Access Token Exchange with Token Vault.\n   *\n   * Exchanges an Auth0 token (access token or refresh token) for an external provider's access token\n   * from a third-party provider configured in Token Vault. The external provider's refresh token\n   * is securely stored in Auth0 and never exposed to the client.\n   *\n   * This method constructs the appropriate request for Auth0's proprietary Token Vault\n   * grant type and handles the exchange with proper validation and error handling.\n   *\n   * @private\n   * @param options Access Token Exchange with Token Vault configuration including connection and optional hints\n   * @returns Promise resolving to TokenResponse containing the external provider's access token\n   * @throws {TokenExchangeError} When validation fails, audience/resource are provided,\n   *                               or the exchange operation fails\n   */\n  async #exchangeTokenVaultToken(\n    options: TokenVaultExchangeOptions\n  ): Promise<TokenResponse> {\n    const { configuration } = await this.#discover();\n\n    if ('audience' in options || 'resource' in options) {\n      throw new TokenExchangeError(\n        'audience and resource parameters are not supported for Token Vault exchanges'\n      );\n    }\n\n    validateSubjectToken(options.subjectToken);\n\n    const tokenRequestParams = new URLSearchParams({\n      connection: options.connection,\n      subject_token: options.subjectToken,\n      subject_token_type:\n        options.subjectTokenType ?? SUBJECT_TYPE_ACCESS_TOKEN,\n      requested_token_type:\n        options.requestedTokenType ??\n        REQUESTED_TOKEN_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN,\n    });\n\n    if (options.loginHint) {\n      tokenRequestParams.append('login_hint', options.loginHint);\n    }\n    if (options.scope) {\n      tokenRequestParams.append('scope', options.scope);\n    }\n\n    appendExtraParams(tokenRequestParams, options.extra);\n\n    try {\n      const tokenEndpointResponse = await client.genericGrantRequest(\n        configuration,\n        GRANT_TYPE_FEDERATED_CONNECTION_ACCESS_TOKEN,\n        tokenRequestParams\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new TokenExchangeError(\n        `Failed to exchange token for connection '${options.connection}'.`,\n        e as OAuth2Error\n      );\n    }\n  }\n\n  /**\n   * Internal implementation for Token Exchange via Token Exchange Profile (RFC 8693).\n   *\n   * Exchanges a custom token for Auth0 tokens targeting a specific API audience,\n   * preserving user identity. This enables first-party on-behalf-of flows where\n   * a custom token (e.g., from an MCP server, legacy system, or partner service)\n   * is exchanged for Auth0 tokens.\n   *\n   * Requires a Token Exchange Profile configured in Auth0 that defines the\n   * subject_token_type, validation logic, and user mapping.\n   *\n   * @private\n   * @param options Token Exchange Profile configuration including token type and target API\n   * @returns Promise resolving to TokenResponse containing Auth0 tokens\n   * @throws {TokenExchangeError} When validation fails or the exchange operation fails\n   */\n  async #exchangeProfileToken(\n    options: ExchangeProfileOptions\n  ): Promise<TokenResponse> {\n    const { configuration } = await this.#discover();\n\n    validateSubjectToken(options.subjectToken);\n\n    const tokenRequestParams = new URLSearchParams({\n      subject_token_type: options.subjectTokenType,\n      subject_token: options.subjectToken,\n    });\n\n    if (options.audience) {\n      tokenRequestParams.append('audience', options.audience);\n    }\n    if (options.scope) {\n      tokenRequestParams.append('scope', options.scope);\n    }\n    if (options.requestedTokenType) {\n      tokenRequestParams.append('requested_token_type', options.requestedTokenType);\n    }\n    if (options.organization) {\n      tokenRequestParams.append('organization', options.organization);\n    }\n\n    appendExtraParams(tokenRequestParams, options.extra);\n\n    try {\n      const tokenEndpointResponse = await client.genericGrantRequest(\n        configuration,\n        TOKEN_EXCHANGE_GRANT_TYPE,\n        tokenRequestParams\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new TokenExchangeError(\n        `Failed to exchange token of type '${options.subjectTokenType}'${options.audience ? ` for audience '${options.audience}'` : ''}.`,\n        e as OAuth2Error\n      );\n    }\n  }\n\n  /**\n   * @overload\n   * Exchanges a custom token for Auth0 tokens using RFC 8693 Token Exchange via Token Exchange Profile.\n   *\n   * This overload is used when you DON'T provide a `connection` parameter.\n   * It enables exchanging custom tokens (from MCP servers, legacy systems, or partner\n   * services) for Auth0 tokens targeting a specific API audience. Requires a Token\n   * Exchange Profile configured in Auth0.\n   *\n   * @param options Token Exchange Profile configuration (without `connection` parameter)\n   * @returns Promise resolving to TokenResponse with Auth0 tokens\n   * @throws {TokenExchangeError} When exchange fails or validation errors occur\n   * @throws {MissingClientAuthError} When client authentication is not configured\n   *\n   * @example\n   * ```typescript\n   * // Exchange custom token (organization is optional)\n   * const response = await authClient.exchangeToken({\n   *   subjectTokenType: 'urn:acme:mcp-token',\n   *   subjectToken: mcpServerToken,\n   *   audience: 'https://api.example.com',\n   *   organization: 'org_abc123', // Optional - Organization ID or name\n   *   scope: 'openid profile read:data'\n   * });\n   * // The resulting access token will include the organization ID in its payload\n   * ```\n   */\n  public exchangeToken(options: ExchangeProfileOptions): Promise<TokenResponse>;\n\n  /**\n   * @overload\n   * Exchanges an Auth0 token for an external provider's access token using Token Vault.\n   *\n   * This overload is used when you DO provide a `connection` parameter.\n   * It exchanges Auth0 tokens (access or refresh) for external provider's access tokens\n   * (Google, Facebook, etc.). The external provider's refresh token is securely stored in\n   * Auth0's Token Vault.\n   *\n   * @param options Token Vault exchange configuration (with `connection` parameter)\n   * @returns Promise resolving to TokenResponse with external provider's access token\n   * @throws {TokenExchangeError} When exchange fails or validation errors occur\n   * @throws {MissingClientAuthError} When client authentication is not configured\n   *\n   * @example\n   * ```typescript\n   * const response = await authClient.exchangeToken({\n   *   connection: 'google-oauth2',\n   *   subjectToken: auth0AccessToken,\n   *   loginHint: 'user@example.com'\n   * });\n   * ```\n   */\n  public exchangeToken(options: TokenVaultExchangeOptions): Promise<TokenResponse>;\n\n  /**\n   * Exchanges a token using either Token Exchange via Token Exchange Profile (RFC 8693) or Access Token Exchange with Token Vault.\n   *\n   * **Method routing is determined by the presence of the `connection` parameter:**\n   * - **Without `connection`**: Token Exchange via Token Exchange Profile (RFC 8693)\n   * - **With `connection`**: Access Token Exchange with Token Vault\n   *\n   * Both flows require a confidential client (client credentials must be configured).\n   *\n   * @see {@link ExchangeProfileOptions} for Token Exchange Profile parameters\n   * @see {@link TokenVaultExchangeOptions} for Token Vault parameters\n   * @see {@link https://auth0.com/docs/authenticate/custom-token-exchange Custom Token Exchange Docs}\n   * @see {@link https://auth0.com/docs/secure/tokens/token-vault Token Vault Docs}\n   *\n   * @example Token Exchange with validation context\n   * ```typescript\n   * const response = await authClient.exchangeToken({\n   *   subjectTokenType: 'urn:acme:legacy-token',\n   *   subjectToken: legacySystemToken,\n   *   audience: 'https://api.acme.com',\n   *   scope: 'openid offline_access',\n   *   extra: {\n   *     device_id: 'device-12345',\n   *     session_id: 'sess-abc',\n   *     migration_context: 'legacy-system-v1'\n   *   }\n   * });\n   * ```\n   */\n  public async exchangeToken(\n    options: ExchangeProfileOptions | TokenVaultExchangeOptions\n  ): Promise<TokenResponse> {\n    return 'connection' in options\n      ? this.#exchangeTokenVaultToken(options)\n      : this.#exchangeProfileToken(options);\n  }\n\n  /**\n   * Retrieves a token by exchanging an authorization code.\n   * @param url The URL containing the authorization code.\n   * @param options Options for exchanging the authorization code, containing the expected code verifier.\n   *\n   * @throws {TokenByCodeError} If there was an issue requesting the access token.\n   *\n   * @returns A Promise, resolving to the TokenResponse as returned from Auth0.\n   */\n  public async getTokenByCode(\n    url: URL,\n    options: TokenByCodeOptions\n  ): Promise<TokenResponse> {\n    const { configuration } = await this.#discover();\n    try {\n      const tokenEndpointResponse = await client.authorizationCodeGrant(\n        configuration,\n        url,\n        {\n          pkceCodeVerifier: options.codeVerifier,\n        }\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new TokenByCodeError(\n        'There was an error while trying to request a token.',\n        e as OAuth2Error\n      );\n    }\n  }\n\n  /**\n   * Retrieves a token by exchanging a refresh token.\n   * @param options Options for exchanging the refresh token.\n   *\n   * @throws {TokenByRefreshTokenError} If there was an issue requesting the access token.\n   *\n   * @returns A Promise, resolving to the TokenResponse as returned from Auth0.\n   */\n  public async getTokenByRefreshToken(options: TokenByRefreshTokenOptions) {\n    const { configuration } = await this.#discover();\n\n    try {\n      const tokenEndpointResponse = await client.refreshTokenGrant(\n        configuration,\n        options.refreshToken\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new TokenByRefreshTokenError(\n        'The access token has expired and there was an error while trying to refresh it.',\n        e as OAuth2Error\n      );\n    }\n  }\n\n  /**\n   * Retrieves a token by exchanging client credentials.\n   * @param options Options for retrieving the token.\n   *\n   * @throws {TokenByClientCredentialsError} If there was an issue requesting the access token.\n   *\n   * @returns A Promise, resolving to the TokenResponse as returned from Auth0.\n   */\n  public async getTokenByClientCredentials(\n    options: TokenByClientCredentialsOptions\n  ): Promise<TokenResponse> {\n    const { configuration } = await this.#discover();\n\n    try {\n      const params = new URLSearchParams({\n        audience: options.audience,\n      });\n\n      if (options.organization) {\n        params.append('organization', options.organization);\n      }\n\n      const tokenEndpointResponse = await client.clientCredentialsGrant(\n        configuration,\n        params\n      );\n\n      return TokenResponse.fromTokenEndpointResponse(tokenEndpointResponse);\n    } catch (e) {\n      throw new TokenByClientCredentialsError(\n        'There was an error while trying to request a token.',\n        e as OAuth2Error\n      );\n    }\n  }\n\n  /**\n   * Builds the URL to redirect the user-agent to to request logout at Auth0.\n   * @param options Options used to configure the logout URL.\n   * @returns A promise resolving to the URL to redirect the user-agent to.\n   */\n  public async buildLogoutUrl(options: BuildLogoutUrlOptions): Promise<URL> {\n    const { configuration, serverMetadata } = await this.#discover();\n\n    // We should not call `client.buildEndSessionUrl` when we do not have an `end_session_endpoint`\n    // In that case, we rely on the v2 logout endpoint.\n    // This can happen for tenants that do not have RP-Initiated Logout enabled.\n    if (!serverMetadata.end_session_endpoint) {\n      const url = new URL(`https://${this.#options.domain}/v2/logout`);\n      url.searchParams.set('returnTo', options.returnTo);\n      url.searchParams.set('client_id', this.#options.clientId);\n      return url;\n    }\n\n    return client.buildEndSessionUrl(configuration, {\n      post_logout_redirect_uri: options.returnTo,\n    });\n  }\n\n  /**\n   * Verifies whether a logout token is valid.\n   * @param options Options used to verify the logout token.\n   *\n   * @throws {VerifyLogoutTokenError} If there was an issue verifying the logout token.\n   *\n   * @returns An object containing the `sid` and `sub` claims from the logout token.\n   */\n  async verifyLogoutToken(\n    options: VerifyLogoutTokenOptions\n  ): Promise<VerifyLogoutTokenResult> {\n    const { serverMetadata } = await this.#discover();\n    this.#jwks ||= createRemoteJWKSet(new URL(serverMetadata!.jwks_uri!), {\n      [customFetch]: this.#options.customFetch,\n    });\n\n    const { payload } = await jwtVerify(options.logoutToken, this.#jwks, {\n      issuer: serverMetadata!.issuer,\n      audience: this.#options.clientId,\n      algorithms: ['RS256'],\n      requiredClaims: ['iat'],\n    });\n\n    if (!('sid' in payload) && !('sub' in payload)) {\n      throw new VerifyLogoutTokenError(\n        'either \"sid\" or \"sub\" (or both) claims must be present'\n      );\n    }\n\n    if ('sid' in payload && typeof payload.sid !== 'string') {\n      throw new VerifyLogoutTokenError('\"sid\" claim must be a string');\n    }\n\n    if ('sub' in payload && typeof payload.sub !== 'string') {\n      throw new VerifyLogoutTokenError('\"sub\" claim must be a string');\n    }\n\n    if ('nonce' in payload) {\n      throw new VerifyLogoutTokenError('\"nonce\" claim is prohibited');\n    }\n\n    if (!('events' in payload)) {\n      throw new VerifyLogoutTokenError('\"events\" claim is missing');\n    }\n\n    if (typeof payload.events !== 'object' || payload.events === null) {\n      throw new VerifyLogoutTokenError('\"events\" claim must be an object');\n    }\n\n    if (\n      !('http://schemas.openid.net/event/backchannel-logout' in payload.events)\n    ) {\n      throw new VerifyLogoutTokenError(\n        '\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim'\n      );\n    }\n\n    if (\n      typeof payload.events[\n        'http://schemas.openid.net/event/backchannel-logout'\n      ] !== 'object'\n    ) {\n      throw new VerifyLogoutTokenError(\n        '\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object'\n      );\n    }\n\n    return {\n      sid: payload.sid as string,\n      sub: payload.sub as string,\n    };\n  }\n\n  /**\n   * Gets the client authentication method based on the provided options.\n   *\n   * Supports three authentication methods in order of preference:\n   * 1. mTLS (mutual TLS) - requires customFetch with client certificate\n   * 2. private_key_jwt - requires clientAssertionSigningKey\n   * 3. client_secret_post - requires clientSecret\n   *\n   * @private\n   * @returns The ClientAuth object to use for client authentication.\n   * @throws {MissingClientAuthError} When no valid authentication method is configured\n   */\n  async #getClientAuth(): Promise<client.ClientAuth> {\n    if (\n      !this.#options.clientSecret &&\n      !this.#options.clientAssertionSigningKey &&\n      !this.#options.useMtls\n    ) {\n      throw new MissingClientAuthError();\n    }\n\n    if (this.#options.useMtls) {\n      return client.TlsClientAuth();\n    }\n\n    let clientPrivateKey = this.#options.clientAssertionSigningKey as\n      | CryptoKey\n      | undefined;\n\n    if (clientPrivateKey && !(clientPrivateKey instanceof CryptoKey)) {\n      clientPrivateKey = await importPKCS8(\n        clientPrivateKey,\n        this.#options.clientAssertionSigningAlg || 'RS256'\n      );\n    }\n\n    return clientPrivateKey\n      ? client.PrivateKeyJwt(clientPrivateKey)\n      : client.ClientSecretPost(this.#options.clientSecret!);\n  }\n\n  /**\n   * Builds the URL to redirect the user-agent to to request authorization at Auth0.\n   * @param options Options used to configure the authorization URL.\n   * @returns A promise resolving to an object, containing the authorizationUrl and codeVerifier.\n   */\n  async #buildAuthorizationUrl(\n    options?: BuildAuthorizationUrlOptions\n  ): Promise<BuildAuthorizationUrlResult> {\n    const { configuration } = await this.#discover();\n\n    const codeChallengeMethod = 'S256';\n    const codeVerifier = client.randomPKCECodeVerifier();\n    const codeChallenge = await client.calculatePKCECodeChallenge(codeVerifier);\n\n    const additionalParams = stripUndefinedProperties({\n      ...this.#options.authorizationParams,\n      ...options?.authorizationParams,\n    });\n\n    const params = new URLSearchParams({\n      scope: DEFAULT_SCOPES,\n      ...additionalParams,\n      client_id: this.#options.clientId,\n      code_challenge: codeChallenge,\n      code_challenge_method: codeChallengeMethod,\n    });\n\n    const authorizationUrl = options?.pushedAuthorizationRequests\n      ? await client.buildAuthorizationUrlWithPAR(configuration, params)\n      : await client.buildAuthorizationUrl(configuration, params);\n\n    return {\n      authorizationUrl,\n      codeVerifier,\n    };\n  }\n}\n","/**\n * Interface to represent an OAuth2 error.\n */\nexport interface OAuth2Error {\n  error: string;\n  error_description: string;\n  message?: string;\n}\n\n/**\n * Error codes used for {@link NotSupportedError}\n */\nexport enum NotSupportedErrorCode {\n  PAR_NOT_SUPPORTED = 'par_not_supported_error',\n  MTLS_WITHOUT_CUSTOMFETCH_NOT_SUPPORT = 'mtls_without_custom_fetch_not_supported',\n}\n\n/**\n * Error thrown when a feature is not supported.\n * For example, when trying to use Pushed Authorization Requests (PAR) but the Auth0 tenant was not configured to support it.\n */\nexport class NotSupportedError extends Error {\n  public code: string;\n\n  constructor(code: string, message: string) {\n    super(message);\n    this.name = 'NotSupportedError';\n    this.code = code;\n  }\n}\n\n/**\n * Base class for API errors, containing the error, error_description and message (if available).\n */\nabstract class ApiError extends Error {\n  public cause?: OAuth2Error;\n  public code: string;\n\n  constructor(code: string, message: string, cause?: OAuth2Error) {\n    super(message);\n\n    this.code = code;\n    this.cause = cause && {\n      error: cause.error,\n      error_description: cause.error_description,\n      message: cause.message,\n    };\n  }\n}\n\n/**\n * Error thrown when trying to get an access token.\n */\nexport class TokenByCodeError extends ApiError {\n  constructor(message: string, cause?: OAuth2Error) {\n    super('token_by_code_error', message, cause);\n    this.name = 'TokenByCodeError';\n  }\n}\n\n/**\n * Error thrown when trying to get an access token.\n */\nexport class TokenByClientCredentialsError extends ApiError {\n  constructor(message: string, cause?: OAuth2Error) {\n    super('token_by_client_credentials_error', message, cause);\n    this.name = 'TokenByClientCredentialsError';\n  }\n}\n\n/**\n * Error thrown when trying to get an access token.\n */\nexport class TokenByRefreshTokenError extends ApiError {\n  constructor(message: string, cause?: OAuth2Error) {\n    super('token_by_refresh_token_error', message, cause);\n    this.name = 'TokenByRefreshTokenError';\n  }\n}\n\n/**\n * Error thrown when trying to get an access token for a connection.\n *\n * @deprecated Since v1.2.0, using {@link AuthClient#getTokenForConnection} is deprecated and we recommend to use {@link AuthClient#exchangeToken}.\n * When doing so, use {@link TokenExchangeError} instead of {@link TokenForConnectionError}.\n * This error class remains for backward compatibility and is planned for removal in v2.0.\n */\nexport class TokenForConnectionError extends ApiError {\n  constructor(message: string, cause?: OAuth2Error) {\n    super('token_for_connection_error', message, cause);\n    // NOTE: The name is 'TokenForConnectionErrorCode' (not 'TokenForConnectionError')\n    // for backward compatibility. Consumers may branch on err.name in their error handling.\n    this.name = 'TokenForConnectionErrorCode';\n  }\n}\n\n/**\n * Error thrown when a Token Exchange flow fails. This can occur due to misconfiguration,\n * an invalid subject_token, or if the exchange is denied by the server.\n */\nexport class TokenExchangeError extends ApiError {\n  constructor(message: string, cause?: OAuth2Error) {\n    super('token_exchange_error', message, cause);\n    this.name = 'TokenExchangeError';\n  }\n}\n\n/**\n * Error thrown when verifying the logout token.\n */\nexport class VerifyLogoutTokenError extends Error {\n  public code: string = 'verify_logout_token_error';\n\n  constructor(message: string) {\n    super(message);\n    this.name = 'VerifyLogoutTokenError';\n  }\n}\n\n/**\n * Error thrown when trying to use Client-Initiated Backchannel Authentication.\n */\nexport class BackchannelAuthenticationError extends ApiError {\n  public code: string = 'backchannel_authentication_error';\n\n  constructor(cause?: OAuth2Error) {\n    super(\n      'backchannel_authentication_error',\n      'There was an error when trying to use Client-Initiated Backchannel Authentication.',\n      cause\n    );\n    this.name = 'BackchannelAuthenticationError';\n  }\n}\n\n/**\n * Error thrown when trying to build the authorization URL.\n */\nexport class BuildAuthorizationUrlError extends ApiError {\n  constructor(cause?: OAuth2Error) {\n    super(\n      'build_authorization_url_error',\n      'There was an error when trying to build the authorization URL.',\n      cause\n    );\n    this.name = 'BuildAuthorizationUrlError';\n  }\n}\n\n/**\n * Error thrown when trying to build the Link User URL.\n */\nexport class BuildLinkUserUrlError extends ApiError {\n  constructor(cause?: OAuth2Error) {\n    super(\n      'build_link_user_url_error',\n      'There was an error when trying to build the Link User URL.',\n      cause\n    );\n    this.name = 'BuildLinkUserUrlError';\n  }\n}\n\n/**\n * Error thrown when trying to build the Unlink User URL.\n */\nexport class BuildUnlinkUserUrlError extends ApiError {\n  constructor(cause?: OAuth2Error) {\n    super(\n      'build_unlink_user_url_error',\n      'There was an error when trying to build the Unlink User URL.',\n      cause\n    );\n    this.name = 'BuildUnlinkUserUrlError';\n  }\n}\n\n/**\n * Error thrown when Client Secret or Client Assertion Signing Key is missing.\n */\nexport class MissingClientAuthError extends Error {\n  public code: string = 'missing_client_auth_error';\n\n  constructor() {\n    super(\n      'The client secret or client assertion signing key must be provided.'\n    );\n    this.name = 'MissingClientAuthError';\n  }\n}\n","/**\n * Helper function that removes properties from an object when the value is undefined.\n * @returns The object, without the properties whose values are undefined.\n */\nexport function stripUndefinedProperties<T extends object>(\n  value: T\n): Partial<T> {\n  return Object.entries(value)\n    .filter(([, value]) => typeof value !== 'undefined')\n    .reduce((acc, curr) => ({ ...acc, [curr[0]]: curr[1] }), {});\n}\n","/**\n * Interface to represent an MFA API error response.\n */\nexport interface MfaApiErrorResponse {\n  error: string;\n  error_description: string;\n  message?: string;\n}\n\n/**\n * Base class for MFA-related errors.\n */\nabstract class MfaError extends Error {\n  public cause?: MfaApiErrorResponse;\n  public code: string;\n\n  constructor(code: string, message: string, cause?: MfaApiErrorResponse) {\n    super(message);\n\n    this.code = code;\n    this.cause = cause && {\n      error: cause.error,\n      error_description: cause.error_description,\n      message: cause.message,\n    };\n  }\n}\n\n/**\n * Error thrown when listing authenticators fails.\n */\nexport class MfaListAuthenticatorsError extends MfaError {\n  constructor(message: string, cause?: MfaApiErrorResponse) {\n    super('mfa_list_authenticators_error', message, cause);\n    this.name = 'MfaListAuthenticatorsError';\n  }\n}\n\n/**\n * Error thrown when enrolling an authenticator fails.\n */\nexport class MfaEnrollmentError extends MfaError {\n  constructor(message: string, cause?: MfaApiErrorResponse) {\n    super('mfa_enrollment_error', message, cause);\n    this.name = 'MfaEnrollmentError';\n  }\n}\n\n/**\n * Error thrown when deleting an authenticator fails.\n */\nexport class MfaDeleteAuthenticatorError extends MfaError {\n  constructor(message: string, cause?: MfaApiErrorResponse) {\n    super('mfa_delete_authenticator_error', message, cause);\n    this.name = 'MfaDeleteAuthenticatorError';\n  }\n}\n\n/**\n * Error thrown when initiating an MFA challenge fails.\n */\nexport class MfaChallengeError extends MfaError {\n  constructor(message: string, cause?: MfaApiErrorResponse) {\n    super('mfa_challenge_error', message, cause);\n    this.name = 'MfaChallengeError';\n  }\n}\n\n","import type {\n  AuthenticatorResponse,\n  AuthenticatorApiResponse,\n  EnrollmentResponse,\n  EnrollmentApiResponse,\n  ChallengeResponse,\n  ChallengeApiResponse,\n} from './types.js';\n\n/**\n * Transforms API authenticator response (snake_case) to SDK format (camelCase).\n * @internal\n */\nexport function transformAuthenticatorResponse(api: AuthenticatorApiResponse): AuthenticatorResponse {\n  return {\n    id: api.id,\n    authenticatorType: api.authenticator_type,\n    active: api.active,\n    name: api.name,\n    oobChannels: api.oob_channels,\n    type: api.type\n  };\n}\n\n/**\n * Transforms API enrollment response (snake_case) to SDK format (camelCase).\n * @internal\n */\nexport function transformEnrollmentResponse(api: EnrollmentApiResponse): EnrollmentResponse {\n  if (api.authenticator_type === 'otp') {\n    return {\n      authenticatorType: 'otp',\n      secret: api.secret,\n      barcodeUri: api.barcode_uri,\n      recoveryCodes: api.recovery_codes,\n      id: api.id,\n    };\n  }\n  \n  // OOB - covers SMS, Voice, Auth0, and Email channels\n  if (api.authenticator_type === 'oob') {\n    return {\n      authenticatorType: 'oob',\n      oobChannel: api.oob_channel,\n      oobCode: api.oob_code,\n      bindingMethod: api.binding_method,\n      id: api.id,\n    };\n  }\n  \n  throw new Error(`Unexpected authenticator type: ${(api as { authenticator_type: string }).authenticator_type}`);\n}\n\n/**\n * Transforms API challenge response (snake_case) to SDK format (camelCase).\n * Only includes optional fields when they have values.\n * @internal\n */\nexport function transformChallengeResponse(api: ChallengeApiResponse): ChallengeResponse {\n  const result: ChallengeResponse = {\n    challengeType: api.challenge_type,\n  };\n\n  if (api.oob_code !== undefined) {\n    result.oobCode = api.oob_code;\n  }\n\n  if (api.binding_method !== undefined) {\n    result.bindingMethod = api.binding_method;\n  }\n\n  return result;\n}\n","import type {\n  MfaClientOptions,\n  AuthenticatorResponse,\n  AuthenticatorApiResponse,\n  ListAuthenticatorsOptions,\n  DeleteAuthenticatorOptions,\n  EnrollAuthenticatorOptions,\n  EnrollmentResponse,\n  EnrollmentApiResponse,\n  ChallengeOptions,\n  ChallengeResponse,\n  ChallengeApiResponse,\n} from './types.js';\nimport {\n  MfaListAuthenticatorsError,\n  MfaEnrollmentError,\n  MfaDeleteAuthenticatorError,\n  MfaChallengeError,\n  type MfaApiErrorResponse,\n} from './errors.js';\nimport {\n  transformAuthenticatorResponse,\n  transformEnrollmentResponse,\n  transformChallengeResponse,\n} from './utils.js';\n\n\nexport class MfaClient {\n  #baseUrl: string;\n  #clientId: string;\n  #customFetch: typeof fetch;\n\n  /**\n   * @internal\n   */\n  constructor(options: MfaClientOptions) {\n    this.#baseUrl = `https://${options.domain}`;\n    this.#clientId = options.clientId;\n    this.#customFetch = options.customFetch ?? ((...args) => fetch(...args));\n  }\n\n  /**\n   * Lists all MFA authenticators enrolled by the user.\n   *\n   * Retrieves a list of all multi-factor authentication methods that have been\n   * enrolled for the user, including OTP (TOTP), SMS, voice, email, and recovery codes.\n   *\n   * @param options - Options for listing authenticators\n   * @param options.mfaToken - MFA token obtained from an MFA challenge response\n   * @returns Promise resolving to an array of enrolled authenticators\n   * @throws {MfaListAuthenticatorsError} When the request fails (e.g., invalid token, network error)\n   *\n   * @example\n   * ```typescript\n   * const authenticators = await authClient.mfa.listAuthenticators({\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   *\n   * // authenticators is an array of enrolled authenticators\n   * // Each has: id, authenticatorType, active, name, oobChannels (for OOB types), type\n   * ```\n   */\n  async listAuthenticators(options: ListAuthenticatorsOptions): Promise<AuthenticatorResponse[]> {\n    const url = `${this.#baseUrl}/mfa/authenticators`;\n    const { mfaToken } = options;\n\n    const response = await this.#customFetch(url, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${mfaToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      const error = (await response.json()) as MfaApiErrorResponse;\n      throw new MfaListAuthenticatorsError(\n        error.error_description || 'Failed to list authenticators',\n        error\n      );\n    }\n\n    const apiResponse = (await response.json()) as AuthenticatorApiResponse[];\n    return apiResponse.map(transformAuthenticatorResponse);\n  }\n\n  /**\n   * Enrolls a new MFA authenticator for the user.\n   *\n   * Initiates the enrollment process for a new multi-factor authentication method.\n   * Supports OTP (TOTP apps like Google Authenticator), SMS, voice, and email authenticators.\n   *\n   * For OTP enrollment, the response includes a secret and QR code URI that the user\n   * can scan with their authenticator app. For SMS/voice enrollment, a phone number\n   * must be provided. For email enrollment, an optional email address can be specified.\n   *\n   * @param options - Enrollment options (type depends on authenticator being enrolled)\n   * @param options.mfaToken - MFA token obtained from an MFA challenge response\n   * @param options.authenticatorTypes - Array with one authenticator type: 'otp', 'oob', or 'email'\n   * @param options.oobChannels - (OOB only) Delivery channels: 'sms', 'voice', or 'auth0'\n   * @param options.phoneNumber - (OOB only) Phone number in E.164 format (e.g., +1234567890)\n   * @param options.email - (Email only) Email address (optional, uses user's email if not provided)\n   * @returns Promise resolving to enrollment response with authenticator details\n   * @throws {MfaEnrollmentError} When enrollment fails (e.g., invalid parameters, network error)\n   *\n   * @example\n   * ```typescript\n   * // Enroll OTP authenticator (Google Authenticator, etc.)\n   * const otpEnrollment = await authClient.mfa.enrollAuthenticator({\n   *   authenticatorTypes: ['otp'],\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   * // otpEnrollment.secret - Base32-encoded secret for TOTP\n   * // otpEnrollment.barcodeUri - URI for generating QR code\n   *\n   * // Enroll SMS authenticator\n   * const smsEnrollment = await authClient.mfa.enrollAuthenticator({\n   *   authenticatorTypes: ['oob'],\n   *   oobChannels: ['sms'],\n   *   phoneNumber: '+1234567890',\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   * ```\n   */\n  async enrollAuthenticator(options: EnrollAuthenticatorOptions): Promise<EnrollmentResponse> {\n    const url = `${this.#baseUrl}/mfa/associate`;\n    const { mfaToken, ...sdkParams } = options;\n\n    // Transform camelCase SDK params to snake_case for API\n    const apiParams: Record<string, unknown> = {\n      authenticator_types: sdkParams.authenticatorTypes,\n    };\n\n    if ('oobChannels' in sdkParams) {\n      apiParams.oob_channels = sdkParams.oobChannels;\n    }\n\n    if ('phoneNumber' in sdkParams && sdkParams.phoneNumber) {\n      apiParams.phone_number = sdkParams.phoneNumber;\n    }\n\n    if ('email' in sdkParams && sdkParams.email) {\n      apiParams.email = sdkParams.email;\n    }\n\n    const response = await this.#customFetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${mfaToken}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(apiParams),\n    });\n\n    if (!response.ok) {\n      const error = (await response.json()) as MfaApiErrorResponse;\n      throw new MfaEnrollmentError(\n        error.error_description || 'Failed to enroll authenticator',\n        error\n      );\n    }\n\n    const apiResponse = (await response.json()) as EnrollmentApiResponse;\n    return transformEnrollmentResponse(apiResponse);\n  }\n\n  /**\n   * Deletes an enrolled MFA authenticator.\n   *\n   * Removes a previously enrolled multi-factor authentication method from the user's account.\n   * The authenticator ID can be obtained from the listAuthenticators() method.\n   *\n   * @param options - Options for deleting an authenticator\n   * @param options.authenticatorId - ID of the authenticator to delete (e.g., 'totp|dev_abc123')\n   * @param options.mfaToken - MFA token obtained from an MFA challenge response\n   * @returns Promise that resolves when the authenticator is successfully deleted\n   * @throws {MfaDeleteAuthenticatorError} When deletion fails (e.g., invalid ID, network error)\n   *\n   * @example\n   * ```typescript\n   * // First, list authenticators to get the ID\n   * const authenticators = await authClient.mfa.listAuthenticators({\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   *\n   * // Delete a specific authenticator\n   * await authClient.mfa.deleteAuthenticator({\n   *   authenticatorId: authenticators[0].id,\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   * ```\n   */\n  async deleteAuthenticator(options: DeleteAuthenticatorOptions): Promise<void> {\n    const { authenticatorId, mfaToken } = options;\n    const url = `${this.#baseUrl}/mfa/authenticators/${encodeURIComponent(authenticatorId)}`;\n\n    const response = await this.#customFetch(url, {\n      method: 'DELETE',\n      headers: {\n        Authorization: `Bearer ${mfaToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      const error = (await response.json()) as MfaApiErrorResponse;\n      throw new MfaDeleteAuthenticatorError(\n        error.error_description || 'Failed to delete authenticator',\n        error\n      );\n    }\n  }\n\n  /**\n   * Initiates an MFA challenge for user verification.\n   *\n   * Creates a challenge that the user must complete to verify their identity using\n   * one of their enrolled MFA factors. For OTP challenges, the user enters a code\n   * from their authenticator app. For OOB (out-of-band) challenges like SMS, a code\n   * is sent to the user's device.\n   *\n   * @param options - Challenge options\n   * @param options.mfaToken - MFA token obtained from an MFA challenge response\n   * @param options.challengeType - Type of challenge: 'otp' for TOTP apps, 'oob' for SMS/voice/push\n   * @param options.authenticatorId - (Optional) Specific authenticator to challenge\n   * @returns Promise resolving to challenge response with challenge details\n   * @throws {MfaChallengeError} When the challenge fails (e.g., invalid parameters, network error)\n   *\n   * @example\n   * ```typescript\n   * // Challenge with OTP (user enters code from their app)\n   * const otpChallenge = await authClient.mfa.challengeAuthenticator({\n   *   challengeType: 'otp',\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   *\n   * // Challenge with SMS (code sent to user's phone)\n   * const smsChallenge = await authClient.mfa.challengeAuthenticator({\n   *   challengeType: 'oob',\n   *   authenticatorId: 'sms|dev_abc123',\n   *   mfaToken: 'your_mfa_token_here'\n   * });\n   * // smsChallenge.oobCode - Out-of-band code for verification\n   * ```\n   */\n  async challengeAuthenticator(options: ChallengeOptions): Promise<ChallengeResponse> {\n    const url = `${this.#baseUrl}/mfa/challenge`;\n    const { mfaToken, ...challengeParams } = options;\n\n    const body: Record<string, string | undefined> = {\n      mfa_token: mfaToken,\n      client_id: this.#clientId,\n      challenge_type: challengeParams.challengeType,\n    };\n\n    if (challengeParams.authenticatorId) {\n      body.authenticator_id = challengeParams.authenticatorId;\n    }\n\n    const response = await this.#customFetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    });\n\n    if (!response.ok) {\n      const error = (await response.json()) as MfaApiErrorResponse;\n      throw new MfaChallengeError(\n        error.error_description || 'Failed to challenge authenticator',\n        error\n      );\n    }\n\n    const apiResponse = (await response.json()) as ChallengeApiResponse;\n    return transformChallengeResponse(apiResponse);\n  }\n}\n","import {\n  IDToken,\n  TokenEndpointResponse,\n  TokenEndpointResponseHelpers,\n} from 'openid-client';\n\nexport interface AuthClientOptions {\n  /**\n   * The Auth0 domain to use for authentication.\n   * @example 'example.auth0.com' (without https://)\n   */\n  domain: string;\n  /**\n   * The client ID of the application.\n   */\n  clientId: string;\n  /**\n   * The client secret of the application.\n   */\n  clientSecret?: string;\n  /**\n   * The client assertion signing key to use.\n   */\n  clientAssertionSigningKey?: string | CryptoKey;\n  /**\n   * The client assertion signing algorithm to use.\n   */\n  clientAssertionSigningAlg?: string;\n  /**\n   * Authorization Parameters to be sent with the authorization request.\n   */\n  authorizationParams?: AuthorizationParameters;\n  /**\n   * Optional, custom Fetch implementation to use.\n   */\n  customFetch?: typeof fetch;\n\n  /**\n   * Indicates whether the SDK should use the mTLS endpoints if they are available.\n   *\n   * When set to `true`, using a `customFetch` is required.\n   */\n  useMtls?: boolean;\n}\n\nexport interface AuthorizationParameters {\n  /**\n   * The scope to use for the authentication request.\n   */\n  scope?: string;\n  /**\n   * The audience to use for the authentication request.\n   */\n  audience?: string;\n  /**\n   * The redirect URI to use for the authentication request, to which Auth0 will redirect the browser after the user has authenticated.\n   * @example 'https://example.com/callback'\n   */\n  redirect_uri?: string;\n\n  [key: string]: unknown;\n}\n\nexport interface BuildAuthorizationUrlOptions {\n  /**\n   * Indicates whether the authorization request should be done using a Pushed Authorization Request.\n   */\n  pushedAuthorizationRequests?: boolean;\n  /**\n   * Authorization Parameters to be sent with the authorization request.\n   */\n  authorizationParams?: AuthorizationParameters;\n}\n\nexport interface BuildAuthorizationUrlResult {\n  /**\n   * The URL to use to authenticate the user, including the query parameters.\n   * Redirect the user to this URL to authenticate.\n   * @example 'https://example.auth0.com/authorize?client_id=...&scope=...'\n   */\n  authorizationUrl: URL;\n  /**\n   * The code verifier that is used for the authorization request.\n   */\n  codeVerifier: string;\n}\n\nexport interface BuildLinkUserUrlOptions {\n  /**\n   * The connection for the user to link.\n   */\n  connection: string;\n  /**\n   * The scope for the connection.\n   */\n  connectionScope: string;\n  /**\n   * The id token of the user initiating the link.\n   */\n  idToken: string;\n  /**\n   * Additional authorization parameters to be sent with the link user request.\n   */\n  authorizationParams?: AuthorizationParameters;\n}\n\nexport interface BuildLinkUserUrlResult {\n  /**\n   * The URL to use to link the user, including the query parameters.\n   * Redirect the user to this URL to link the user.\n   * @example 'https://example.auth0.com/authorize?request_uri=urn:ietf:params:oauth:request_uri&client_id=...'\n   */\n  linkUserUrl: URL;\n  /**\n   * The code verifier that is used for the link user request.\n   */\n  codeVerifier: string;\n}\n\nexport interface BuildUnlinkUserUrlOptions {\n  /**\n   * The connection for the user to unlink.\n   */\n  connection: string;\n  /**\n   * The id token of the user initiating the unlink.\n   */\n  idToken: string;\n  /**\n   * Additional authorization parameters to be sent with the unlink user request.\n   */\n  authorizationParams?: AuthorizationParameters;\n}\n\nexport interface BuildUnlinkUserUrlResult {\n  /**\n   * The URL to use to unlink the user, including the query parameters.\n   * Redirect the user to this URL to unlink the user.\n   * @example 'https://example.auth0.com/authorize?request_uri=urn:ietf:params:oauth:request_uri&client_id=...'\n   */\n  unlinkUserUrl: URL;\n  /**\n   * The code verifier that is used for the unlink user request.\n   */\n  codeVerifier: string;\n}\n\nexport interface TokenByClientCredentialsOptions {\n  /**\n   * The audience for which the token should be requested.\n   */\n  audience: string;\n  /**\n   * The organization for which the token should be requested.\n   */\n  organization?: string;\n}\n\nexport interface TokenByRefreshTokenOptions {\n  /**\n   * The refresh token to use to get a token.\n   */\n  refreshToken: string;\n}\n\nexport interface TokenByCodeOptions {\n  /**\n   * The code verifier that is used for the authorization request.\n   */\n  codeVerifier: string;\n}\n\n/**\n * @deprecated Since v1.2.0. Use {@link TokenVaultExchangeOptions} with {@link AuthClient#exchangeToken}.\n * This interface remains for backward compatibility and is planned for removal in v2.0.\n */\nexport interface TokenForConnectionOptions {\n  /**\n   * The connection for which a token should be requested.\n   */\n  connection: string;\n  /**\n   * Login hint to inform which connection account to use, can be useful when multiple accounts for the connection exist for the same user.\n   */\n  loginHint?: string;\n  /**\n   * The refresh token to use to get an access token for the connection.\n   */\n  refreshToken?: string;\n  /**\n   * The access token to use to get an access token for the connection.\n   */\n  accessToken?: string;\n}\n\n/**\n * Configuration options for Token Exchange via Token Exchange Profile (RFC 8693).\n *\n * Token Exchange Profiles enable first-party on-behalf-of flows where you exchange\n * a custom token for Auth0 tokens targeting a different API, while preserving user identity.\n *\n * **Requirements:**\n * - Requires a confidential client (client_secret or client_assertion must be configured)\n * - Requires a Token Exchange Profile to be created in Auth0 via the Management API\n * - The subject_token_type must match a profile configured in your tenant\n * - Reserved namespaces are validated by the Auth0 platform; the SDK does not pre-validate\n * - The organization parameter is not supported during Early Access\n *\n * @see {@link https://auth0.com/docs/authenticate/custom-token-exchange Custom Token Exchange Documentation}\n * @see {@link https://auth0.com/docs/api/management/v2/token-exchange-profiles Token Exchange Profiles API}\n * @see {@link https://www.rfc-editor.org/rfc/rfc8693 RFC 8693: OAuth 2.0 Token Exchange}\n *\n * @example Basic usage\n * ```typescript\n * const response = await authClient.exchangeToken({\n *   subjectTokenType: 'urn:acme:custom-token',\n *   subjectToken: userProvidedToken,\n *   audience: 'https://api.example.com',\n *   scope: 'openid profile read:data'\n * });\n * ```\n *\n * @example With custom parameters for Action validation\n * ```typescript\n * const response = await authClient.exchangeToken({\n *   subjectTokenType: 'urn:acme:legacy-token',\n *   subjectToken: legacyToken,\n *   audience: 'https://api.example.com',\n *   scope: 'openid offline_access',\n *   extra: {\n *     device_id: 'device-12345',\n *     session_token: 'sess-abc'\n *   }\n * });\n * ```\n */\nexport interface ExchangeProfileOptions {\n  /**\n   * A URI that identifies the type of the subject token being exchanged.\n   * Must match a subject_token_type configured in a Token Exchange Profile.\n   *\n   * For custom token types, this must be a URI scoped under your own ownership.\n   *\n   * **Reserved namespaces** (validated by Auth0 platform):\n   * - http://auth0.com, https://auth0.com\n   * - http://okta.com, https://okta.com\n   * - urn:ietf, urn:auth0, urn:okta\n   *\n   * @example \"urn:acme:legacy-token\"\n   * @example \"http://acme.com/mcp-token\"\n   */\n  subjectTokenType: string;\n\n  /**\n   * The token to be exchanged.\n   */\n  subjectToken: string;\n\n  /**\n   * The unique identifier (audience) of the target API.\n   * Must match an API identifier configured in your Auth0 tenant.\n   *\n   * @example \"https://api.example.com\"\n   */\n  audience?: string;\n\n  /**\n   * Space-separated list of OAuth 2.0 scopes to request.\n   * Scopes must be allowed by the target API and token exchange profile configuration.\n   *\n   * @example \"openid profile email\"\n   * @example \"openid profile read:data write:data\"\n   */\n  scope?: string;\n\n  /**\n   * Type of token being requested (RFC 8693).\n   * Defaults to access_token if not specified.\n   *\n   * @see {@link https://datatracker.ietf.org/doc/html/rfc8693#section-2.1 RFC 8693 Section 2.1}\n   * @example \"urn:ietf:params:oauth:token-type:access_token\"\n   * @example \"urn:ietf:params:oauth:token-type:refresh_token\"\n   */\n  requestedTokenType?: string;\n\n  /**\n   * ID or name of the organization to use when authenticating a user.\n   * When provided, the user will be authenticated within the organization context,\n   * and the organization ID will be present in the access token payload.\n   * \n   * @see https://auth0.com/docs/manage-users/organizations\n   */\n  organization?: string;\n\n  /**\n   * Additional custom parameters accessible in Auth0 Actions via event.request.body.\n   *\n   * Use for context like device fingerprints, session IDs, or business metadata.\n   * Cannot override reserved OAuth parameters.\n   *\n   * Array values are limited to 20 items per key to prevent DoS attacks.\n   *\n   * **Security Warning**: Never include PII (Personally Identifiable Information),\n   * secrets, passwords, or sensitive data in extra parameters. These values may be\n   * logged by Auth0, stored in audit trails, or visible in network traces. Use only\n   * for non-sensitive metadata like device IDs, session identifiers, or request context.\n   *\n   * @example\n   * ```typescript\n   * {\n   *   device_fingerprint: 'a3d8f7b2c1e4...',\n   *   session_id: 'sess_abc123',\n   *   risk_score: '0.95'\n   * }\n   * ```\n   */\n  extra?: Record<string, string | string[]>;\n}\n\n/**\n * Configuration options for Access Token Exchange with Token Vault.\n *\n * Access Token Exchange with Token Vault enables secure access to third-party APIs (e.g., Google Calendar, Salesforce)\n * by exchanging an Auth0 token for an external provider's access token without the client handling\n * the external provider's refresh tokens.\n *\n * **Requirements:**\n * - Requires a confidential client (client credentials must be configured)\n * - Token Vault must be enabled for the specified connection\n * - The connection must support the requested token type\n *\n * @see {@link https://auth0.com/docs/secure/tokens/token-vault Token Vault Documentation}\n * @see {@link https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault Configure Token Vault}\n *\n * @example Using an access token\n * ```typescript\n * const response = await authClient.exchangeToken({\n *   connection: 'google-oauth2',\n *   subjectToken: auth0AccessToken,\n *   subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',\n *   loginHint: 'user@example.com'\n * });\n * ```\n *\n * @example Using a refresh token\n * ```typescript\n * const response = await authClient.exchangeToken({\n *   connection: 'google-oauth2',\n *   subjectToken: auth0RefreshToken,\n *   subjectTokenType: 'urn:ietf:params:oauth:token-type:refresh_token'\n * });\n * ```\n */\nexport interface TokenVaultExchangeOptions {\n  /**\n   * The name of the connection configured in Auth0 with Token Vault enabled.\n   *\n   * @example \"google-oauth2\"\n   * @example \"salesforce\"\n   */\n  connection: string;\n\n  /**\n   * The Auth0 token to exchange (access token or refresh token).\n   */\n  subjectToken: string;\n\n  /**\n   * Type of the Auth0 token being exchanged.\n   *\n   * **Important**: Defaults to `urn:ietf:params:oauth:token-type:access_token` if not specified.\n   * If you're passing a refresh token, you MUST explicitly set this to\n   * `urn:ietf:params:oauth:token-type:refresh_token` to avoid token type mismatch errors.\n   *\n   * @default 'urn:ietf:params:oauth:token-type:access_token'\n   */\n  subjectTokenType?:\n    | 'urn:ietf:params:oauth:token-type:access_token'\n    | 'urn:ietf:params:oauth:token-type:refresh_token';\n\n  /**\n   * Type of token being requested from the external provider.\n   * Typically defaults to the external provider's access token type.\n   */\n  requestedTokenType?: string;\n\n  /**\n   * Hint about which external provider account to use.\n   * Useful when multiple accounts for the connection exist for the same user.\n   *\n   * @example \"user@example.com\"\n   * @example \"external_user_id_123\"\n   */\n  loginHint?: string;\n\n  /**\n   * Space-separated list of scopes to request from the external provider.\n   *\n   * @example \"https://www.googleapis.com/auth/calendar.readonly\"\n   */\n  scope?: string;\n\n  /**\n   * Additional custom parameters.\n   * Cannot override reserved OAuth parameters.\n   *\n   * Array values are limited to 20 items per key to prevent DoS attacks.\n   */\n  extra?: Record<string, string | string[]>;\n}\n\nexport interface BuildLogoutUrlOptions {\n  /**\n   * The URL to which the user should be redirected after the logout.\n   * @example 'https://example.com'\n   */\n  returnTo: string;\n}\n\nexport interface VerifyLogoutTokenOptions {\n  /**\n   * The logout token to verify.\n   */\n  logoutToken: string;\n}\n\nexport interface VerifyLogoutTokenResult {\n  /**\n   * The sid claim of the logout token.\n   */\n  sid: string;\n  /**\n   * The sub claim of the logout token.\n   */\n  sub: string;\n}\n\nexport interface AuthorizationDetails {\n  readonly type: string;\n  readonly [parameter: string]: unknown;\n}\n\n/**\n * Represents a successful token response from Auth0.\n *\n * Contains all tokens and metadata returned from Auth0 token endpoints,\n * including standard OAuth 2.0 tokens and optional OIDC tokens.\n */\nexport class TokenResponse {\n  /**\n   * The access token retrieved from Auth0.\n   */\n  accessToken: string;\n  /**\n   * The id token retrieved from Auth0.\n   */\n  idToken?: string;\n  /**\n   * The refresh token retrieved from Auth0.\n   */\n  refreshToken?: string;\n  /**\n   * The time at which the access token expires (Unix timestamp in seconds).\n   */\n  expiresAt: number;\n  /**\n   * The scope of the access token.\n   */\n  scope?: string;\n  /**\n   * The claims of the id token.\n   */\n  claims?: IDToken;\n  /**\n   * The authorization details of the token response.\n   */\n  authorizationDetails?: AuthorizationDetails[];\n\n  /**\n   * The type of the token (typically \"Bearer\").\n   */\n  tokenType?: string;\n\n  /**\n   * A URI that identifies the type of the issued token (RFC 8693).\n   *\n   * @see {@link https://datatracker.ietf.org/doc/html/rfc8693#section-3 RFC 8693 Section 3}\n   * @example \"urn:ietf:params:oauth:token-type:access_token\"\n   */\n  issuedTokenType?: string;\n\n  constructor(\n    accessToken: string,\n    expiresAt: number,\n    idToken?: string,\n    refreshToken?: string,\n    scope?: string,\n    claims?: IDToken,\n    authorizationDetails?: AuthorizationDetails[]\n  ) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.refreshToken = refreshToken;\n    this.expiresAt = expiresAt;\n    this.scope = scope;\n    this.claims = claims;\n    this.authorizationDetails = authorizationDetails;\n  }\n\n  /**\n   * Create a TokenResponse from a TokenEndpointResponse (openid-client).\n   *\n   * Populates all standard OAuth 2.0 token response fields plus RFC 8693 extensions.\n   * Safely handles responses that may not include all optional fields (e.g., ID token,\n   * refresh token, issued_token_type).\n   *\n   * @param response The TokenEndpointResponse from the token endpoint.\n   * @returns A TokenResponse instance with all available token data.\n   */\n  static fromTokenEndpointResponse(\n    response: TokenEndpointResponse & TokenEndpointResponseHelpers\n  ): TokenResponse {\n    const claims = response.id_token ? response.claims() : undefined;\n\n    const tokenResponse = new TokenResponse(\n      response.access_token,\n      Math.floor(Date.now() / 1000) + Number(response.expires_in),\n      response.id_token,\n      response.refresh_token,\n      response.scope,\n      claims,\n      response.authorization_details\n    );\n\n    tokenResponse.tokenType = response.token_type;\n    tokenResponse.issuedTokenType = (\n      response as typeof response & { issued_token_type?: string }\n    ).issued_token_type;\n\n    return tokenResponse;\n  }\n}\n\nexport interface BackchannelAuthenticationOptions {\n  /**\n   * Human-readable message to be displayed at the consumption device and authentication device.\n   * This allows the user to ensure the transaction initiated by the consumption device is the same that triggers the action on the authentication device.\n   */\n  bindingMessage: string;\n  /**\n   * The login hint to inform which user to use.\n   */\n  loginHint: {\n    /**\n     * The `sub` claim of the user that is trying to login using Client-Initiated Backchannel Authentication, and to which a push notification to authorize the login will be sent.\n     */\n    sub: string;\n  };\n  /**\n   * Set a custom expiry time for the CIBA flow in seconds. Defaults to 300 seconds (5 minutes) if not set.\n   */\n  requestedExpiry?: number;\n  /**\n   * Optional authorization details to use Rich Authorization Requests (RAR).\n   * @see https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests\n   */\n  authorizationDetails?: AuthorizationDetails[];\n  /**\n   * Authorization Parameters to be sent with the authorization request.\n   */\n  authorizationParams?: AuthorizationParameters;\n}\n"],"mappings":"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","names":["customFetch","NotSupportedErrorCode","value","customFetch"]}