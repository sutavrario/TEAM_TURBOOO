import {
  __toESM,
  require_react
} from "./chunk-N6MYFXC3.js";

// node_modules/@auth0/auth0-react/dist/auth0-react.esm.js
var import_react = __toESM(require_react());
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e3) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
    if (ar2 || !(i2 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i2);
      ar2[i2] = from[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
function e(e3, t2) {
  var n2 = {};
  for (var o2 in e3) Object.prototype.hasOwnProperty.call(e3, o2) && t2.indexOf(o2) < 0 && (n2[o2] = e3[o2]);
  if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
    var r2 = 0;
    for (o2 = Object.getOwnPropertySymbols(e3); r2 < o2.length; r2++) t2.indexOf(o2[r2]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, o2[r2]) && (n2[o2[r2]] = e3[o2[r2]]);
  }
  return n2;
}
var t = { timeoutInSeconds: 60 };
var n = { name: "auth0-spa-js", version: "2.16.0" };
var o = () => Date.now();
var r = class _r2 extends Error {
  constructor(e3, t2) {
    super(t2), this.error = e3, this.error_description = t2, Object.setPrototypeOf(this, _r2.prototype);
  }
  static fromPayload(e3) {
    let { error: t2, error_description: n2 } = e3;
    return new _r2(t2, n2);
  }
};
var i = class _i2 extends r {
  constructor(e3, t2, n2) {
    let o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    super(e3, t2), this.state = n2, this.appState = o2, Object.setPrototypeOf(this, _i2.prototype);
  }
};
var a = class _a extends r {
  constructor(e3, t2, n2, o2) {
    let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
    super(e3, t2), this.connection = n2, this.state = o2, this.appState = r2, Object.setPrototypeOf(this, _a.prototype);
  }
};
var s = class _s extends r {
  constructor() {
    super("timeout", "Timeout"), Object.setPrototypeOf(this, _s.prototype);
  }
};
var c = class _c extends s {
  constructor(e3) {
    super(), this.popup = e3, Object.setPrototypeOf(this, _c.prototype);
  }
};
var u = class _u extends r {
  constructor(e3) {
    super("cancelled", "Popup closed"), this.popup = e3, Object.setPrototypeOf(this, _u.prototype);
  }
};
var l = class _l extends r {
  constructor() {
    super("popup_open", "Unable to open a popup for loginWithPopup - window.open returned `null`"), Object.setPrototypeOf(this, _l.prototype);
  }
};
var d = class _d extends r {
  constructor(e3, t2, n2, o2) {
    super(e3, t2), this.mfa_token = n2, this.mfa_requirements = o2, Object.setPrototypeOf(this, _d.prototype);
  }
};
var h = class _h extends r {
  constructor(e3, t2) {
    super("missing_refresh_token", "Missing Refresh Token (audience: '".concat(m(e3, ["default"]), "', scope: '").concat(m(t2), "')")), this.audience = e3, this.scope = t2, Object.setPrototypeOf(this, _h.prototype);
  }
};
var p = class _p extends r {
  constructor(e3, t2) {
    super("missing_scopes", "Missing requested scopes after refresh (audience: '".concat(m(e3, ["default"]), "', missing scope: '").concat(m(t2), "')")), this.audience = e3, this.scope = t2, Object.setPrototypeOf(this, _p.prototype);
  }
};
var f = class _f extends r {
  constructor(e3) {
    super("use_dpop_nonce", "Server rejected DPoP proof: wrong nonce"), this.newDpopNonce = e3, Object.setPrototypeOf(this, _f.prototype);
  }
};
function m(e3) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  return e3 && !t2.includes(e3) ? e3 : "";
}
var y = () => window.crypto;
var w = () => {
  const e3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
  let t2 = "";
  return Array.from(y().getRandomValues(new Uint8Array(43))).forEach(((n2) => t2 += e3[n2 % e3.length])), t2;
};
var g = (e3) => btoa(e3);
var v = [{ key: "name", type: ["string"] }, { key: "version", type: ["string", "number"] }, { key: "env", type: ["object"] }];
var b = function(e3) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
  return Object.keys(e3).reduce(((n2, o2) => {
    if (t2 && "env" === o2) return n2;
    const r2 = v.find(((e4) => e4.key === o2));
    return r2 && r2.type.includes(typeof e3[o2]) && (n2[o2] = e3[o2]), n2;
  }), {});
};
var _ = (t2) => {
  var { clientId: n2 } = t2, o2 = e(t2, ["clientId"]);
  return new URLSearchParams(((e3) => Object.keys(e3).filter(((t3) => void 0 !== e3[t3])).reduce(((t3, n3) => Object.assign(Object.assign({}, t3), { [n3]: e3[n3] })), {}))(Object.assign({ client_id: n2 }, o2))).toString();
};
var k = async (e3) => {
  const t2 = y().subtle.digest({ name: "SHA-256" }, new TextEncoder().encode(e3));
  return await t2;
};
var S = (e3) => ((e4) => decodeURIComponent(atob(e4).split("").map(((e5) => "%" + ("00" + e5.charCodeAt(0).toString(16)).slice(-2))).join("")))(e3.replace(/_/g, "/").replace(/-/g, "+"));
var E = (e3) => {
  const t2 = new Uint8Array(e3);
  return ((e4) => {
    const t3 = { "+": "-", "/": "_", "=": "" };
    return e4.replace(/[+/=]/g, ((e5) => t3[e5]));
  })(window.btoa(String.fromCharCode(...Array.from(t2))));
};
var T = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
var A = {};
var P = {};
Object.defineProperty(P, "__esModule", { value: true });
var R = (function() {
  function e3() {
    var e4 = this;
    this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t2, n2) {
      var o2 = e4.locked.get(t2);
      void 0 === o2 ? void 0 === n2 ? e4.locked.set(t2, []) : e4.locked.set(t2, [n2]) : void 0 !== n2 && (o2.unshift(n2), e4.locked.set(t2, o2));
    }, this.isLocked = function(t2) {
      return e4.locked.has(t2);
    }, this.lock = function(t2) {
      return new Promise((function(n2, o2) {
        e4.isLocked(t2) ? e4.addToLocked(t2, n2) : (e4.addToLocked(t2), n2());
      }));
    }, this.unlock = function(t2) {
      var n2 = e4.locked.get(t2);
      if (void 0 !== n2 && 0 !== n2.length) {
        var o2 = n2.pop();
        e4.locked.set(t2, n2), void 0 !== o2 && setTimeout(o2, 0);
      } else e4.locked.delete(t2);
    };
  }
  return e3.getInstance = function() {
    return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;
  }, e3;
})();
P.default = function() {
  return R.getInstance();
};
var I = T && T.__awaiter || function(e3, t2, n2, o2) {
  return new (n2 || (n2 = Promise))((function(r2, i2) {
    function a2(e4) {
      try {
        c2(o2.next(e4));
      } catch (e5) {
        i2(e5);
      }
    }
    function s2(e4) {
      try {
        c2(o2.throw(e4));
      } catch (e5) {
        i2(e5);
      }
    }
    function c2(e4) {
      e4.done ? r2(e4.value) : new n2((function(t3) {
        t3(e4.value);
      })).then(a2, s2);
    }
    c2((o2 = o2.apply(e3, t2 || [])).next());
  }));
};
var x = T && T.__generator || function(e3, t2) {
  var n2, o2, r2, i2, a2 = { label: 0, sent: function() {
    if (1 & r2[0]) throw r2[1];
    return r2[1];
  }, trys: [], ops: [] };
  return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function s2(i3) {
    return function(s3) {
      return (function(i4) {
        if (n2) throw new TypeError("Generator is already executing.");
        for (; a2; ) try {
          if (n2 = 1, o2 && (r2 = 2 & i4[0] ? o2.return : i4[0] ? o2.throw || ((r2 = o2.return) && r2.call(o2), 0) : o2.next) && !(r2 = r2.call(o2, i4[1])).done) return r2;
          switch (o2 = 0, r2 && (i4 = [2 & i4[0], r2.value]), i4[0]) {
            case 0:
            case 1:
              r2 = i4;
              break;
            case 4:
              return a2.label++, { value: i4[1], done: false };
            case 5:
              a2.label++, o2 = i4[1], i4 = [0];
              continue;
            case 7:
              i4 = a2.ops.pop(), a2.trys.pop();
              continue;
            default:
              if (!(r2 = a2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                a2 = 0;
                continue;
              }
              if (3 === i4[0] && (!r2 || i4[1] > r2[0] && i4[1] < r2[3])) {
                a2.label = i4[1];
                break;
              }
              if (6 === i4[0] && a2.label < r2[1]) {
                a2.label = r2[1], r2 = i4;
                break;
              }
              if (r2 && a2.label < r2[2]) {
                a2.label = r2[2], a2.ops.push(i4);
                break;
              }
              r2[2] && a2.ops.pop(), a2.trys.pop();
              continue;
          }
          i4 = t2.call(e3, a2);
        } catch (e4) {
          i4 = [6, e4], o2 = 0;
        } finally {
          n2 = r2 = 0;
        }
        if (5 & i4[0]) throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      })([i3, s3]);
    };
  }
};
var O = T;
Object.defineProperty(A, "__esModule", { value: true });
var C = P;
var j = { key: function(e3) {
  return I(O, void 0, void 0, (function() {
    return x(this, (function(e4) {
      throw new Error("Unsupported");
    }));
  }));
}, getItem: function(e3) {
  return I(O, void 0, void 0, (function() {
    return x(this, (function(e4) {
      throw new Error("Unsupported");
    }));
  }));
}, clear: function() {
  return I(O, void 0, void 0, (function() {
    return x(this, (function(e3) {
      return [2, window.localStorage.clear()];
    }));
  }));
}, removeItem: function(e3) {
  return I(O, void 0, void 0, (function() {
    return x(this, (function(e4) {
      throw new Error("Unsupported");
    }));
  }));
}, setItem: function(e3, t2) {
  return I(O, void 0, void 0, (function() {
    return x(this, (function(e4) {
      throw new Error("Unsupported");
    }));
  }));
}, keySync: function(e3) {
  return window.localStorage.key(e3);
}, getItemSync: function(e3) {
  return window.localStorage.getItem(e3);
}, clearSync: function() {
  return window.localStorage.clear();
}, removeItemSync: function(e3) {
  return window.localStorage.removeItem(e3);
}, setItemSync: function(e3, t2) {
  return window.localStorage.setItem(e3, t2);
} };
function D(e3) {
  return new Promise((function(t2) {
    return setTimeout(t2, e3);
  }));
}
function K(e3) {
  for (var t2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", n2 = "", o2 = 0; o2 < e3; o2++) {
    n2 += t2[Math.floor(Math.random() * t2.length)];
  }
  return n2;
}
var L = (function() {
  function e3(t2) {
    this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + K(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);
  }
  return e3.prototype.acquireLock = function(t2, n2) {
    return void 0 === n2 && (n2 = 5e3), I(this, void 0, void 0, (function() {
      var o2, r2, i2, a2, s2, c2, u2;
      return x(this, (function(l2) {
        switch (l2.label) {
          case 0:
            o2 = Date.now() + K(4), r2 = Date.now() + n2, i2 = "browser-tabs-lock-key-" + t2, a2 = void 0 === this.storageHandler ? j : this.storageHandler, l2.label = 1;
          case 1:
            return Date.now() < r2 ? [4, D(30)] : [3, 8];
          case 2:
            return l2.sent(), null !== a2.getItemSync(i2) ? [3, 5] : (s2 = this.id + "-" + t2 + "-" + o2, [4, D(Math.floor(25 * Math.random()))]);
          case 3:
            return l2.sent(), a2.setItemSync(i2, JSON.stringify({ id: this.id, iat: o2, timeoutKey: s2, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, D(30)];
          case 4:
            return l2.sent(), null !== (c2 = a2.getItemSync(i2)) && (u2 = JSON.parse(c2)).id === this.id && u2.iat === o2 ? (this.acquiredIatSet.add(o2), this.refreshLockWhileAcquired(i2, o2), [2, true]) : [3, 7];
          case 5:
            return e3.lockCorrector(void 0 === this.storageHandler ? j : this.storageHandler), [4, this.waitForSomethingToChange(r2)];
          case 6:
            l2.sent(), l2.label = 7;
          case 7:
            return o2 = Date.now() + K(4), [3, 1];
          case 8:
            return [2, false];
        }
      }));
    }));
  }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {
    return I(this, void 0, void 0, (function() {
      var n2 = this;
      return x(this, (function(o2) {
        return setTimeout((function() {
          return I(n2, void 0, void 0, (function() {
            var n3, o3, r2;
            return x(this, (function(i2) {
              switch (i2.label) {
                case 0:
                  return [4, C.default().lock(t2)];
                case 1:
                  return i2.sent(), this.acquiredIatSet.has(t2) ? (n3 = void 0 === this.storageHandler ? j : this.storageHandler, null === (o3 = n3.getItemSync(e4)) ? (C.default().unlock(t2), [2]) : ((r2 = JSON.parse(o3)).timeRefreshed = Date.now(), n3.setItemSync(e4, JSON.stringify(r2)), C.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (C.default().unlock(t2), [2]);
              }
            }));
          }));
        }), 1e3), [2];
      }));
    }));
  }, e3.prototype.waitForSomethingToChange = function(t2) {
    return I(this, void 0, void 0, (function() {
      return x(this, (function(n2) {
        switch (n2.label) {
          case 0:
            return [4, new Promise((function(n3) {
              var o2 = false, r2 = Date.now(), i2 = false;
              function a2() {
                if (i2 || (window.removeEventListener("storage", a2), e3.removeFromWaiting(a2), clearTimeout(s2), i2 = true), !o2) {
                  o2 = true;
                  var t3 = 50 - (Date.now() - r2);
                  t3 > 0 ? setTimeout(n3, t3) : n3(null);
                }
              }
              window.addEventListener("storage", a2), e3.addToWaiting(a2);
              var s2 = setTimeout(a2, Math.max(0, t2 - Date.now()));
            }))];
          case 1:
            return n2.sent(), [2];
        }
      }));
    }));
  }, e3.addToWaiting = function(t2) {
    this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);
  }, e3.removeFromWaiting = function(t2) {
    void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter((function(e4) {
      return e4 !== t2;
    })));
  }, e3.notifyWaiters = function() {
    void 0 !== e3.waiters && e3.waiters.slice().forEach((function(e4) {
      return e4();
    }));
  }, e3.prototype.releaseLock = function(e4) {
    return I(this, void 0, void 0, (function() {
      return x(this, (function(t2) {
        switch (t2.label) {
          case 0:
            return [4, this.releaseLock__private__(e4)];
          case 1:
            return [2, t2.sent()];
        }
      }));
    }));
  }, e3.prototype.releaseLock__private__ = function(t2) {
    return I(this, void 0, void 0, (function() {
      var n2, o2, r2, i2;
      return x(this, (function(a2) {
        switch (a2.label) {
          case 0:
            return n2 = void 0 === this.storageHandler ? j : this.storageHandler, o2 = "browser-tabs-lock-key-" + t2, null === (r2 = n2.getItemSync(o2)) ? [2] : (i2 = JSON.parse(r2)).id !== this.id ? [3, 2] : [4, C.default().lock(i2.iat)];
          case 1:
            a2.sent(), this.acquiredIatSet.delete(i2.iat), n2.removeItemSync(o2), C.default().unlock(i2.iat), e3.notifyWaiters(), a2.label = 2;
          case 2:
            return [2];
        }
      }));
    }));
  }, e3.lockCorrector = function(t2) {
    for (var n2 = Date.now() - 5e3, o2 = t2, r2 = [], i2 = 0; ; ) {
      var a2 = o2.keySync(i2);
      if (null === a2) break;
      r2.push(a2), i2++;
    }
    for (var s2 = false, c2 = 0; c2 < r2.length; c2++) {
      var u2 = r2[c2];
      if (u2.includes("browser-tabs-lock-key")) {
        var l2 = o2.getItemSync(u2);
        if (null !== l2) {
          var d2 = JSON.parse(l2);
          (void 0 === d2.timeRefreshed && d2.timeAcquired < n2 || void 0 !== d2.timeRefreshed && d2.timeRefreshed < n2) && (o2.removeItemSync(u2), s2 = true);
        }
      }
    }
    s2 && e3.notifyWaiters();
  }, e3.waiters = void 0, e3;
})();
var U = A.default = L;
var N = class {
  async runWithLock(e3, t2, n2) {
    const o2 = new AbortController(), r2 = setTimeout((() => o2.abort()), t2);
    try {
      return await navigator.locks.request(e3, { mode: "exclusive", signal: o2.signal }, (async (e4) => {
        if (clearTimeout(r2), !e4) throw new Error("Lock not available");
        return await n2();
      }));
    } catch (e4) {
      if (clearTimeout(r2), "AbortError" === (null == e4 ? void 0 : e4.name)) throw new s();
      throw e4;
    }
  }
};
var W = class {
  constructor() {
    this.activeLocks = /* @__PURE__ */ new Set(), this.lock = new U(), this.pagehideHandler = () => {
      this.activeLocks.forEach(((e3) => this.lock.releaseLock(e3))), this.activeLocks.clear();
    };
  }
  async runWithLock(e3, t2, n2) {
    let o2 = false;
    for (let n3 = 0; n3 < 10 && !o2; n3++) o2 = await this.lock.acquireLock(e3, t2);
    if (!o2) throw new s();
    this.activeLocks.add(e3), 1 === this.activeLocks.size && "undefined" != typeof window && window.addEventListener("pagehide", this.pagehideHandler);
    try {
      return await n2();
    } finally {
      this.activeLocks.delete(e3), await this.lock.releaseLock(e3), 0 === this.activeLocks.size && "undefined" != typeof window && window.removeEventListener("pagehide", this.pagehideHandler);
    }
  }
};
function z() {
  return "undefined" != typeof navigator && "function" == typeof (null === (e3 = navigator.locks) || void 0 === e3 ? void 0 : e3.request) ? new N() : new W();
  var e3;
}
var H = null;
var M = new TextEncoder();
var J = new TextDecoder();
function V(e3) {
  return "string" == typeof e3 ? M.encode(e3) : J.decode(e3);
}
function F(e3) {
  if ("number" != typeof e3.modulusLength || e3.modulusLength < 2048) throw new X(`${e3.name} modulusLength must be at least 2048 bits`);
}
async function G(e3, t2, n2) {
  if (false === n2.usages.includes("sign")) throw new TypeError('private CryptoKey instances used for signing assertions must include "sign" in their "usages"');
  const o2 = `${q(V(JSON.stringify(e3)))}.${q(V(JSON.stringify(t2)))}`;
  return `${o2}.${q(await crypto.subtle.sign((function(e4) {
    switch (e4.algorithm.name) {
      case "ECDSA":
        return { name: e4.algorithm.name, hash: "SHA-256" };
      case "RSA-PSS":
        return F(e4.algorithm), { name: e4.algorithm.name, saltLength: 32 };
      case "RSASSA-PKCS1-v1_5":
        return F(e4.algorithm), { name: e4.algorithm.name };
      case "Ed25519":
        return { name: e4.algorithm.name };
    }
    throw new B();
  })(n2), n2, V(o2)))}`;
}
var Z;
if (Uint8Array.prototype.toBase64) Z = (e3) => (e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), e3.toBase64({ alphabet: "base64url", omitPadding: true }));
else {
  const e3 = 32768;
  Z = (t2) => {
    t2 instanceof ArrayBuffer && (t2 = new Uint8Array(t2));
    const n2 = [];
    for (let o2 = 0; o2 < t2.byteLength; o2 += e3) n2.push(String.fromCharCode.apply(null, t2.subarray(o2, o2 + e3)));
    return btoa(n2.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
}
function q(e3) {
  return Z(e3);
}
var B = class extends Error {
  constructor(e3) {
    var t2;
    super(null != e3 ? e3 : "operation not supported"), this.name = this.constructor.name, null === (t2 = Error.captureStackTrace) || void 0 === t2 || t2.call(Error, this, this.constructor);
  }
};
var X = class extends Error {
  constructor(e3) {
    var t2;
    super(e3), this.name = this.constructor.name, null === (t2 = Error.captureStackTrace) || void 0 === t2 || t2.call(Error, this, this.constructor);
  }
};
function Y(e3) {
  switch (e3.algorithm.name) {
    case "RSA-PSS":
      return (function(e4) {
        if ("SHA-256" === e4.algorithm.hash.name) return "PS256";
        throw new B("unsupported RsaHashedKeyAlgorithm hash name");
      })(e3);
    case "RSASSA-PKCS1-v1_5":
      return (function(e4) {
        if ("SHA-256" === e4.algorithm.hash.name) return "RS256";
        throw new B("unsupported RsaHashedKeyAlgorithm hash name");
      })(e3);
    case "ECDSA":
      return (function(e4) {
        if ("P-256" === e4.algorithm.namedCurve) return "ES256";
        throw new B("unsupported EcKeyAlgorithm namedCurve");
      })(e3);
    case "Ed25519":
      return "Ed25519";
    default:
      throw new B("unsupported CryptoKey algorithm name");
  }
}
function Q(e3) {
  return e3 instanceof CryptoKey;
}
function $(e3) {
  return Q(e3) && "public" === e3.type;
}
async function ee(e3, t2, n2, o2, r2, i2) {
  const a2 = null == e3 ? void 0 : e3.privateKey, s2 = null == e3 ? void 0 : e3.publicKey;
  if (!Q(c2 = a2) || "private" !== c2.type) throw new TypeError('"keypair.privateKey" must be a private CryptoKey');
  var c2;
  if (!$(s2)) throw new TypeError('"keypair.publicKey" must be a public CryptoKey');
  if (true !== s2.extractable) throw new TypeError('"keypair.publicKey.extractable" must be true');
  if ("string" != typeof t2) throw new TypeError('"htu" must be a string');
  if ("string" != typeof n2) throw new TypeError('"htm" must be a string');
  if (void 0 !== o2 && "string" != typeof o2) throw new TypeError('"nonce" must be a string or undefined');
  if (void 0 !== r2 && "string" != typeof r2) throw new TypeError('"accessToken" must be a string or undefined');
  if (void 0 !== i2 && ("object" != typeof i2 || null === i2 || Array.isArray(i2))) throw new TypeError('"additional" must be an object');
  return G({ alg: Y(a2), typ: "dpop+jwt", jwk: await te(s2) }, Object.assign(Object.assign({}, i2), { iat: Math.floor(Date.now() / 1e3), jti: crypto.randomUUID(), htm: n2, nonce: o2, htu: t2, ath: r2 ? q(await crypto.subtle.digest("SHA-256", V(r2))) : void 0 }), a2);
}
async function te(e3) {
  const { kty: t2, e: n2, n: o2, x: r2, y: i2, crv: a2 } = await crypto.subtle.exportKey("jwk", e3);
  return { kty: t2, crv: a2, e: n2, n: o2, x: r2, y: i2 };
}
var ne = ["authorization_code", "refresh_token", "urn:ietf:params:oauth:grant-type:token-exchange", "http://auth0.com/oauth/grant-type/mfa-oob", "http://auth0.com/oauth/grant-type/mfa-otp", "http://auth0.com/oauth/grant-type/mfa-recovery-code"];
function oe() {
  return (async function(e3, t2) {
    var n2;
    let o2;
    if ("string" != typeof e3 || 0 === e3.length) throw new TypeError('"alg" must be a non-empty string');
    switch (e3) {
      case "PS256":
        o2 = { name: "RSA-PSS", hash: "SHA-256", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]) };
        break;
      case "RS256":
        o2 = { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]) };
        break;
      case "ES256":
        o2 = { name: "ECDSA", namedCurve: "P-256" };
        break;
      case "Ed25519":
        o2 = { name: "Ed25519" };
        break;
      default:
        throw new B();
    }
    return crypto.subtle.generateKey(o2, null !== (n2 = null == t2 ? void 0 : t2.extractable) && void 0 !== n2 && n2, ["sign", "verify"]);
  })("ES256", { extractable: false });
}
function re(e3) {
  return (async function(e4) {
    if (!$(e4)) throw new TypeError('"publicKey" must be a public CryptoKey');
    if (true !== e4.extractable) throw new TypeError('"publicKey.extractable" must be true');
    const t2 = await te(e4);
    let n2;
    switch (t2.kty) {
      case "EC":
        n2 = { crv: t2.crv, kty: t2.kty, x: t2.x, y: t2.y };
        break;
      case "OKP":
        n2 = { crv: t2.crv, kty: t2.kty, x: t2.x };
        break;
      case "RSA":
        n2 = { e: t2.e, kty: t2.kty, n: t2.n };
        break;
      default:
        throw new B("unsupported JWK kty");
    }
    return q(await crypto.subtle.digest({ name: "SHA-256" }, V(JSON.stringify(n2))));
  })(e3.publicKey);
}
function ie(e3) {
  let { keyPair: t2, url: n2, method: o2, nonce: r2, accessToken: i2 } = e3;
  const a2 = (function(e4) {
    const t3 = new URL(e4);
    return t3.search = "", t3.hash = "", t3.href;
  })(n2);
  return ee(t2, a2, o2, r2, i2);
}
var ae = async (e3, t2) => {
  const n2 = await fetch(e3, t2);
  return { ok: n2.ok, json: await n2.json(), headers: (o2 = n2.headers, [...o2].reduce(((e4, t3) => {
    let [n3, o3] = t3;
    return e4[n3] = o3, e4;
  }), {})) };
  var o2;
};
var se = async (e3, t2, n2) => {
  const o2 = new AbortController();
  let r2;
  return t2.signal = o2.signal, Promise.race([ae(e3, t2), new Promise(((e4, t3) => {
    r2 = setTimeout((() => {
      o2.abort(), t3(new Error("Timeout when executing 'fetch'"));
    }), n2);
  }))]).finally((() => {
    clearTimeout(r2);
  }));
};
var ce = async (e3, t2, n2, o2, r2, i2, a2, s2) => ((e4, t3) => new Promise((function(n3, o3) {
  const r3 = new MessageChannel();
  r3.port1.onmessage = function(e5) {
    e5.data.error ? o3(new Error(e5.data.error)) : n3(e5.data), r3.port1.close();
  }, t3.postMessage(e4, [r3.port2]);
})))({ auth: { audience: t2, scope: n2 }, timeout: r2, fetchUrl: e3, fetchOptions: o2, useFormData: a2, useMrrt: s2 }, i2);
var ue = async function(e3, t2, n2, o2, r2, i2) {
  let a2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1e4, s2 = arguments.length > 7 ? arguments[7] : void 0;
  return r2 ? ce(e3, t2, n2, o2, a2, r2, i2, s2) : se(e3, o2, a2);
};
async function le(t2, n2, o2, i2, a2, s2, c2, u2, l2, p2) {
  if (l2) {
    const e3 = await l2.generateProof({ url: t2, method: a2.method || "GET", nonce: await l2.getNonce() });
    a2.headers = Object.assign(Object.assign({}, a2.headers), { dpop: e3 });
  }
  let m2, y2 = null;
  for (let e3 = 0; e3 < 3; e3++) try {
    m2 = await ue(t2, o2, i2, a2, s2, c2, n2, u2), y2 = null;
    break;
  } catch (e4) {
    y2 = e4;
  }
  if (y2) throw y2;
  const w2 = m2.json, { error: g2, error_description: v2 } = w2, b2 = e(w2, ["error", "error_description"]), { headers: _2, ok: k2 } = m2;
  let S2;
  if (l2 && (S2 = _2["dpop-nonce"], S2 && await l2.setNonce(S2)), !k2) {
    const e3 = v2 || "HTTP error. Unable to fetch ".concat(t2);
    if ("mfa_required" === g2) throw new d(g2, e3, b2.mfa_token, b2.mfa_requirements);
    if ("missing_refresh_token" === g2) throw new h(o2, i2);
    if ("use_dpop_nonce" === g2) {
      if (!l2 || !S2 || p2) throw new f(S2);
      return le(t2, n2, o2, i2, a2, s2, c2, u2, l2, true);
    }
    throw new r(g2 || "request_error", e3);
  }
  return b2;
}
async function de(t2, o2) {
  var { baseUrl: r2, timeout: i2, audience: a2, scope: s2, auth0Client: c2, useFormData: u2, useMrrt: l2, dpop: d2 } = t2, h2 = e(t2, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData", "useMrrt", "dpop"]);
  const p2 = "urn:ietf:params:oauth:grant-type:token-exchange" === h2.grant_type, f2 = "refresh_token" === h2.grant_type && l2, m2 = Object.assign(Object.assign(Object.assign(Object.assign({}, h2), p2 && a2 && { audience: a2 }), p2 && s2 && { scope: s2 }), f2 && { audience: a2, scope: s2 }), y2 = u2 ? _(m2) : JSON.stringify(m2), w2 = (g2 = h2.grant_type, ne.includes(g2));
  var g2;
  return await le("".concat(r2, "/oauth/token"), i2, a2 || "default", s2, { method: "POST", body: y2, headers: { "Content-Type": u2 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(b(c2 || n))) } }, o2, u2, l2, w2 ? d2 : void 0);
}
var he = (e3) => Array.from(new Set(e3));
var pe = function() {
  for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
  return he(t2.filter(Boolean).join(" ").trim().split(/\s+/)).join(" ");
};
var fe = (e3, t2, n2) => {
  let o2;
  return n2 && (o2 = e3[n2]), o2 || (o2 = e3.default), pe(o2, t2);
};
var me = class _me {
  constructor(e3) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "@@auth0spajs@@", n2 = arguments.length > 2 ? arguments[2] : void 0;
    this.prefix = t2, this.suffix = n2, this.clientId = e3.clientId, this.scope = e3.scope, this.audience = e3.audience;
  }
  toKey() {
    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
  }
  static fromKey(e3) {
    const [t2, n2, o2, r2] = e3.split("::");
    return new _me({ clientId: n2, scope: r2, audience: o2 }, t2);
  }
  static fromCacheEntry(e3) {
    const { scope: t2, audience: n2, client_id: o2 } = e3;
    return new _me({ scope: t2, audience: n2, clientId: o2 });
  }
};
var ye = class {
  set(e3, t2) {
    localStorage.setItem(e3, JSON.stringify(t2));
  }
  get(e3) {
    const t2 = window.localStorage.getItem(e3);
    if (t2) try {
      return JSON.parse(t2);
    } catch (e4) {
      return;
    }
  }
  remove(e3) {
    localStorage.removeItem(e3);
  }
  allKeys() {
    return Object.keys(window.localStorage).filter(((e3) => e3.startsWith("@@auth0spajs@@")));
  }
};
var we = class {
  constructor() {
    this.enclosedCache = /* @__PURE__ */ (function() {
      let e3 = {};
      return { set(t2, n2) {
        e3[t2] = n2;
      }, get(t2) {
        const n2 = e3[t2];
        if (n2) return n2;
      }, remove(t2) {
        delete e3[t2];
      }, allKeys: () => Object.keys(e3) };
    })();
  }
};
var ge = class {
  constructor(e3, t2, n2) {
    this.cache = e3, this.keyManifest = t2, this.nowProvider = n2 || o;
  }
  async setIdToken(e3, t2, n2) {
    var o2;
    const r2 = this.getIdTokenCacheKey(e3);
    await this.cache.set(r2, { id_token: t2, decodedToken: n2 }), await (null === (o2 = this.keyManifest) || void 0 === o2 ? void 0 : o2.add(r2));
  }
  async getIdToken(e3) {
    const t2 = await this.cache.get(this.getIdTokenCacheKey(e3.clientId));
    if (!t2 && e3.scope && e3.audience) {
      const t3 = await this.get(e3);
      if (!t3) return;
      if (!t3.id_token || !t3.decodedToken) return;
      return { id_token: t3.id_token, decodedToken: t3.decodedToken };
    }
    if (t2) return { id_token: t2.id_token, decodedToken: t2.decodedToken };
  }
  async get(e3) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o2 = arguments.length > 3 ? arguments[3] : void 0;
    var r2;
    let i2 = await this.cache.get(e3.toKey());
    if (!i2) {
      const t3 = await this.getCacheKeys();
      if (!t3) return;
      const r3 = this.matchExistingCacheKey(e3, t3);
      if (r3 && (i2 = await this.cache.get(r3)), !i2 && n2 && "cache-only" !== o2) return this.getEntryWithRefreshToken(e3, t3);
    }
    if (!i2) return;
    const a2 = await this.nowProvider(), s2 = Math.floor(a2 / 1e3);
    return i2.expiresAt - t2 < s2 ? i2.body.refresh_token ? this.modifiedCachedEntry(i2, e3) : (await this.cache.remove(e3.toKey()), void await (null === (r2 = this.keyManifest) || void 0 === r2 ? void 0 : r2.remove(e3.toKey()))) : i2.body;
  }
  async modifiedCachedEntry(e3, t2) {
    return e3.body = { refresh_token: e3.body.refresh_token, audience: e3.body.audience, scope: e3.body.scope }, await this.cache.set(t2.toKey(), e3), { refresh_token: e3.body.refresh_token, audience: e3.body.audience, scope: e3.body.scope };
  }
  async set(e3) {
    var t2;
    const n2 = new me({ clientId: e3.client_id, scope: e3.scope, audience: e3.audience }), o2 = await this.wrapCacheEntry(e3);
    await this.cache.set(n2.toKey(), o2), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(n2.toKey()));
  }
  async remove(e3, t2, n2) {
    const o2 = new me({ clientId: e3, scope: n2, audience: t2 });
    await this.cache.remove(o2.toKey());
  }
  async clear(e3) {
    var t2;
    const n2 = await this.getCacheKeys();
    n2 && (await n2.filter(((t3) => !e3 || t3.includes(e3))).reduce((async (e4, t3) => {
      await e4, await this.cache.remove(t3);
    }), Promise.resolve()), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear()));
  }
  async wrapCacheEntry(e3) {
    const t2 = await this.nowProvider();
    return { body: e3, expiresAt: Math.floor(t2 / 1e3) + e3.expires_in };
  }
  async getCacheKeys() {
    var e3;
    return this.keyManifest ? null === (e3 = await this.keyManifest.get()) || void 0 === e3 ? void 0 : e3.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;
  }
  getIdTokenCacheKey(e3) {
    return new me({ clientId: e3 }, "@@auth0spajs@@", "@@user@@").toKey();
  }
  matchExistingCacheKey(e3, t2) {
    return t2.filter(((t3) => {
      var n2;
      const o2 = me.fromKey(t3), r2 = new Set(o2.scope && o2.scope.split(" ")), i2 = (null === (n2 = e3.scope) || void 0 === n2 ? void 0 : n2.split(" ")) || [], a2 = o2.scope && i2.reduce(((e4, t4) => e4 && r2.has(t4)), true);
      return "@@auth0spajs@@" === o2.prefix && o2.clientId === e3.clientId && o2.audience === e3.audience && a2;
    }))[0];
  }
  async getEntryWithRefreshToken(e3, t2) {
    var n2;
    for (const o2 of t2) {
      const t3 = me.fromKey(o2);
      if ("@@auth0spajs@@" === t3.prefix && t3.clientId === e3.clientId) {
        const t4 = await this.cache.get(o2);
        if (null === (n2 = null == t4 ? void 0 : t4.body) || void 0 === n2 ? void 0 : n2.refresh_token) return this.modifiedCachedEntry(t4, e3);
      }
    }
  }
  async updateEntry(e3, t2) {
    var n2;
    const o2 = await this.getCacheKeys();
    if (o2) for (const r2 of o2) {
      const o3 = await this.cache.get(r2);
      (null === (n2 = null == o3 ? void 0 : o3.body) || void 0 === n2 ? void 0 : n2.refresh_token) === e3 && (o3.body.refresh_token = t2, await this.cache.set(r2, o3));
    }
  }
};
var ve = class {
  constructor(e3, t2, n2) {
    this.storage = e3, this.clientId = t2, this.cookieDomain = n2, this.storageKey = "".concat("a0.spajs.txs", ".").concat(this.clientId);
  }
  create(e3) {
    this.storage.save(this.storageKey, e3, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });
  }
  get() {
    return this.storage.get(this.storageKey);
  }
  remove() {
    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });
  }
};
var be = (e3) => "number" == typeof e3;
var _e = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"];
var ke = (e3) => {
  if (!e3.id_token) throw new Error("ID token is required but missing");
  const t2 = ((e4) => {
    const t3 = e4.split("."), [n3, o3, r3] = t3;
    if (3 !== t3.length || !n3 || !o3 || !r3) throw new Error("ID token could not be decoded");
    const i2 = JSON.parse(S(o3)), a2 = { __raw: e4 }, s2 = {};
    return Object.keys(i2).forEach(((e5) => {
      a2[e5] = i2[e5], _e.includes(e5) || (s2[e5] = i2[e5]);
    })), { encoded: { header: n3, payload: o3, signature: r3 }, header: JSON.parse(S(n3)), claims: a2, user: s2 };
  })(e3.id_token);
  if (!t2.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token");
  if (t2.claims.iss !== e3.iss) throw new Error('Issuer (iss) claim mismatch in the ID token; expected "'.concat(e3.iss, '", found "').concat(t2.claims.iss, '"'));
  if (!t2.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token");
  if ("RS256" !== t2.header.alg) throw new Error('Signature algorithm of "'.concat(t2.header.alg, '" is not supported. Expected the ID token to be signed with "RS256".'));
  if (!t2.claims.aud || "string" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
  if (Array.isArray(t2.claims.aud)) {
    if (!t2.claims.aud.includes(e3.aud)) throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(e3.aud, '" but was not one of "').concat(t2.claims.aud.join(", "), '"'));
    if (t2.claims.aud.length > 1) {
      if (!t2.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
      if (t2.claims.azp !== e3.aud) throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "'.concat(e3.aud, '", found "').concat(t2.claims.azp, '"'));
    }
  } else if (t2.claims.aud !== e3.aud) throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(e3.aud, '" but found "').concat(t2.claims.aud, '"'));
  if (e3.nonce) {
    if (!t2.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token");
    if (t2.claims.nonce !== e3.nonce) throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "'.concat(e3.nonce, '", found "').concat(t2.claims.nonce, '"'));
  }
  if (e3.max_age && !be(t2.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
  if (null == t2.claims.exp || !be(t2.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
  if (!be(t2.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token");
  const n2 = e3.leeway || 60, o2 = new Date(e3.now || Date.now()), r2 = /* @__PURE__ */ new Date(0);
  if (r2.setUTCSeconds(t2.claims.exp + n2), o2 > r2) throw new Error("Expiration Time (exp) claim error in the ID token; current time (".concat(o2, ") is after expiration time (").concat(r2, ")"));
  if (null != t2.claims.nbf && be(t2.claims.nbf)) {
    const e4 = /* @__PURE__ */ new Date(0);
    if (e4.setUTCSeconds(t2.claims.nbf - n2), o2 < e4) throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (".concat(o2, ") is before ").concat(e4));
  }
  if (null != t2.claims.auth_time && be(t2.claims.auth_time)) {
    const r3 = /* @__PURE__ */ new Date(0);
    if (r3.setUTCSeconds(parseInt(t2.claims.auth_time) + e3.max_age + n2), o2 > r3) throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (".concat(o2, ") is after last auth at ").concat(r3));
  }
  if (e3.organization) {
    const n3 = e3.organization.trim();
    if (n3.startsWith("org_")) {
      const e4 = n3;
      if (!t2.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
      if (e4 !== t2.claims.org_id) throw new Error('Organization ID (org_id) claim mismatch in the ID token; expected "'.concat(e4, '", found "').concat(t2.claims.org_id, '"'));
    } else {
      const e4 = n3.toLowerCase();
      if (!t2.claims.org_name) throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
      if (e4 !== t2.claims.org_name) throw new Error('Organization Name (org_name) claim mismatch in the ID token; expected "'.concat(e4, '", found "').concat(t2.claims.org_name, '"'));
    }
  }
  return t2;
};
var Se = T && T.__assign || function() {
  return Se = Object.assign || function(e3) {
    for (var t2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) for (var r2 in t2 = arguments[n2]) Object.prototype.hasOwnProperty.call(t2, r2) && (e3[r2] = t2[r2]);
    return e3;
  }, Se.apply(this, arguments);
};
function Ee(e3, t2) {
  if (!t2) return "";
  var n2 = "; " + e3;
  return true === t2 ? n2 : n2 + "=" + t2;
}
function Te(e3, t2, n2) {
  return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + (function(e4) {
    if ("number" == typeof e4.expires) {
      var t3 = /* @__PURE__ */ new Date();
      t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;
    }
    return Ee("Expires", e4.expires ? e4.expires.toUTCString() : "") + Ee("Domain", e4.domain) + Ee("Path", e4.path) + Ee("Secure", e4.secure) + Ee("SameSite", e4.sameSite);
  })(n2);
}
function Ae() {
  return (function(e3) {
    for (var t2 = {}, n2 = e3 ? e3.split("; ") : [], o2 = /(%[\dA-F]{2})+/gi, r2 = 0; r2 < n2.length; r2++) {
      var i2 = n2[r2].split("="), a2 = i2.slice(1).join("=");
      '"' === a2.charAt(0) && (a2 = a2.slice(1, -1));
      try {
        t2[i2[0].replace(o2, decodeURIComponent)] = a2.replace(o2, decodeURIComponent);
      } catch (e4) {
      }
    }
    return t2;
  })(document.cookie);
}
var Pe = function(e3) {
  return Ae()[e3];
};
function Re(e3, t2, n2) {
  document.cookie = Te(e3, t2, Se({ path: "/" }, n2));
}
var Ie = Re;
var xe = function(e3, t2) {
  Re(e3, "", Se(Se({}, t2), { expires: -1 }));
};
var Oe = { get(e3) {
  const t2 = Pe(e3);
  if (void 0 !== t2) return JSON.parse(t2);
}, save(e3, t2, n2) {
  let o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true, sameSite: "none" }), (null == n2 ? void 0 : n2.daysUntilExpire) && (o2.expires = n2.daysUntilExpire), (null == n2 ? void 0 : n2.cookieDomain) && (o2.domain = n2.cookieDomain), Ie(e3, JSON.stringify(t2), o2);
}, remove(e3, t2) {
  let n2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (n2.domain = t2.cookieDomain), xe(e3, n2);
} };
var Ce = { get(e3) {
  const t2 = Oe.get(e3);
  return t2 || Oe.get("".concat("_legacy_").concat(e3));
}, save(e3, t2, n2) {
  let o2 = {};
  "https:" === window.location.protocol && (o2 = { secure: true }), (null == n2 ? void 0 : n2.daysUntilExpire) && (o2.expires = n2.daysUntilExpire), (null == n2 ? void 0 : n2.cookieDomain) && (o2.domain = n2.cookieDomain), Ie("".concat("_legacy_").concat(e3), JSON.stringify(t2), o2), Oe.save(e3, t2, n2);
}, remove(e3, t2) {
  let n2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (n2.domain = t2.cookieDomain), xe(e3, n2), Oe.remove(e3, t2), Oe.remove("".concat("_legacy_").concat(e3), t2);
} };
var je = { get(e3) {
  if ("undefined" == typeof sessionStorage) return;
  const t2 = sessionStorage.getItem(e3);
  return null != t2 ? JSON.parse(t2) : void 0;
}, save(e3, t2) {
  sessionStorage.setItem(e3, JSON.stringify(t2));
}, remove(e3) {
  sessionStorage.removeItem(e3);
} };
var De;
!(function(e3) {
  e3.Code = "code", e3.ConnectCode = "connect_code";
})(De || (De = {}));
var Ke = class {
};
function Le(e3, t2, n2) {
  var o2 = void 0 === t2 ? null : t2, r2 = (function(e4, t3) {
    var n3 = atob(e4);
    if (t3) {
      for (var o3 = new Uint8Array(n3.length), r3 = 0, i3 = n3.length; r3 < i3; ++r3) o3[r3] = n3.charCodeAt(r3);
      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));
    }
    return n3;
  })(e3, void 0 !== n2 && n2), i2 = r2.indexOf("\n", 10) + 1, a2 = r2.substring(i2) + (o2 ? "//# sourceMappingURL=" + o2 : ""), s2 = new Blob([a2], { type: "application/javascript" });
  return URL.createObjectURL(s2);
}
var Ue;
var Ne;
var We;
var ze;
var He = (Ue = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHQpe2xldHtlcnJvcjpyLGVycm9yX2Rlc2NyaXB0aW9uOnN9PXQ7cmV0dXJuIG5ldyBlKHIscyl9fWNsYXNzIHQgZXh0ZW5kcyBle2NvbnN0cnVjdG9yKGUscyl7c3VwZXIoIm1pc3NpbmdfcmVmcmVzaF90b2tlbiIsIk1pc3NpbmcgUmVmcmVzaCBUb2tlbiAoYXVkaWVuY2U6ICciLmNvbmNhdChyKGUsWyJkZWZhdWx0Il0pLCInLCBzY29wZTogJyIpLmNvbmNhdChyKHMpLCInKSIpKSx0aGlzLmF1ZGllbmNlPWUsdGhpcy5zY29wZT1zLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLHQucHJvdG90eXBlKX19ZnVuY3Rpb24gcihlKXtsZXQgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06W107cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+IiIuY29uY2F0KGUsInwiKS5jb25jYXQodCk7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jIGU9PntsZXQgcixjLHtkYXRhOnt0aW1lb3V0OmksYXV0aDphLGZldGNoVXJsOmYsZmV0Y2hPcHRpb25zOmwsdXNlRm9ybURhdGE6cCx1c2VNcnJ0Omh9LHBvcnRzOlt1XX09ZSxkPXt9O2NvbnN0e2F1ZGllbmNlOmcsc2NvcGU6eX09YXx8e307dHJ5e2NvbnN0IGU9cD8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShsLmJvZHkpOkpTT04ucGFyc2UobC5ib2R5KTtpZighZS5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1lLmdyYW50X3R5cGUpe2lmKGM9KChlLHQpPT5vW24oZSx0KV0pKGcseSksIWMmJmgpe2NvbnN0IGU9by5sYXRlc3RfcmVmcmVzaF90b2tlbix0PSgoZSx0KT0+e2NvbnN0IHI9T2JqZWN0LmtleXMobykuZmluZCgocj0+e2lmKCJsYXRlc3RfcmVmcmVzaF90b2tlbiIhPT1yKXtjb25zdCBzPSgoZSx0KT0+dC5zdGFydHNXaXRoKCIiLmNvbmNhdChlLCJ8IikpKSh0LHIpLG89ci5zcGxpdCgifCIpWzFdLnNwbGl0KCIgIiksbj1lLnNwbGl0KCIgIikuZXZlcnkoKGU9Pm8uaW5jbHVkZXMoZSkpKTtyZXR1cm4gcyYmbn19KSk7cmV0dXJuISFyfSkoeSxnKTtlJiYhdCYmKGM9ZSl9aWYoIWMpdGhyb3cgbmV3IHQoZyx5KTtsLmJvZHk9cD9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7cmVmcmVzaF90b2tlbjpjfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7cmVmcmVzaF90b2tlbjpjfSkpfWxldCBhLGs7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGE9bmV3IEFib3J0Q29udHJvbGxlcixsLnNpZ25hbD1hLnNpZ25hbCk7dHJ5e2s9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaj1pLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaikpKSksZmV0Y2goZixPYmplY3QuYXNzaWduKHt9LGwpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIHUucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFrKXJldHVybiBhJiZhLmFib3J0KCksdm9pZCB1LnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO189ay5oZWFkZXJzLGQ9Wy4uLl9dLnJlZHVjZSgoKGUsdCk9PntsZXRbcixzXT10O3JldHVybiBlW3JdPXMsZX0pLHt9KSxyPWF3YWl0IGsuanNvbigpLHIucmVmcmVzaF90b2tlbj8oaCYmKG8ubGF0ZXN0X3JlZnJlc2hfdG9rZW49ci5yZWZyZXNoX3Rva2VuLE89YyxiPXIucmVmcmVzaF90b2tlbixPYmplY3QuZW50cmllcyhvKS5mb3JFYWNoKChlPT57bGV0W3Qscl09ZTtyPT09TyYmKG9bdF09Yil9KSkpLCgoZSx0LHIpPT57b1tuKHQscildPWV9KShyLnJlZnJlc2hfdG9rZW4sZyx5KSxkZWxldGUgci5yZWZyZXNoX3Rva2VuKTooKGUsdCk9PntkZWxldGUgb1tuKGUsdCldfSkoZyx5KSx1LnBvc3RNZXNzYWdlKHtvazprLm9rLGpzb246cixoZWFkZXJzOmR9KX1jYXRjaChlKXt1LnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcjplLmVycm9yLGVycm9yX2Rlc2NyaXB0aW9uOmUubWVzc2FnZX0saGVhZGVyczpkfSl9dmFyIE8sYixfLGp9KSl9KCk7Cgo=", Ne = null, We = false, function(e3) {
  return ze = ze || Le(Ue, Ne, We), new Worker(ze, e3);
});
var Me = {};
var Je = class {
  constructor(e3, t2) {
    this.cache = e3, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);
  }
  async add(e3) {
    var t2;
    const n2 = new Set((null === (t2 = await this.cache.get(this.manifestKey)) || void 0 === t2 ? void 0 : t2.keys) || []);
    n2.add(e3), await this.cache.set(this.manifestKey, { keys: [...n2] });
  }
  async remove(e3) {
    const t2 = await this.cache.get(this.manifestKey);
    if (t2) {
      const n2 = new Set(t2.keys);
      return n2.delete(e3), n2.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...n2] }) : await this.cache.remove(this.manifestKey);
    }
  }
  get() {
    return this.cache.get(this.manifestKey);
  }
  clear() {
    return this.cache.remove(this.manifestKey);
  }
  createManifestKeyFrom(e3) {
    return "".concat("@@auth0spajs@@", "::").concat(e3);
  }
};
var Ve = { memory: () => new we().enclosedCache, localstorage: () => new ye() };
var Fe = (e3) => Ve[e3];
var Ge = (t2) => {
  const { openUrl: n2, onRedirect: o2 } = t2, r2 = e(t2, ["openUrl", "onRedirect"]);
  return Object.assign(Object.assign({}, r2), { openUrl: false === n2 || n2 ? n2 : o2 });
};
var Ze = (e3, t2) => {
  const n2 = (null == t2 ? void 0 : t2.split(" ")) || [];
  return ((null == e3 ? void 0 : e3.split(" ")) || []).every(((e4) => n2.includes(e4)));
};
var qe = { NONCE: "nonce", KEYPAIR: "keypair" };
var Be = class {
  constructor(e3) {
    this.clientId = e3;
  }
  getVersion() {
    return 1;
  }
  createDbHandle() {
    const e3 = window.indexedDB.open("auth0-spa-js", this.getVersion());
    return new Promise(((t2, n2) => {
      e3.onupgradeneeded = () => Object.values(qe).forEach(((t3) => e3.result.createObjectStore(t3))), e3.onerror = () => n2(e3.error), e3.onsuccess = () => t2(e3.result);
    }));
  }
  async getDbHandle() {
    return this.dbHandle || (this.dbHandle = await this.createDbHandle()), this.dbHandle;
  }
  async executeDbRequest(e3, t2, n2) {
    const o2 = n2((await this.getDbHandle()).transaction(e3, t2).objectStore(e3));
    return new Promise(((e4, t3) => {
      o2.onsuccess = () => e4(o2.result), o2.onerror = () => t3(o2.error);
    }));
  }
  buildKey(e3) {
    const t2 = e3 ? "_".concat(e3) : "auth0";
    return "".concat(this.clientId, "::").concat(t2);
  }
  setNonce(e3, t2) {
    return this.save(qe.NONCE, this.buildKey(t2), e3);
  }
  setKeyPair(e3) {
    return this.save(qe.KEYPAIR, this.buildKey(), e3);
  }
  async save(e3, t2, n2) {
    await this.executeDbRequest(e3, "readwrite", ((e4) => e4.put(n2, t2)));
  }
  findNonce(e3) {
    return this.find(qe.NONCE, this.buildKey(e3));
  }
  findKeyPair() {
    return this.find(qe.KEYPAIR, this.buildKey());
  }
  find(e3, t2) {
    return this.executeDbRequest(e3, "readonly", ((e4) => e4.get(t2)));
  }
  async deleteBy(e3, t2) {
    const n2 = await this.executeDbRequest(e3, "readonly", ((e4) => e4.getAllKeys()));
    null == n2 || n2.filter(t2).map(((t3) => this.executeDbRequest(e3, "readwrite", ((e4) => e4.delete(t3)))));
  }
  deleteByClientId(e3, t2) {
    return this.deleteBy(e3, ((e4) => "string" == typeof e4 && e4.startsWith("".concat(t2, "::"))));
  }
  clearNonces() {
    return this.deleteByClientId(qe.NONCE, this.clientId);
  }
  clearKeyPairs() {
    return this.deleteByClientId(qe.KEYPAIR, this.clientId);
  }
};
var Xe = class {
  constructor(e3) {
    this.storage = new Be(e3);
  }
  getNonce(e3) {
    return this.storage.findNonce(e3);
  }
  setNonce(e3, t2) {
    return this.storage.setNonce(e3, t2);
  }
  async getOrGenerateKeyPair() {
    let e3 = await this.storage.findKeyPair();
    return e3 || (e3 = await oe(), await this.storage.setKeyPair(e3)), e3;
  }
  async generateProof(e3) {
    const t2 = await this.getOrGenerateKeyPair();
    return ie(Object.assign({ keyPair: t2 }, e3));
  }
  async calculateThumbprint() {
    return re(await this.getOrGenerateKeyPair());
  }
  async clear() {
    await Promise.all([this.storage.clearNonces(), this.storage.clearKeyPairs()]);
  }
};
var Ye;
!(function(e3) {
  e3.Bearer = "Bearer", e3.DPoP = "DPoP";
})(Ye || (Ye = {}));
var Qe = class {
  constructor(e3, t2) {
    this.hooks = t2, this.config = Object.assign(Object.assign({}, e3), { fetch: e3.fetch || ("undefined" == typeof window ? fetch : window.fetch.bind(window)) });
  }
  isAbsoluteUrl(e3) {
    return /^(https?:)?\/\//i.test(e3);
  }
  buildUrl(e3, t2) {
    if (t2) {
      if (this.isAbsoluteUrl(t2)) return t2;
      if (e3) return "".concat(e3.replace(/\/?\/$/, ""), "/").concat(t2.replace(/^\/+/, ""));
    }
    throw new TypeError("`url` must be absolute or `baseUrl` non-empty.");
  }
  getAccessToken(e3) {
    return this.config.getAccessToken ? this.config.getAccessToken(e3) : this.hooks.getAccessToken(e3);
  }
  extractUrl(e3) {
    return "string" == typeof e3 ? e3 : e3 instanceof URL ? e3.href : e3.url;
  }
  buildBaseRequest(e3, t2) {
    if (!this.config.baseUrl) return new Request(e3, t2);
    const n2 = this.buildUrl(this.config.baseUrl, this.extractUrl(e3)), o2 = e3 instanceof Request ? new Request(n2, e3) : n2;
    return new Request(o2, t2);
  }
  setAuthorizationHeader(e3, t2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ye.Bearer;
    e3.headers.set("authorization", "".concat(n2, " ").concat(t2));
  }
  async setDpopProofHeader(e3, t2) {
    if (!this.config.dpopNonceId) return;
    const n2 = await this.hooks.getDpopNonce(), o2 = await this.hooks.generateDpopProof({ accessToken: t2, method: e3.method, nonce: n2, url: e3.url });
    e3.headers.set("dpop", o2);
  }
  async prepareRequest(e3, t2) {
    const n2 = await this.getAccessToken(t2);
    let o2, r2;
    "string" == typeof n2 ? (o2 = this.config.dpopNonceId ? Ye.DPoP : Ye.Bearer, r2 = n2) : (o2 = n2.token_type, r2 = n2.access_token), this.setAuthorizationHeader(e3, r2, o2), o2 === Ye.DPoP && await this.setDpopProofHeader(e3, r2);
  }
  getHeader(e3, t2) {
    return Array.isArray(e3) ? new Headers(e3).get(t2) || "" : "function" == typeof e3.get ? e3.get(t2) || "" : e3[t2] || "";
  }
  hasUseDpopNonceError(e3) {
    if (401 !== e3.status) return false;
    const t2 = this.getHeader(e3.headers, "www-authenticate");
    return t2.includes("invalid_dpop_nonce") || t2.includes("use_dpop_nonce");
  }
  async handleResponse(e3, t2) {
    const n2 = this.getHeader(e3.headers, "dpop-nonce");
    if (n2 && await this.hooks.setDpopNonce(n2), !this.hasUseDpopNonceError(e3)) return e3;
    if (!n2 || !t2.onUseDpopNonceError) throw new f(n2);
    return t2.onUseDpopNonceError();
  }
  async internalFetchWithAuth(e3, t2, n2, o2) {
    const r2 = this.buildBaseRequest(e3, t2);
    await this.prepareRequest(r2, o2);
    const i2 = await this.config.fetch(r2);
    return this.handleResponse(i2, n2);
  }
  fetchWithAuth(e3, t2, n2) {
    const o2 = { onUseDpopNonceError: () => this.internalFetchWithAuth(e3, t2, Object.assign(Object.assign({}, o2), { onUseDpopNonceError: void 0 }), n2) };
    return this.internalFetchWithAuth(e3, t2, o2, n2);
  }
};
var $e = class {
  constructor(e3, t2) {
    this.myAccountFetcher = e3, this.apiBase = t2;
  }
  async connectAccount(e3) {
    const t2 = await this.myAccountFetcher.fetchWithAuth("".concat(this.apiBase, "v1/connected-accounts/connect"), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(e3) });
    return this._handleResponse(t2);
  }
  async completeAccount(e3) {
    const t2 = await this.myAccountFetcher.fetchWithAuth("".concat(this.apiBase, "v1/connected-accounts/complete"), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(e3) });
    return this._handleResponse(t2);
  }
  async _handleResponse(e3) {
    let t2;
    try {
      t2 = await e3.text(), t2 = JSON.parse(t2);
    } catch (n2) {
      throw new et({ type: "invalid_json", status: e3.status, title: "Invalid JSON response", detail: t2 || String(n2) });
    }
    if (e3.ok) return t2;
    throw new et(t2);
  }
};
var et = class _et extends Error {
  constructor(e3) {
    let { type: t2, status: n2, title: o2, detail: r2, validation_errors: i2 } = e3;
    super(r2), this.name = "MyAccountApiError", this.type = t2, this.status = n2, this.title = o2, this.detail = r2, this.validation_errors = i2, Object.setPrototypeOf(this, _et.prototype);
  }
};
var tt = { otp: { authenticatorTypes: ["otp"] }, sms: { authenticatorTypes: ["oob"], oobChannels: ["sms"] }, email: { authenticatorTypes: ["oob"], oobChannels: ["email"] }, push: { authenticatorTypes: ["oob"], oobChannels: ["auth0"] }, voice: { authenticatorTypes: ["oob"], oobChannels: ["voice"] } };
var nt = "http://auth0.com/oauth/grant-type/mfa-otp";
var ot = "http://auth0.com/oauth/grant-type/mfa-oob";
var rt = "http://auth0.com/oauth/grant-type/mfa-recovery-code";
function it(e3, t2) {
  this.v = e3, this.k = t2;
}
function at(e3, t2, n2) {
  if ("function" == typeof e3 ? e3 === t2 : e3.has(t2)) return arguments.length < 3 ? t2 : n2;
  throw new TypeError("Private element is not present on this object");
}
function st(e3) {
  return new it(e3, 0);
}
function ct(e3, t2) {
  if (t2.has(e3)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ut(e3, t2) {
  return e3.get(at(e3, t2));
}
function lt(e3, t2, n2) {
  ct(e3, t2), t2.set(e3, n2);
}
function dt(e3, t2, n2) {
  return e3.set(at(e3, t2), n2), n2;
}
function ht(e3, t2, n2) {
  return (t2 = (function(e4) {
    var t3 = (function(e5, t4) {
      if ("object" != typeof e5 || !e5) return e5;
      var n3 = e5[Symbol.toPrimitive];
      if (void 0 !== n3) {
        var o2 = n3.call(e5, t4 || "default");
        if ("object" != typeof o2) return o2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t4 ? String : Number)(e5);
    })(e4, "string");
    return "symbol" == typeof t3 ? t3 : t3 + "";
  })(t2)) in e3 ? Object.defineProperty(e3, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t2] = n2, e3;
}
function pt(e3, t2) {
  var n2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    t2 && (o2 = o2.filter((function(t3) {
      return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
    }))), n2.push.apply(n2, o2);
  }
  return n2;
}
function ft(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? pt(Object(n2), true).forEach((function(t3) {
      ht(e3, t3, n2[t3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : pt(Object(n2)).forEach((function(t3) {
      Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(n2, t3));
    }));
  }
  return e3;
}
function mt(e3, t2) {
  if (null == e3) return {};
  var n2, o2, r2 = (function(e4, t3) {
    if (null == e4) return {};
    var n3 = {};
    for (var o3 in e4) if ({}.hasOwnProperty.call(e4, o3)) {
      if (-1 !== t3.indexOf(o3)) continue;
      n3[o3] = e4[o3];
    }
    return n3;
  })(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var i2 = Object.getOwnPropertySymbols(e3);
    for (o2 = 0; o2 < i2.length; o2++) n2 = i2[o2], -1 === t2.indexOf(n2) && {}.propertyIsEnumerable.call(e3, n2) && (r2[n2] = e3[n2]);
  }
  return r2;
}
function yt(e3) {
  return function() {
    return new wt(e3.apply(this, arguments));
  };
}
function wt(e3) {
  var t2, n2;
  function o2(t3, n3) {
    try {
      var i2 = e3[t3](n3), a2 = i2.value, s2 = a2 instanceof it;
      Promise.resolve(s2 ? a2.v : a2).then((function(n4) {
        if (s2) {
          var c2 = "return" === t3 ? "return" : "next";
          if (!a2.k || n4.done) return o2(c2, n4);
          n4 = e3[c2](n4).value;
        }
        r2(i2.done ? "return" : "normal", n4);
      }), (function(e4) {
        o2("throw", e4);
      }));
    } catch (e4) {
      r2("throw", e4);
    }
  }
  function r2(e4, r3) {
    switch (e4) {
      case "return":
        t2.resolve({ value: r3, done: true });
        break;
      case "throw":
        t2.reject(r3);
        break;
      default:
        t2.resolve({ value: r3, done: false });
    }
    (t2 = t2.next) ? o2(t2.key, t2.arg) : n2 = null;
  }
  this._invoke = function(e4, r3) {
    return new Promise((function(i2, a2) {
      var s2 = { key: e4, arg: r3, resolve: i2, reject: a2, next: null };
      n2 ? n2 = n2.next = s2 : (t2 = n2 = s2, o2(e4, r3));
    }));
  }, "function" != typeof e3.return && (this.return = void 0);
}
var gt;
var vt;
var bt;
if (wt.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
  return this;
}, wt.prototype.next = function(e3) {
  return this._invoke("next", e3);
}, wt.prototype.throw = function(e3) {
  return this._invoke("throw", e3);
}, wt.prototype.return = function(e3) {
  return this._invoke("return", e3);
}, "undefined" == typeof navigator || null === (gt = navigator.userAgent) || void 0 === gt || null === (vt = gt.startsWith) || void 0 === vt || !vt.call(gt, "Mozilla/5.0 ")) {
  const e3 = "v3.8.3";
  bt = "".concat("oauth4webapi", "/").concat(e3);
}
function _t(e3, t2) {
  if (null == e3) return false;
  try {
    return e3 instanceof t2 || Object.getPrototypeOf(e3)[Symbol.toStringTag] === t2.prototype[Symbol.toStringTag];
  } catch (e4) {
    return false;
  }
}
function kt(e3, t2, n2) {
  const o2 = new TypeError(e3, { cause: n2 });
  return Object.assign(o2, { code: t2 }), o2;
}
var St = Symbol();
var Et = Symbol();
var Tt = Symbol();
var At = Symbol();
var Pt = Symbol();
var Rt = Symbol();
var It = new TextEncoder();
var xt = new TextDecoder();
function Ot(e3) {
  return "string" == typeof e3 ? It.encode(e3) : xt.decode(e3);
}
var Ct;
var jt;
if (Uint8Array.prototype.toBase64) Ct = (e3) => (e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), e3.toBase64({ alphabet: "base64url", omitPadding: true }));
else {
  const e3 = 32768;
  Ct = (t2) => {
    t2 instanceof ArrayBuffer && (t2 = new Uint8Array(t2));
    const n2 = [];
    for (let o2 = 0; o2 < t2.byteLength; o2 += e3) n2.push(String.fromCharCode.apply(null, t2.subarray(o2, o2 + e3)));
    return btoa(n2.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
}
function Dt(e3) {
  return "string" == typeof e3 ? jt(e3) : Ct(e3);
}
jt = Uint8Array.fromBase64 ? (e3) => {
  try {
    return Uint8Array.fromBase64(e3, { alphabet: "base64url" });
  } catch (e4) {
    throw kt("The input to be decoded is not correctly encoded.", "ERR_INVALID_ARG_VALUE", e4);
  }
} : (e3) => {
  try {
    const t2 = atob(e3.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")), n2 = new Uint8Array(t2.length);
    for (let e4 = 0; e4 < t2.length; e4++) n2[e4] = t2.charCodeAt(e4);
    return n2;
  } catch (e4) {
    throw kt("The input to be decoded is not correctly encoded.", "ERR_INVALID_ARG_VALUE", e4);
  }
};
var Kt = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "code", void 0), this.name = this.constructor.name, this.code = Kn, null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
var Lt = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "code", void 0), this.name = this.constructor.name, null != t2 && t2.code && (this.code = null == t2 ? void 0 : t2.code), null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
function Ut(e3, t2, n2) {
  return new Lt(e3, { code: t2, cause: n2 });
}
function Nt(e3, t2) {
  if ((function(e4, t3) {
    if (!(e4 instanceof CryptoKey)) throw kt("".concat(t3, " must be a CryptoKey"), "ERR_INVALID_ARG_TYPE");
  })(e3, t2), "private" !== e3.type) throw kt("".concat(t2, " must be a private CryptoKey"), "ERR_INVALID_ARG_VALUE");
}
function Wt(e3) {
  return null !== e3 && "object" == typeof e3 && !Array.isArray(e3);
}
function zt(e3) {
  _t(e3, Headers) && (e3 = Object.fromEntries(e3.entries()));
  const t2 = new Headers(null != e3 ? e3 : {});
  if (bt && !t2.has("user-agent") && t2.set("user-agent", bt), t2.has("authorization")) throw kt('"options.headers" must not include the "authorization" header name', "ERR_INVALID_ARG_VALUE");
  return t2;
}
function Ht(e3, t2) {
  if (void 0 !== t2) {
    if ("function" == typeof t2 && (t2 = t2(e3.href)), !(t2 instanceof AbortSignal)) throw kt('"options.signal" must return or be an instance of AbortSignal', "ERR_INVALID_ARG_TYPE");
    return t2;
  }
}
function Mt(e3) {
  return e3.includes("//") ? e3.replace("//", "/") : e3;
}
async function Jt(e3, t2) {
  return (async function(e4, t3, n2, o2) {
    if (!(e4 instanceof URL)) throw kt('"'.concat(t3, '" must be an instance of URL'), "ERR_INVALID_ARG_TYPE");
    on(e4, true !== (null == o2 ? void 0 : o2[St]));
    const r2 = n2(new URL(e4.href)), i2 = zt(null == o2 ? void 0 : o2.headers);
    return i2.set("accept", "application/json"), ((null == o2 ? void 0 : o2[At]) || fetch)(r2.href, { body: void 0, headers: Object.fromEntries(i2.entries()), method: "GET", redirect: "manual", signal: Ht(r2, null == o2 ? void 0 : o2.signal) });
  })(e3, "issuerIdentifier", ((e4) => {
    switch (null == t2 ? void 0 : t2.algorithm) {
      case void 0:
      case "oidc":
        !(function(e5, t3) {
          e5.pathname = Mt("".concat(e5.pathname, "/").concat(t3));
        })(e4, ".well-known/openid-configuration");
        break;
      case "oauth2":
        !(function(e5, t3) {
          let n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          "/" === e5.pathname ? e5.pathname = t3 : e5.pathname = Mt("".concat(t3, "/").concat(n2 ? e5.pathname : e5.pathname.replace(/(\/)$/, "")));
        })(e4, ".well-known/oauth-authorization-server");
        break;
      default:
        throw kt('"options.algorithm" must be "oidc" (default), or "oauth2"', "ERR_INVALID_ARG_VALUE");
    }
    return e4;
  }), t2);
}
function Vt(e3, t2, n2, o2, r2) {
  try {
    if ("number" != typeof e3 || !Number.isFinite(e3)) throw kt("".concat(n2, " must be a number"), "ERR_INVALID_ARG_TYPE", r2);
    if (e3 > 0) return;
    if (t2) {
      if (0 !== e3) throw kt("".concat(n2, " must be a non-negative number"), "ERR_INVALID_ARG_VALUE", r2);
      return;
    }
    throw kt("".concat(n2, " must be a positive number"), "ERR_INVALID_ARG_VALUE", r2);
  } catch (e4) {
    if (o2) throw Ut(e4.message, o2, r2);
    throw e4;
  }
}
function Ft(e3, t2, n2, o2) {
  try {
    if ("string" != typeof e3) throw kt("".concat(t2, " must be a string"), "ERR_INVALID_ARG_TYPE", o2);
    if (0 === e3.length) throw kt("".concat(t2, " must not be empty"), "ERR_INVALID_ARG_VALUE", o2);
  } catch (e4) {
    if (n2) throw Ut(e4.message, n2, o2);
    throw e4;
  }
}
function Gt(e3) {
  !(function(e4, t2) {
    if (wn(e4) !== t2) throw (function(e5) {
      let t3 = '"response" content-type must be ';
      for (var n2 = arguments.length, o2 = new Array(n2 > 1 ? n2 - 1 : 0), r2 = 1; r2 < n2; r2++) o2[r2 - 1] = arguments[r2];
      if (o2.length > 2) {
        const e6 = o2.pop();
        t3 += "".concat(o2.join(", "), ", or ").concat(e6);
      } else 2 === o2.length ? t3 += "".concat(o2[0], " or ").concat(o2[1]) : t3 += o2[0];
      return Ut(t3, Wn, e5);
    })(e4, t2);
  })(e3, "application/json");
}
function Zt() {
  return Dt(crypto.getRandomValues(new Uint8Array(32)));
}
function qt(e3) {
  switch (e3.algorithm.name) {
    case "RSA-PSS":
      return (function(e4) {
        switch (e4.algorithm.hash.name) {
          case "SHA-256":
            return "PS256";
          case "SHA-384":
            return "PS384";
          case "SHA-512":
            return "PS512";
          default:
            throw new Kt("unsupported RsaHashedKeyAlgorithm hash name", { cause: e4 });
        }
      })(e3);
    case "RSASSA-PKCS1-v1_5":
      return (function(e4) {
        switch (e4.algorithm.hash.name) {
          case "SHA-256":
            return "RS256";
          case "SHA-384":
            return "RS384";
          case "SHA-512":
            return "RS512";
          default:
            throw new Kt("unsupported RsaHashedKeyAlgorithm hash name", { cause: e4 });
        }
      })(e3);
    case "ECDSA":
      return (function(e4) {
        switch (e4.algorithm.namedCurve) {
          case "P-256":
            return "ES256";
          case "P-384":
            return "ES384";
          case "P-521":
            return "ES512";
          default:
            throw new Kt("unsupported EcKeyAlgorithm namedCurve", { cause: e4 });
        }
      })(e3);
    case "Ed25519":
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return e3.algorithm.name;
    case "EdDSA":
      return "Ed25519";
    default:
      throw new Kt("unsupported CryptoKey algorithm name", { cause: e3 });
  }
}
function Bt(e3) {
  const t2 = null == e3 ? void 0 : e3[Et];
  return "number" == typeof t2 && Number.isFinite(t2) ? t2 : 0;
}
function Xt(e3) {
  const t2 = null == e3 ? void 0 : e3[Tt];
  return "number" == typeof t2 && Number.isFinite(t2) && -1 !== Math.sign(t2) ? t2 : 30;
}
function Yt() {
  return Math.floor(Date.now() / 1e3);
}
function Qt(e3) {
  if ("object" != typeof e3 || null === e3) throw kt('"as" must be an object', "ERR_INVALID_ARG_TYPE");
  Ft(e3.issuer, '"as.issuer"');
}
function $t(e3) {
  if ("object" != typeof e3 || null === e3) throw kt('"client" must be an object', "ERR_INVALID_ARG_TYPE");
  Ft(e3.client_id, '"client.client_id"');
}
function en(e3) {
  return Ft(e3, '"clientSecret"'), (t2, n2, o2, r2) => {
    o2.set("client_id", n2.client_id), o2.set("client_secret", e3);
  };
}
function tn(e3, t2) {
  const { key: n2, kid: o2 } = (r2 = e3) instanceof CryptoKey ? { key: r2 } : (null == r2 ? void 0 : r2.key) instanceof CryptoKey ? (void 0 !== r2.kid && Ft(r2.kid, '"kid"'), { key: r2.key, kid: r2.kid }) : {};
  var r2;
  return Nt(n2, '"clientPrivateKey.key"'), async (e4, r3, i2, a2) => {
    var s2;
    const c2 = { alg: qt(n2), kid: o2 }, u2 = (function(e5, t3) {
      const n3 = Yt() + Bt(t3);
      return { jti: Zt(), aud: e5.issuer, exp: n3 + 60, iat: n3, nbf: n3, iss: t3.client_id, sub: t3.client_id };
    })(e4, r3);
    null == t2 || null === (s2 = t2[Pt]) || void 0 === s2 || s2.call(t2, c2, u2), i2.set("client_id", r3.client_id), i2.set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"), i2.set("client_assertion", await (async function(e5, t3, n3) {
      if (!n3.usages.includes("sign")) throw kt('CryptoKey instances used for signing assertions must include "sign" in their "usages"', "ERR_INVALID_ARG_VALUE");
      const o3 = "".concat(Dt(Ot(JSON.stringify(e5))), ".").concat(Dt(Ot(JSON.stringify(t3)))), r4 = Dt(await crypto.subtle.sign((function(e6) {
        switch (e6.algorithm.name) {
          case "ECDSA":
            return { name: e6.algorithm.name, hash: Xn(e6) };
          case "RSA-PSS":
            switch (Bn(e6), e6.algorithm.hash.name) {
              case "SHA-256":
              case "SHA-384":
              case "SHA-512":
                return { name: e6.algorithm.name, saltLength: parseInt(e6.algorithm.hash.name.slice(-3), 10) >> 3 };
              default:
                throw new Kt("unsupported RSA-PSS hash name", { cause: e6 });
            }
          case "RSASSA-PKCS1-v1_5":
            return Bn(e6), e6.algorithm.name;
          case "ML-DSA-44":
          case "ML-DSA-65":
          case "ML-DSA-87":
          case "Ed25519":
            return e6.algorithm.name;
        }
        throw new Kt("unsupported CryptoKey algorithm name", { cause: e6 });
      })(n3), n3, Ot(o3)));
      return "".concat(o3, ".").concat(r4);
    })(c2, u2, n2));
  };
}
var nn = URL.parse ? (e3, t2) => URL.parse(e3, t2) : (e3, t2) => {
  try {
    return new URL(e3, t2);
  } catch (e4) {
    return null;
  }
};
function on(e3, t2) {
  if (t2 && "https:" !== e3.protocol) throw Ut("only requests to HTTPS are allowed", Hn, e3);
  if ("https:" !== e3.protocol && "http:" !== e3.protocol) throw Ut("only HTTP and HTTPS requests are allowed", Mn, e3);
}
function rn(e3, t2, n2, o2) {
  let r2;
  if ("string" != typeof e3 || !(r2 = nn(e3))) throw Ut("authorization server metadata does not contain a valid ".concat(n2 ? '"as.mtls_endpoint_aliases.'.concat(t2, '"') : '"as.'.concat(t2, '"')), void 0 === e3 ? Gn : Zn, { attribute: n2 ? "mtls_endpoint_aliases.".concat(t2) : t2 });
  return on(r2, o2), r2;
}
function an(e3, t2, n2, o2) {
  return n2 && e3.mtls_endpoint_aliases && t2 in e3.mtls_endpoint_aliases ? rn(e3.mtls_endpoint_aliases[t2], t2, n2, o2) : rn(e3[t2], t2, n2, o2);
}
var sn = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "cause", void 0), ht(this, "code", void 0), ht(this, "error", void 0), ht(this, "status", void 0), ht(this, "error_description", void 0), ht(this, "response", void 0), this.name = this.constructor.name, this.code = Dn, this.cause = t2.cause, this.error = t2.cause.error, this.status = t2.response.status, this.error_description = t2.cause.error_description, Object.defineProperty(this, "response", { enumerable: false, value: t2.response }), null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
var cn = class extends Error {
  constructor(e3, t2) {
    var n2, o2;
    super(e3, t2), ht(this, "cause", void 0), ht(this, "code", void 0), ht(this, "error", void 0), ht(this, "error_description", void 0), this.name = this.constructor.name, this.code = Ln, this.cause = t2.cause, this.error = t2.cause.get("error"), this.error_description = null !== (n2 = t2.cause.get("error_description")) && void 0 !== n2 ? n2 : void 0, null === (o2 = Error.captureStackTrace) || void 0 === o2 || o2.call(Error, this, this.constructor);
  }
};
var un = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "cause", void 0), ht(this, "code", void 0), ht(this, "response", void 0), ht(this, "status", void 0), this.name = this.constructor.name, this.code = jn, this.cause = t2.cause, this.status = t2.response.status, this.response = t2.response, Object.defineProperty(this, "response", { enumerable: false }), null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
var ln = "[a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+";
var dn = new RegExp("^[,\\s]*(" + ln + ")");
var hn = new RegExp('^[,\\s]*([a-zA-Z0-9!#$%&\\\'\\*\\+\\-\\.\\^_`\\|~]+)\\s*=\\s*"((?:[^"\\\\]|\\\\[\\s\\S])*)"[,\\s]*(.*)');
var pn = new RegExp("^[,\\s]*([a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+)\\s*=\\s*([a-zA-Z0-9!#$%&\\'\\*\\+\\-\\.\\^_`\\|~]+)[,\\s]*(.*)");
var fn = new RegExp("^([a-zA-Z0-9\\-\\._\\~\\+\\/]+={0,2})(?:$|[,\\s])(.*)");
async function mn(e3, t2, n2) {
  if (e3.status !== t2) {
    let t3;
    var o2;
    if ((function(e4) {
      let t4;
      if (t4 = (function(e5) {
        if (!_t(e5, Response)) throw kt('"response" must be an instance of Response', "ERR_INVALID_ARG_TYPE");
        const t5 = e5.headers.get("www-authenticate");
        if (null === t5) return;
        const n3 = [];
        let o3 = t5;
        for (; o3; ) {
          var r2;
          let e6 = o3.match(dn);
          const t6 = null === (r2 = e6) || void 0 === r2 ? void 0 : r2[1].toLowerCase();
          if (!t6) return;
          const i2 = o3.substring(e6[0].length);
          if (i2 && !i2.match(/^[\s,]/)) return;
          const a2 = i2.match(/^\s+(.*)$/), s2 = !!a2;
          o3 = a2 ? a2[1] : void 0;
          const c2 = {};
          let u2;
          if (s2) for (; o3; ) {
            let t7, n4;
            if (e6 = o3.match(hn)) {
              if ([, t7, n4, o3] = e6, n4.includes("\\")) try {
                n4 = JSON.parse('"'.concat(n4, '"'));
              } catch (e7) {
              }
              c2[t7.toLowerCase()] = n4;
            } else {
              if (!(e6 = o3.match(pn))) {
                if (e6 = o3.match(fn)) {
                  if (Object.keys(c2).length) break;
                  [, u2, o3] = e6;
                  break;
                }
                return;
              }
              [, t7, n4, o3] = e6, c2[t7.toLowerCase()] = n4;
            }
          }
          else o3 = i2 || void 0;
          const l2 = { scheme: t6, parameters: c2 };
          u2 && (l2.token68 = u2), n3.push(l2);
        }
        return n3.length ? n3 : void 0;
      })(e4)) throw new un("server responded with a challenge in the WWW-Authenticate HTTP Header", { cause: t4, response: e4 });
    })(e3), t3 = await (async function(e4) {
      if (e4.status > 399 && e4.status < 500) {
        qn(e4), Gt(e4);
        try {
          const t4 = await e4.clone().json();
          if (Wt(t4) && "string" == typeof t4.error && t4.error.length) return t4;
        } catch (e5) {
        }
      }
    })(e3)) throw await (null === (o2 = e3.body) || void 0 === o2 ? void 0 : o2.cancel()), new sn("server responded with an error in the response body", { cause: t3, response: e3 });
    throw Ut('"response" is not a conform '.concat(n2, " response (unexpected HTTP status code)"), zn, e3);
  }
}
function yn(e3) {
  if (!An.has(e3)) throw kt('"options.DPoP" is not a valid DPoPHandle', "ERR_INVALID_ARG_VALUE");
}
function wn(e3) {
  var t2;
  return null === (t2 = e3.headers.get("content-type")) || void 0 === t2 ? void 0 : t2.split(";")[0];
}
async function gn(e3, t2, n2, o2, r2, i2, a2) {
  return await n2(e3, t2, r2, i2), i2.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), ((null == a2 ? void 0 : a2[At]) || fetch)(o2.href, { body: r2, headers: Object.fromEntries(i2.entries()), method: "POST", redirect: "manual", signal: Ht(o2, null == a2 ? void 0 : a2.signal) });
}
async function vn(e3, t2, n2, o2, r2, i2) {
  var a2;
  const s2 = an(e3, "token_endpoint", t2.use_mtls_endpoint_aliases, true !== (null == i2 ? void 0 : i2[St]));
  r2.set("grant_type", o2);
  const c2 = zt(null == i2 ? void 0 : i2.headers);
  c2.set("accept", "application/json"), void 0 !== (null == i2 ? void 0 : i2.DPoP) && (yn(i2.DPoP), await i2.DPoP.addProof(s2, c2, "POST"));
  const u2 = await gn(e3, t2, n2, s2, r2, c2, i2);
  return null == i2 || null === (a2 = i2.DPoP) || void 0 === a2 || a2.cacheNonce(u2, s2), u2;
}
var bn = /* @__PURE__ */ new WeakMap();
var _n = /* @__PURE__ */ new WeakMap();
function kn(e3) {
  if (!e3.id_token) return;
  const t2 = bn.get(e3);
  if (!t2) throw kt('"ref" was already garbage collected or did not resolve from the proper sources', "ERR_INVALID_ARG_VALUE");
  return t2;
}
async function Sn(e3, t2, n2, o2, r2, i2) {
  if (Qt(e3), $t(t2), !_t(n2, Response)) throw kt('"response" must be an instance of Response', "ERR_INVALID_ARG_TYPE");
  await mn(n2, 200, "Token Endpoint"), qn(n2);
  const a2 = await oo(n2);
  if (Ft(a2.access_token, '"response" body "access_token" property', Nn, { body: a2 }), Ft(a2.token_type, '"response" body "token_type" property', Nn, { body: a2 }), a2.token_type = a2.token_type.toLowerCase(), void 0 !== a2.expires_in) {
    let e4 = "number" != typeof a2.expires_in ? parseFloat(a2.expires_in) : a2.expires_in;
    Vt(e4, true, '"response" body "expires_in" property', Nn, { body: a2 }), a2.expires_in = e4;
  }
  if (void 0 !== a2.refresh_token && Ft(a2.refresh_token, '"response" body "refresh_token" property', Nn, { body: a2 }), void 0 !== a2.scope && "string" != typeof a2.scope) throw Ut('"response" body "scope" property must be a string', Nn, { body: a2 });
  if (void 0 !== a2.id_token) {
    Ft(a2.id_token, '"response" body "id_token" property', Nn, { body: a2 });
    const i3 = ["aud", "exp", "iat", "iss", "sub"];
    true === t2.require_auth_time && i3.push("auth_time"), void 0 !== t2.default_max_age && (Vt(t2.default_max_age, true, '"client.default_max_age"'), i3.push("auth_time")), null != o2 && o2.length && i3.push(...o2);
    const { claims: s2, jwt: c2 } = await (async function(e4, t3, n3, o3, r3) {
      let i4, a3, { 0: s3, 1: c3, length: u2 } = e4.split(".");
      if (5 === u2) {
        if (void 0 === r3) throw new Kt("JWE decryption is not configured", { cause: e4 });
        e4 = await r3(e4), { 0: s3, 1: c3, length: u2 } = e4.split(".");
      }
      if (3 !== u2) throw Ut("Invalid JWT", Nn, e4);
      try {
        i4 = JSON.parse(Ot(Dt(s3)));
      } catch (e5) {
        throw Ut("failed to parse JWT Header body as base64url encoded JSON", Un, e5);
      }
      if (!Wt(i4)) throw Ut("JWT Header must be a top level object", Nn, e4);
      if (t3(i4), void 0 !== i4.crit) throw new Kt('no JWT "crit" header parameter extensions are supported', { cause: { header: i4 } });
      try {
        a3 = JSON.parse(Ot(Dt(c3)));
      } catch (e5) {
        throw Ut("failed to parse JWT Payload body as base64url encoded JSON", Un, e5);
      }
      if (!Wt(a3)) throw Ut("JWT Payload must be a top level object", Nn, e4);
      const l2 = Yt() + n3;
      if (void 0 !== a3.exp) {
        if ("number" != typeof a3.exp) throw Ut('unexpected JWT "exp" (expiration time) claim type', Nn, { claims: a3 });
        if (a3.exp <= l2 - o3) throw Ut('unexpected JWT "exp" (expiration time) claim value, expiration is past current timestamp', Jn, { claims: a3, now: l2, tolerance: o3, claim: "exp" });
      }
      if (void 0 !== a3.iat && "number" != typeof a3.iat) throw Ut('unexpected JWT "iat" (issued at) claim type', Nn, { claims: a3 });
      if (void 0 !== a3.iss && "string" != typeof a3.iss) throw Ut('unexpected JWT "iss" (issuer) claim type', Nn, { claims: a3 });
      if (void 0 !== a3.nbf) {
        if ("number" != typeof a3.nbf) throw Ut('unexpected JWT "nbf" (not before) claim type', Nn, { claims: a3 });
        if (a3.nbf > l2 + o3) throw Ut('unexpected JWT "nbf" (not before) claim value', Jn, { claims: a3, now: l2, tolerance: o3, claim: "nbf" });
      }
      if (void 0 !== a3.aud && "string" != typeof a3.aud && !Array.isArray(a3.aud)) throw Ut('unexpected JWT "aud" (audience) claim type', Nn, { claims: a3 });
      return { header: i4, claims: a3, jwt: e4 };
    })(a2.id_token, Qn.bind(void 0, t2.id_token_signed_response_alg, e3.id_token_signing_alg_values_supported, "RS256"), Bt(t2), Xt(t2), r2).then(In.bind(void 0, i3)).then(Tn.bind(void 0, e3)).then(En.bind(void 0, t2.client_id));
    if (Array.isArray(s2.aud) && 1 !== s2.aud.length) {
      if (void 0 === s2.azp) throw Ut('ID Token "aud" (audience) claim includes additional untrusted audiences', Vn, { claims: s2, claim: "aud" });
      if (s2.azp !== t2.client_id) throw Ut('unexpected ID Token "azp" (authorized party) claim value', Vn, { expected: t2.client_id, claims: s2, claim: "azp" });
    }
    void 0 !== s2.auth_time && Vt(s2.auth_time, true, 'ID Token "auth_time" (authentication time)', Nn, { claims: s2 }), _n.set(n2, c2), bn.set(a2, s2);
  }
  if (void 0 !== (null == i2 ? void 0 : i2[a2.token_type])) i2[a2.token_type](n2, a2);
  else if ("dpop" !== a2.token_type && "bearer" !== a2.token_type) throw new Kt("unsupported `token_type` value", { cause: { body: a2 } });
  return a2;
}
function En(e3, t2) {
  if (Array.isArray(t2.claims.aud)) {
    if (!t2.claims.aud.includes(e3)) throw Ut('unexpected JWT "aud" (audience) claim value', Vn, { expected: e3, claims: t2.claims, claim: "aud" });
  } else if (t2.claims.aud !== e3) throw Ut('unexpected JWT "aud" (audience) claim value', Vn, { expected: e3, claims: t2.claims, claim: "aud" });
  return t2;
}
function Tn(e3, t2) {
  var n2, o2;
  const r2 = null !== (n2 = null === (o2 = e3[io]) || void 0 === o2 ? void 0 : o2.call(e3, t2)) && void 0 !== n2 ? n2 : e3.issuer;
  if (t2.claims.iss !== r2) throw Ut('unexpected JWT "iss" (issuer) claim value', Vn, { expected: r2, claims: t2.claims, claim: "iss" });
  return t2;
}
var An = /* @__PURE__ */ new WeakSet();
var Pn = Symbol();
var Rn = { aud: "audience", c_hash: "code hash", client_id: "client id", exp: "expiration time", iat: "issued at", iss: "issuer", jti: "jwt id", nonce: "nonce", s_hash: "state hash", sub: "subject", ath: "access token hash", htm: "http method", htu: "http uri", cnf: "confirmation", auth_time: "authentication time" };
function In(e3, t2) {
  for (const n2 of e3) if (void 0 === t2.claims[n2]) throw Ut('JWT "'.concat(n2, '" (').concat(Rn[n2], ") claim missing"), Nn, { claims: t2.claims });
  return t2;
}
var xn = Symbol();
var On = Symbol();
async function Cn(e3, t2, n2, o2) {
  return "string" == typeof (null == o2 ? void 0 : o2.expectedNonce) || "number" == typeof (null == o2 ? void 0 : o2.maxAge) || null != o2 && o2.requireIdToken ? (async function(e4, t3, n3, o3, r2, i2, a2) {
    const s2 = [];
    switch (o3) {
      case void 0:
        o3 = xn;
        break;
      case xn:
        break;
      default:
        Ft(o3, '"expectedNonce" argument'), s2.push("nonce");
    }
    switch (null != r2 || (r2 = t3.default_max_age), r2) {
      case void 0:
        r2 = On;
        break;
      case On:
        break;
      default:
        Vt(r2, true, '"maxAge" argument'), s2.push("auth_time");
    }
    const c2 = await Sn(e4, t3, n3, s2, i2, a2);
    Ft(c2.id_token, '"response" body "id_token" property', Nn, { body: c2 });
    const u2 = kn(c2);
    if (r2 !== On) {
      const e5 = Yt() + Bt(t3), n4 = Xt(t3);
      if (u2.auth_time + r2 < e5 - n4) throw Ut("too much time has elapsed since the last End-User authentication", Jn, { claims: u2, now: e5, tolerance: n4, claim: "auth_time" });
    }
    if (o3 === xn) {
      if (void 0 !== u2.nonce) throw Ut('unexpected ID Token "nonce" claim value', Vn, { expected: void 0, claims: u2, claim: "nonce" });
    } else if (u2.nonce !== o3) throw Ut('unexpected ID Token "nonce" claim value', Vn, { expected: o3, claims: u2, claim: "nonce" });
    return c2;
  })(e3, t2, n2, o2.expectedNonce, o2.maxAge, o2[Rt], o2.recognizedTokenTypes) : (async function(e4, t3, n3, o3, r2) {
    const i2 = await Sn(e4, t3, n3, void 0, o3, r2), a2 = kn(i2);
    if (a2) {
      if (void 0 !== t3.default_max_age) {
        Vt(t3.default_max_age, true, '"client.default_max_age"');
        const e5 = Yt() + Bt(t3), n4 = Xt(t3);
        if (a2.auth_time + t3.default_max_age < e5 - n4) throw Ut("too much time has elapsed since the last End-User authentication", Jn, { claims: a2, now: e5, tolerance: n4, claim: "auth_time" });
      }
      if (void 0 !== a2.nonce) throw Ut('unexpected ID Token "nonce" claim value', Vn, { expected: void 0, claims: a2, claim: "nonce" });
    }
    return i2;
  })(e3, t2, n2, null == o2 ? void 0 : o2[Rt], null == o2 ? void 0 : o2.recognizedTokenTypes);
}
var jn = "OAUTH_WWW_AUTHENTICATE_CHALLENGE";
var Dn = "OAUTH_RESPONSE_BODY_ERROR";
var Kn = "OAUTH_UNSUPPORTED_OPERATION";
var Ln = "OAUTH_AUTHORIZATION_RESPONSE_ERROR";
var Un = "OAUTH_PARSE_ERROR";
var Nn = "OAUTH_INVALID_RESPONSE";
var Wn = "OAUTH_RESPONSE_IS_NOT_JSON";
var zn = "OAUTH_RESPONSE_IS_NOT_CONFORM";
var Hn = "OAUTH_HTTP_REQUEST_FORBIDDEN";
var Mn = "OAUTH_REQUEST_PROTOCOL_FORBIDDEN";
var Jn = "OAUTH_JWT_TIMESTAMP_CHECK_FAILED";
var Vn = "OAUTH_JWT_CLAIM_COMPARISON_FAILED";
var Fn = "OAUTH_JSON_ATTRIBUTE_COMPARISON_FAILED";
var Gn = "OAUTH_MISSING_SERVER_METADATA";
var Zn = "OAUTH_INVALID_SERVER_METADATA";
function qn(e3) {
  if (e3.bodyUsed) throw kt('"response" body has been used already', "ERR_INVALID_ARG_VALUE");
}
function Bn(e3) {
  const { algorithm: t2 } = e3;
  if ("number" != typeof t2.modulusLength || t2.modulusLength < 2048) throw new Kt("unsupported ".concat(t2.name, " modulusLength"), { cause: e3 });
}
function Xn(e3) {
  const { algorithm: t2 } = e3;
  switch (t2.namedCurve) {
    case "P-256":
      return "SHA-256";
    case "P-384":
      return "SHA-384";
    case "P-521":
      return "SHA-512";
    default:
      throw new Kt("unsupported ECDSA namedCurve", { cause: e3 });
  }
}
async function Yn(e3) {
  if ("POST" !== e3.method) throw kt("form_post responses are expected to use the POST method", "ERR_INVALID_ARG_VALUE", { cause: e3 });
  if ("application/x-www-form-urlencoded" !== wn(e3)) throw kt("form_post responses are expected to use the application/x-www-form-urlencoded content-type", "ERR_INVALID_ARG_VALUE", { cause: e3 });
  return (async function(e4) {
    if (e4.bodyUsed) throw kt("form_post Request instances must contain a readable body", "ERR_INVALID_ARG_VALUE", { cause: e4 });
    return e4.text();
  })(e3);
}
function Qn(e3, t2, n2, o2) {
  if (void 0 === e3) if (Array.isArray(t2)) {
    if (!t2.includes(o2.alg)) throw Ut('unexpected JWT "alg" header parameter', Nn, { header: o2, expected: t2, reason: "authorization server metadata" });
  } else {
    if (void 0 === n2) throw Ut('missing client or server configuration to verify used JWT "alg" header parameter', void 0, { client: e3, issuer: t2, fallback: n2 });
    if ("string" == typeof n2 ? o2.alg !== n2 : "function" == typeof n2 ? !n2(o2.alg) : !n2.includes(o2.alg)) throw Ut('unexpected JWT "alg" header parameter', Nn, { header: o2, expected: n2, reason: "default value" });
  }
  else if ("string" == typeof e3 ? o2.alg !== e3 : !e3.includes(o2.alg)) throw Ut('unexpected JWT "alg" header parameter', Nn, { header: o2, expected: e3, reason: "client configuration" });
}
function $n(e3, t2) {
  const { 0: n2, length: o2 } = e3.getAll(t2);
  if (o2 > 1) throw Ut('"'.concat(t2, '" parameter must be provided only once'), Nn);
  return n2;
}
var eo = Symbol();
var to = Symbol();
function no(e3, t2, n2, o2) {
  if (Qt(e3), $t(t2), n2 instanceof URL && (n2 = n2.searchParams), !(n2 instanceof URLSearchParams)) throw kt('"parameters" must be an instance of URLSearchParams, or URL', "ERR_INVALID_ARG_TYPE");
  if ($n(n2, "response")) throw Ut('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()', Nn, { parameters: n2 });
  const r2 = $n(n2, "iss"), i2 = $n(n2, "state");
  if (!r2 && e3.authorization_response_iss_parameter_supported) throw Ut('response parameter "iss" (issuer) missing', Nn, { parameters: n2 });
  if (r2 && r2 !== e3.issuer) throw Ut('unexpected "iss" (issuer) response parameter value', Nn, { expected: e3.issuer, parameters: n2 });
  switch (o2) {
    case void 0:
    case to:
      if (void 0 !== i2) throw Ut('unexpected "state" response parameter encountered', Nn, { expected: void 0, parameters: n2 });
      break;
    case eo:
      break;
    default:
      if (Ft(o2, '"expectedState" argument'), i2 !== o2) throw Ut(void 0 === i2 ? 'response parameter "state" missing' : 'unexpected "state" response parameter value', Nn, { expected: o2, parameters: n2 });
  }
  if ($n(n2, "error")) throw new cn("authorization response from the server is an error", { cause: n2 });
  const a2 = $n(n2, "id_token"), s2 = $n(n2, "token");
  if (void 0 !== a2 || void 0 !== s2) throw new Kt("implicit and hybrid flows are not supported");
  return c2 = new URLSearchParams(n2), An.add(c2), c2;
  var c2;
}
async function oo(e3) {
  let t2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Gt;
  try {
    t2 = await e3.json();
  } catch (t3) {
    throw n2(e3), Ut('failed to parse "response" body as JSON', Un, t3);
  }
  if (!Wt(t2)) throw Ut('"response" body must be a top level object', Nn, { body: t2 });
  return t2;
}
var ro = Symbol();
var io = Symbol();
var ao = new TextEncoder();
var so = new TextDecoder();
function co(e3) {
  const t2 = new Uint8Array(e3.length);
  for (let n2 = 0; n2 < e3.length; n2++) {
    const o2 = e3.charCodeAt(n2);
    if (o2 > 127) throw new TypeError("non-ASCII string encountered in encode()");
    t2[n2] = o2;
  }
  return t2;
}
function uo(e3) {
  if (Uint8Array.fromBase64) return Uint8Array.fromBase64(e3);
  const t2 = atob(e3), n2 = new Uint8Array(t2.length);
  for (let e4 = 0; e4 < t2.length; e4++) n2[e4] = t2.charCodeAt(e4);
  return n2;
}
function lo(e3) {
  if (Uint8Array.fromBase64) return Uint8Array.fromBase64("string" == typeof e3 ? e3 : so.decode(e3), { alphabet: "base64url" });
  let t2 = e3;
  t2 instanceof Uint8Array && (t2 = so.decode(t2)), t2 = t2.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return uo(t2);
  } catch (e4) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
var ho = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "code", "ERR_JOSE_GENERIC"), this.name = this.constructor.name, null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
ht(ho, "code", "ERR_JOSE_GENERIC");
var po = class extends ho {
  constructor(e3, t2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "unspecified", o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "unspecified";
    super(e3, { cause: { claim: n2, reason: o2, payload: t2 } }), ht(this, "code", "ERR_JWT_CLAIM_VALIDATION_FAILED"), ht(this, "claim", void 0), ht(this, "reason", void 0), ht(this, "payload", void 0), this.claim = n2, this.reason = o2, this.payload = t2;
  }
};
ht(po, "code", "ERR_JWT_CLAIM_VALIDATION_FAILED");
var fo = class extends ho {
  constructor(e3, t2) {
    let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "unspecified", o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "unspecified";
    super(e3, { cause: { claim: n2, reason: o2, payload: t2 } }), ht(this, "code", "ERR_JWT_EXPIRED"), ht(this, "claim", void 0), ht(this, "reason", void 0), ht(this, "payload", void 0), this.claim = n2, this.reason = o2, this.payload = t2;
  }
};
ht(fo, "code", "ERR_JWT_EXPIRED");
var mo = class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JOSE_ALG_NOT_ALLOWED");
  }
};
ht(mo, "code", "ERR_JOSE_ALG_NOT_ALLOWED");
var yo = class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JOSE_NOT_SUPPORTED");
  }
};
ht(yo, "code", "ERR_JOSE_NOT_SUPPORTED");
ht(class extends ho {
  constructor() {
    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "decryption operation failed", arguments.length > 1 ? arguments[1] : void 0), ht(this, "code", "ERR_JWE_DECRYPTION_FAILED");
  }
}, "code", "ERR_JWE_DECRYPTION_FAILED");
ht(class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JWE_INVALID");
  }
}, "code", "ERR_JWE_INVALID");
var wo = class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JWS_INVALID");
  }
};
ht(wo, "code", "ERR_JWS_INVALID");
var go = class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JWT_INVALID");
  }
};
ht(go, "code", "ERR_JWT_INVALID");
ht(class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JWK_INVALID");
  }
}, "code", "ERR_JWK_INVALID");
var vo = class extends ho {
  constructor() {
    super(...arguments), ht(this, "code", "ERR_JWKS_INVALID");
  }
};
ht(vo, "code", "ERR_JWKS_INVALID");
var bo = class extends ho {
  constructor() {
    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "no applicable key found in the JSON Web Key Set", arguments.length > 1 ? arguments[1] : void 0), ht(this, "code", "ERR_JWKS_NO_MATCHING_KEY");
  }
};
ht(bo, "code", "ERR_JWKS_NO_MATCHING_KEY");
var _o = class extends ho {
  constructor() {
    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "multiple matching keys found in the JSON Web Key Set", arguments.length > 1 ? arguments[1] : void 0), ht(this, Symbol.asyncIterator, void 0), ht(this, "code", "ERR_JWKS_MULTIPLE_MATCHING_KEYS");
  }
};
ht(_o, "code", "ERR_JWKS_MULTIPLE_MATCHING_KEYS");
var ko = class extends ho {
  constructor() {
    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "request timed out", arguments.length > 1 ? arguments[1] : void 0), ht(this, "code", "ERR_JWKS_TIMEOUT");
  }
};
ht(ko, "code", "ERR_JWKS_TIMEOUT");
var So = class extends ho {
  constructor() {
    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "signature verification failed", arguments.length > 1 ? arguments[1] : void 0), ht(this, "code", "ERR_JWS_SIGNATURE_VERIFICATION_FAILED");
  }
};
ht(So, "code", "ERR_JWS_SIGNATURE_VERIFICATION_FAILED");
var Eo = function(e3) {
  let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "algorithm.name";
  return new TypeError("CryptoKey does not support this operation, its ".concat(t2, " must be ").concat(e3));
};
var To = (e3, t2) => e3.name === t2;
function Ao(e3) {
  return parseInt(e3.name.slice(4), 10);
}
function Po(e3, t2, n2) {
  switch (t2) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!To(e3.algorithm, "HMAC")) throw Eo("HMAC");
      const n3 = parseInt(t2.slice(2), 10);
      if (Ao(e3.algorithm.hash) !== n3) throw Eo("SHA-".concat(n3), "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!To(e3.algorithm, "RSASSA-PKCS1-v1_5")) throw Eo("RSASSA-PKCS1-v1_5");
      const n3 = parseInt(t2.slice(2), 10);
      if (Ao(e3.algorithm.hash) !== n3) throw Eo("SHA-".concat(n3), "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!To(e3.algorithm, "RSA-PSS")) throw Eo("RSA-PSS");
      const n3 = parseInt(t2.slice(2), 10);
      if (Ao(e3.algorithm.hash) !== n3) throw Eo("SHA-".concat(n3), "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA":
      if (!To(e3.algorithm, "Ed25519")) throw Eo("Ed25519");
      break;
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      if (!To(e3.algorithm, t2)) throw Eo(t2);
      break;
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!To(e3.algorithm, "ECDSA")) throw Eo("ECDSA");
      const n3 = (function(e4) {
        switch (e4) {
          case "ES256":
            return "P-256";
          case "ES384":
            return "P-384";
          case "ES512":
            return "P-521";
          default:
            throw new Error("unreachable");
        }
      })(t2);
      if (e3.algorithm.namedCurve !== n3) throw Eo(n3, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  !(function(e4, t3) {
    if (t3 && !e4.usages.includes(t3)) throw new TypeError("CryptoKey does not support this operation, its usages must include ".concat(t3, "."));
  })(e3, n2);
}
function Ro(e3, t2) {
  for (var n2 = arguments.length, o2 = new Array(n2 > 2 ? n2 - 2 : 0), r2 = 2; r2 < n2; r2++) o2[r2 - 2] = arguments[r2];
  if ((o2 = o2.filter(Boolean)).length > 2) {
    const t3 = o2.pop();
    e3 += "one of type ".concat(o2.join(", "), ", or ").concat(t3, ".");
  } else 2 === o2.length ? e3 += "one of type ".concat(o2[0], " or ").concat(o2[1], ".") : e3 += "of type ".concat(o2[0], ".");
  if (null == t2) e3 += " Received ".concat(t2);
  else if ("function" == typeof t2 && t2.name) e3 += " Received function ".concat(t2.name);
  else if ("object" == typeof t2 && null != t2) {
    var i2;
    null !== (i2 = t2.constructor) && void 0 !== i2 && i2.name && (e3 += " Received an instance of ".concat(t2.constructor.name));
  }
  return e3;
}
var Io = function(e3, t2) {
  for (var n2 = arguments.length, o2 = new Array(n2 > 2 ? n2 - 2 : 0), r2 = 2; r2 < n2; r2++) o2[r2 - 2] = arguments[r2];
  return Ro("Key for the ".concat(e3, " algorithm must be "), t2, ...o2);
};
var xo = (e3) => {
  if ("CryptoKey" === (null == e3 ? void 0 : e3[Symbol.toStringTag])) return true;
  try {
    return e3 instanceof CryptoKey;
  } catch (e4) {
    return false;
  }
};
var Oo = (e3) => "KeyObject" === (null == e3 ? void 0 : e3[Symbol.toStringTag]);
var Co = (e3) => xo(e3) || Oo(e3);
function jo(e3) {
  if ("object" != typeof (t2 = e3) || null === t2 || "[object Object]" !== Object.prototype.toString.call(e3)) return false;
  var t2;
  if (null === Object.getPrototypeOf(e3)) return true;
  let n2 = e3;
  for (; null !== Object.getPrototypeOf(n2); ) n2 = Object.getPrototypeOf(n2);
  return Object.getPrototypeOf(e3) === n2;
}
var Do = (e3, t2) => {
  if (e3.byteLength !== t2.length) return false;
  for (let n2 = 0; n2 < e3.byteLength; n2++) if (e3[n2] !== t2[n2]) return false;
  return true;
};
var Ko = (e3) => {
  const t2 = e3.data[e3.pos++];
  if (128 & t2) {
    const n2 = 127 & t2;
    let o2 = 0;
    for (let t3 = 0; t3 < n2; t3++) o2 = o2 << 8 | e3.data[e3.pos++];
    return o2;
  }
  return t2;
};
var Lo = (e3, t2, n2) => {
  if (e3.data[e3.pos++] !== t2) throw new Error(n2);
};
var Uo = (e3, t2) => {
  const n2 = e3.data.subarray(e3.pos, e3.pos + t2);
  return e3.pos += t2, n2;
};
var No = (e3) => {
  const t2 = ((e4) => {
    Lo(e4, 6, "Expected algorithm OID");
    const t3 = Ko(e4);
    return Uo(e4, t3);
  })(e3);
  if (Do(t2, [43, 101, 110])) return "X25519";
  if (!Do(t2, [42, 134, 72, 206, 61, 2, 1])) throw new Error("Unsupported key algorithm");
  Lo(e3, 6, "Expected curve OID");
  const n2 = Ko(e3), o2 = Uo(e3, n2);
  for (const { name: e4, oid: t3 } of [{ name: "P-256", oid: [42, 134, 72, 206, 61, 3, 1, 7] }, { name: "P-384", oid: [43, 129, 4, 0, 34] }, { name: "P-521", oid: [43, 129, 4, 0, 35] }]) if (Do(o2, t3)) return e4;
  throw new Error("Unsupported named curve");
};
var Wo = async (e3, t2, n2, o2) => {
  var r2;
  let i2, a2;
  const s2 = "spki" === e3, c2 = () => s2 ? ["verify"] : ["sign"];
  switch (n2) {
    case "PS256":
    case "PS384":
    case "PS512":
      i2 = { name: "RSA-PSS", hash: "SHA-".concat(n2.slice(-3)) }, a2 = c2();
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      i2 = { name: "RSASSA-PKCS1-v1_5", hash: "SHA-".concat(n2.slice(-3)) }, a2 = c2();
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      i2 = { name: "RSA-OAEP", hash: "SHA-".concat(parseInt(n2.slice(-3), 10) || 1) }, a2 = s2 ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
      break;
    case "ES256":
    case "ES384":
    case "ES512":
      i2 = { name: "ECDSA", namedCurve: { ES256: "P-256", ES384: "P-384", ES512: "P-521" }[n2] }, a2 = c2();
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW":
      try {
        const e4 = o2.getNamedCurve(t2);
        i2 = "X25519" === e4 ? { name: "X25519" } : { name: "ECDH", namedCurve: e4 };
      } catch (e4) {
        throw new yo("Invalid or unsupported key format");
      }
      a2 = s2 ? [] : ["deriveBits"];
      break;
    case "Ed25519":
    case "EdDSA":
      i2 = { name: "Ed25519" }, a2 = c2();
      break;
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      i2 = { name: n2 }, a2 = c2();
      break;
    default:
      throw new yo('Invalid or unsupported "alg" (Algorithm) value');
  }
  return crypto.subtle.importKey(e3, t2, i2, null !== (r2 = null == o2 ? void 0 : o2.extractable) && void 0 !== r2 ? r2 : !!s2, a2);
};
var zo = (e3, t2, n2) => {
  var o2;
  const r2 = ((e4, t3) => uo(e4.replace(t3, "")))(e3, /(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g);
  let i2 = n2;
  return null != t2 && null !== (o2 = t2.startsWith) && void 0 !== o2 && o2.call(t2, "ECDH-ES") && (i2 || (i2 = {}), i2.getNamedCurve = (e4) => {
    const t3 = { data: e4, pos: 0 };
    return (function(e5) {
      Lo(e5, 48, "Invalid PKCS#8 structure"), Ko(e5), Lo(e5, 2, "Expected version field");
      const t4 = Ko(e5);
      e5.pos += t4, Lo(e5, 48, "Expected algorithm identifier");
      Ko(e5);
      e5.pos;
    })(t3), No(t3);
  }), Wo("pkcs8", r2, t2, i2);
};
async function Ho(e3) {
  var t2, n2;
  if (!e3.alg) throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  const { algorithm: o2, keyUsages: r2 } = (function(e4) {
    let t3, n3;
    switch (e4.kty) {
      case "AKP":
        switch (e4.alg) {
          case "ML-DSA-44":
          case "ML-DSA-65":
          case "ML-DSA-87":
            t3 = { name: e4.alg }, n3 = e4.priv ? ["sign"] : ["verify"];
            break;
          default:
            throw new yo('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
        }
        break;
      case "RSA":
        switch (e4.alg) {
          case "PS256":
          case "PS384":
          case "PS512":
            t3 = { name: "RSA-PSS", hash: "SHA-".concat(e4.alg.slice(-3)) }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "RS256":
          case "RS384":
          case "RS512":
            t3 = { name: "RSASSA-PKCS1-v1_5", hash: "SHA-".concat(e4.alg.slice(-3)) }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "RSA-OAEP":
          case "RSA-OAEP-256":
          case "RSA-OAEP-384":
          case "RSA-OAEP-512":
            t3 = { name: "RSA-OAEP", hash: "SHA-".concat(parseInt(e4.alg.slice(-3), 10) || 1) }, n3 = e4.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
            break;
          default:
            throw new yo('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
        }
        break;
      case "EC":
        switch (e4.alg) {
          case "ES256":
            t3 = { name: "ECDSA", namedCurve: "P-256" }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "ES384":
            t3 = { name: "ECDSA", namedCurve: "P-384" }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "ES512":
            t3 = { name: "ECDSA", namedCurve: "P-521" }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "ECDH-ES":
          case "ECDH-ES+A128KW":
          case "ECDH-ES+A192KW":
          case "ECDH-ES+A256KW":
            t3 = { name: "ECDH", namedCurve: e4.crv }, n3 = e4.d ? ["deriveBits"] : [];
            break;
          default:
            throw new yo('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
        }
        break;
      case "OKP":
        switch (e4.alg) {
          case "Ed25519":
          case "EdDSA":
            t3 = { name: "Ed25519" }, n3 = e4.d ? ["sign"] : ["verify"];
            break;
          case "ECDH-ES":
          case "ECDH-ES+A128KW":
          case "ECDH-ES+A192KW":
          case "ECDH-ES+A256KW":
            t3 = { name: e4.crv }, n3 = e4.d ? ["deriveBits"] : [];
            break;
          default:
            throw new yo('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
        }
        break;
      default:
        throw new yo('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
    return { algorithm: t3, keyUsages: n3 };
  })(e3), i2 = ft({}, e3);
  return "AKP" !== i2.kty && delete i2.alg, delete i2.use, crypto.subtle.importKey("jwk", i2, o2, null !== (t2 = e3.ext) && void 0 !== t2 ? t2 : !e3.d && !e3.priv, null !== (n2 = e3.key_ops) && void 0 !== n2 ? n2 : r2);
}
var Mo = (e3) => jo(e3) && "string" == typeof e3.kty;
var Jo;
var Vo = async function(e3, t2, n2) {
  let o2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  Jo || (Jo = /* @__PURE__ */ new WeakMap());
  let r2 = Jo.get(e3);
  if (null != r2 && r2[n2]) return r2[n2];
  const i2 = await Ho(ft(ft({}, t2), {}, { alg: n2 }));
  return o2 && Object.freeze(e3), r2 ? r2[n2] = i2 : Jo.set(e3, { [n2]: i2 }), i2;
};
async function Fo(e3, t2) {
  if (e3 instanceof Uint8Array) return e3;
  if (xo(e3)) return e3;
  if (Oo(e3)) {
    if ("secret" === e3.type) return e3.export();
    if ("toCryptoKey" in e3 && "function" == typeof e3.toCryptoKey) try {
      return ((e4, t3) => {
        Jo || (Jo = /* @__PURE__ */ new WeakMap());
        let n3 = Jo.get(e4);
        if (null != n3 && n3[t3]) return n3[t3];
        const o2 = "public" === e4.type, r2 = !!o2;
        let i2;
        if ("x25519" === e4.asymmetricKeyType) {
          switch (t3) {
            case "ECDH-ES":
            case "ECDH-ES+A128KW":
            case "ECDH-ES+A192KW":
            case "ECDH-ES+A256KW":
              break;
            default:
              throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          }
          i2 = e4.toCryptoKey(e4.asymmetricKeyType, r2, o2 ? [] : ["deriveBits"]);
        }
        if ("ed25519" === e4.asymmetricKeyType) {
          if ("EdDSA" !== t3 && "Ed25519" !== t3) throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          i2 = e4.toCryptoKey(e4.asymmetricKeyType, r2, [o2 ? "verify" : "sign"]);
        }
        switch (e4.asymmetricKeyType) {
          case "ml-dsa-44":
          case "ml-dsa-65":
          case "ml-dsa-87":
            if (t3 !== e4.asymmetricKeyType.toUpperCase()) throw new TypeError("given KeyObject instance cannot be used for this algorithm");
            i2 = e4.toCryptoKey(e4.asymmetricKeyType, r2, [o2 ? "verify" : "sign"]);
        }
        if ("rsa" === e4.asymmetricKeyType) {
          let n4;
          switch (t3) {
            case "RSA-OAEP":
              n4 = "SHA-1";
              break;
            case "RS256":
            case "PS256":
            case "RSA-OAEP-256":
              n4 = "SHA-256";
              break;
            case "RS384":
            case "PS384":
            case "RSA-OAEP-384":
              n4 = "SHA-384";
              break;
            case "RS512":
            case "PS512":
            case "RSA-OAEP-512":
              n4 = "SHA-512";
              break;
            default:
              throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          }
          if (t3.startsWith("RSA-OAEP")) return e4.toCryptoKey({ name: "RSA-OAEP", hash: n4 }, r2, o2 ? ["encrypt"] : ["decrypt"]);
          i2 = e4.toCryptoKey({ name: t3.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5", hash: n4 }, r2, [o2 ? "verify" : "sign"]);
        }
        if ("ec" === e4.asymmetricKeyType) {
          var a2;
          const n4 = (/* @__PURE__ */ new Map([["prime256v1", "P-256"], ["secp384r1", "P-384"], ["secp521r1", "P-521"]])).get(null === (a2 = e4.asymmetricKeyDetails) || void 0 === a2 ? void 0 : a2.namedCurve);
          if (!n4) throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          "ES256" === t3 && "P-256" === n4 && (i2 = e4.toCryptoKey({ name: "ECDSA", namedCurve: n4 }, r2, [o2 ? "verify" : "sign"])), "ES384" === t3 && "P-384" === n4 && (i2 = e4.toCryptoKey({ name: "ECDSA", namedCurve: n4 }, r2, [o2 ? "verify" : "sign"])), "ES512" === t3 && "P-521" === n4 && (i2 = e4.toCryptoKey({ name: "ECDSA", namedCurve: n4 }, r2, [o2 ? "verify" : "sign"])), t3.startsWith("ECDH-ES") && (i2 = e4.toCryptoKey({ name: "ECDH", namedCurve: n4 }, r2, o2 ? [] : ["deriveBits"]));
        }
        if (!i2) throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        return n3 ? n3[t3] = i2 : Jo.set(e4, { [t3]: i2 }), i2;
      })(e3, t2);
    } catch (e4) {
      if (e4 instanceof TypeError) throw e4;
    }
    let n2 = e3.export({ format: "jwk" });
    return Vo(e3, n2, t2);
  }
  if (Mo(e3)) return e3.k ? lo(e3.k) : Vo(e3, e3, t2, true);
  throw new Error("unreachable");
}
var Go = (e3) => null == e3 ? void 0 : e3[Symbol.toStringTag];
var Zo = (e3, t2, n2) => {
  if (void 0 !== t2.use) {
    let e4;
    switch (n2) {
      case "sign":
      case "verify":
        e4 = "sig";
        break;
      case "encrypt":
      case "decrypt":
        e4 = "enc";
    }
    if (t2.use !== e4) throw new TypeError('Invalid key for this operation, its "use" must be "'.concat(e4, '" when present'));
  }
  if (void 0 !== t2.alg && t2.alg !== e3) throw new TypeError('Invalid key for this operation, its "alg" must be "'.concat(e3, '" when present'));
  if (Array.isArray(t2.key_ops)) {
    var o2, r2;
    let i2;
    switch (true) {
      case ("sign" === n2 || "verify" === n2):
      case "dir" === e3:
      case e3.includes("CBC-HS"):
        i2 = n2;
        break;
      case e3.startsWith("PBES2"):
        i2 = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(e3):
        i2 = !e3.includes("GCM") && e3.endsWith("KW") ? "encrypt" === n2 ? "wrapKey" : "unwrapKey" : n2;
        break;
      case ("encrypt" === n2 && e3.startsWith("RSA")):
        i2 = "wrapKey";
        break;
      case "decrypt" === n2:
        i2 = e3.startsWith("RSA") ? "unwrapKey" : "deriveBits";
    }
    if (i2 && false === (null === (o2 = t2.key_ops) || void 0 === o2 || null === (r2 = o2.includes) || void 0 === r2 ? void 0 : r2.call(o2, i2))) throw new TypeError('Invalid key for this operation, its "key_ops" must include "'.concat(i2, '" when present'));
  }
  return true;
};
function qo(e3, t2, n2) {
  switch (e3.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      ((e4, t3, n3) => {
        if (!(t3 instanceof Uint8Array)) {
          if (Mo(t3)) {
            if (((e5) => "oct" === e5.kty && "string" == typeof e5.k)(t3) && Zo(e4, t3, n3)) return;
            throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present');
          }
          if (!Co(t3)) throw new TypeError(Io(e4, t3, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
          if ("secret" !== t3.type) throw new TypeError("".concat(Go(t3), ' instances for symmetric algorithms must be of type "secret"'));
        }
      })(e3, t2, n2);
      break;
    default:
      ((e4, t3, n3) => {
        if (Mo(t3)) switch (n3) {
          case "decrypt":
          case "sign":
            if (((e5) => "oct" !== e5.kty && ("AKP" === e5.kty && "string" == typeof e5.priv || "string" == typeof e5.d))(t3) && Zo(e4, t3, n3)) return;
            throw new TypeError("JSON Web Key for this operation must be a private JWK");
          case "encrypt":
          case "verify":
            if (((e5) => "oct" !== e5.kty && void 0 === e5.d && void 0 === e5.priv)(t3) && Zo(e4, t3, n3)) return;
            throw new TypeError("JSON Web Key for this operation must be a public JWK");
        }
        if (!Co(t3)) throw new TypeError(Io(e4, t3, "CryptoKey", "KeyObject", "JSON Web Key"));
        if ("secret" === t3.type) throw new TypeError("".concat(Go(t3), ' instances for asymmetric algorithms must not be of type "secret"'));
        if ("public" === t3.type) switch (n3) {
          case "sign":
            throw new TypeError("".concat(Go(t3), ' instances for asymmetric algorithm signing must be of type "private"'));
          case "decrypt":
            throw new TypeError("".concat(Go(t3), ' instances for asymmetric algorithm decryption must be of type "private"'));
        }
        if ("private" === t3.type) switch (n3) {
          case "verify":
            throw new TypeError("".concat(Go(t3), ' instances for asymmetric algorithm verifying must be of type "public"'));
          case "encrypt":
            throw new TypeError("".concat(Go(t3), ' instances for asymmetric algorithm encryption must be of type "public"'));
        }
      })(e3, t2, n2);
  }
}
var Bo;
var Xo;
var Yo;
var Qo;
if ("undefined" == typeof navigator || null === (Bo = navigator.userAgent) || void 0 === Bo || null === (Xo = Bo.startsWith) || void 0 === Xo || !Xo.call(Bo, "Mozilla/5.0 ")) {
  const e3 = "v6.8.1";
  Qo = "".concat("openid-client", "/").concat(e3), Yo = { "user-agent": Qo };
}
var $o = (e3) => er.get(e3);
var er;
var tr;
function nr(e3) {
  return void 0 !== e3 ? en(e3) : (tr || (tr = /* @__PURE__ */ new WeakMap()), (e4, t2, n2, o2) => {
    let r2;
    return (r2 = tr.get(t2)) || (!(function(e5, t3) {
      if ("string" != typeof e5) throw ar("".concat(t3, " must be a string"), ir);
      if (0 === e5.length) throw ar("".concat(t3, " must not be empty"), rr);
    })(t2.client_secret, '"metadata.client_secret"'), r2 = en(t2.client_secret), tr.set(t2, r2)), r2(e4, t2, n2, o2);
  });
}
var or = At;
var rr = "ERR_INVALID_ARG_VALUE";
var ir = "ERR_INVALID_ARG_TYPE";
function ar(e3, t2, n2) {
  const o2 = new TypeError(e3, { cause: n2 });
  return Object.assign(o2, { code: t2 }), o2;
}
function sr(e3) {
  return (async function(e4) {
    return Ft(e4, "codeVerifier"), Dt(await crypto.subtle.digest("SHA-256", Ot(e4)));
  })(e3);
}
function cr() {
  return Zt();
}
var ur = class extends Error {
  constructor(e3, t2) {
    var n2;
    super(e3, t2), ht(this, "code", void 0), this.name = this.constructor.name, this.code = null == t2 ? void 0 : t2.code, null === (n2 = Error.captureStackTrace) || void 0 === n2 || n2.call(Error, this, this.constructor);
  }
};
function lr(e3, t2, n2) {
  return new ur(e3, { cause: t2, code: n2 });
}
function dr(e3) {
  if (e3 instanceof TypeError || e3 instanceof ur || e3 instanceof sn || e3 instanceof cn || e3 instanceof un) throw e3;
  if (e3 instanceof Lt) switch (e3.code) {
    case Hn:
      throw lr("only requests to HTTPS are allowed", e3, e3.code);
    case Mn:
      throw lr("only requests to HTTP or HTTPS are allowed", e3, e3.code);
    case zn:
      throw lr("unexpected HTTP response status code", e3.cause, e3.code);
    case Wn:
      throw lr("unexpected response content-type", e3.cause, e3.code);
    case Un:
      throw lr("parsing error occured", e3, e3.code);
    case Nn:
      throw lr("invalid response encountered", e3, e3.code);
    case Vn:
      throw lr("unexpected JWT claim value encountered", e3, e3.code);
    case Fn:
      throw lr("unexpected JSON attribute value encountered", e3, e3.code);
    case Jn:
      throw lr("JWT timestamp claim value failed validation", e3, e3.code);
    default:
      throw lr(e3.message, e3, e3.code);
  }
  if (e3 instanceof Kt) throw lr("unsupported operation", e3, e3.code);
  if (e3 instanceof DOMException) switch (e3.name) {
    case "OperationError":
      throw lr("runtime operation error", e3, Kn);
    case "NotSupportedError":
      throw lr("runtime unsupported operation", e3, Kn);
    case "TimeoutError":
      throw lr("operation timed out", e3, "OAUTH_TIMEOUT");
    case "AbortError":
      throw lr("operation aborted", e3, "OAUTH_ABORT");
  }
  throw new ur("something went wrong", { cause: e3 });
}
async function hr(e3, t2, n2, o2, r2) {
  const i2 = await (async function(e4, t3) {
    var n3, o3;
    if (!(e4 instanceof URL)) throw ar('"server" must be an instance of URL', ir);
    const r3 = !e4.href.includes("/.well-known/"), i3 = null !== (n3 = null == t3 ? void 0 : t3.timeout) && void 0 !== n3 ? n3 : 30, a3 = AbortSignal.timeout(1e3 * i3), s3 = await (r3 ? Jt(e4, { algorithm: null == t3 ? void 0 : t3.algorithm, [At]: null == t3 ? void 0 : t3[or], [St]: null == t3 || null === (o3 = t3.execute) || void 0 === o3 ? void 0 : o3.includes(br), signal: a3, headers: new Headers(Yo) }) : ((null == t3 ? void 0 : t3[or]) || fetch)((on(e4, null == t3 || null === (c2 = t3.execute) || void 0 === c2 || !c2.includes(br)), e4.href), { headers: Object.fromEntries(new Headers(ft({ accept: "application/json" }, Yo)).entries()), body: void 0, method: "GET", redirect: "manual", signal: a3 })).then(((e5) => (async function(e6, t4) {
      const n4 = e6;
      if (!(n4 instanceof URL) && n4 !== ro) throw kt('"expectedIssuerIdentifier" must be an instance of URL', "ERR_INVALID_ARG_TYPE");
      if (!_t(t4, Response)) throw kt('"response" must be an instance of Response', "ERR_INVALID_ARG_TYPE");
      if (200 !== t4.status) throw Ut('"response" is not a conform Authorization Server Metadata response (unexpected HTTP status code)', zn, t4);
      qn(t4);
      const o4 = await oo(t4);
      if (Ft(o4.issuer, '"response" body "issuer" property', Nn, { body: o4 }), n4 !== ro && new URL(o4.issuer).href !== n4.href) throw Ut('"response" body "issuer" property does not match the expected value', Fn, { expected: n4.href, body: o4, attribute: "issuer" });
      return o4;
    })(ro, e5))).catch(dr);
    var c2;
    r3 && new URL(s3.issuer).href !== e4.href && ((function(e5, t4, n4) {
      return !("https://login.microsoftonline.com" !== e5.origin || null != n4 && n4.algorithm && "oidc" !== n4.algorithm || (t4[pr] = true, 0));
    })(e4, s3, t3) || (function(e5, t4) {
      return !(!e5.hostname.endsWith(".b2clogin.com") || null != t4 && t4.algorithm && "oidc" !== t4.algorithm);
    })(e4, t3) || (() => {
      throw new ur("discovered metadata issuer does not match the expected issuer", { code: Fn, cause: { expected: e4.href, body: s3, attribute: "issuer" } });
    })());
    return s3;
  })(e3, r2), a2 = new fr(i2, t2, n2, o2);
  let s2 = $o(a2);
  if (null != r2 && r2[or] && (s2.fetch = r2[or]), null != r2 && r2.timeout && (s2.timeout = r2.timeout), null != r2 && r2.execute) for (const e4 of r2.execute) e4(a2);
  return a2;
}
new TextDecoder();
var pr = Symbol();
var fr = class {
  constructor(e3, t2, n2, o2) {
    var r2, i2, a2, s2, c2;
    if ("string" != typeof t2 || !t2.length) throw ar('"clientId" must be a non-empty string', ir);
    if ("string" == typeof n2 && (n2 = { client_secret: n2 }), void 0 !== (null === (r2 = n2) || void 0 === r2 ? void 0 : r2.client_id) && t2 !== n2.client_id) throw ar('"clientId" and "metadata.client_id" must be the same', rr);
    const u2 = ft(ft({}, structuredClone(n2)), {}, { client_id: t2 });
    let l2;
    u2[Et] = null !== (i2 = null === (a2 = n2) || void 0 === a2 ? void 0 : a2[Et]) && void 0 !== i2 ? i2 : 0, u2[Tt] = null !== (s2 = null === (c2 = n2) || void 0 === c2 ? void 0 : c2[Tt]) && void 0 !== s2 ? s2 : 30, l2 = o2 || ("string" == typeof u2.client_secret && u2.client_secret.length ? nr(u2.client_secret) : (e4, t3, n3, o3) => {
      n3.set("client_id", t3.client_id);
    });
    let d2 = Object.freeze(u2);
    const h2 = structuredClone(e3);
    pr in e3 && (h2[io] = (t3) => {
      let { claims: { tid: n3 } } = t3;
      return e3.issuer.replace("{tenantid}", n3);
    });
    let p2 = Object.freeze(h2);
    er || (er = /* @__PURE__ */ new WeakMap()), er.set(this, { __proto__: null, as: p2, c: d2, auth: l2, tlsOnly: true, jwksCache: {} });
  }
  serverMetadata() {
    const e3 = structuredClone($o(this).as);
    return (function(e4) {
      Object.defineProperties(e4, /* @__PURE__ */ (function(e5) {
        return { supportsPKCE: { __proto__: null, value() {
          var t2;
          let n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "S256";
          return true === (null === (t2 = e5.code_challenge_methods_supported) || void 0 === t2 ? void 0 : t2.includes(n2));
        } } };
      })(e4));
    })(e3), e3;
  }
  clientMetadata() {
    return structuredClone($o(this).c);
  }
  get timeout() {
    return $o(this).timeout;
  }
  set timeout(e3) {
    $o(this).timeout = e3;
  }
  get [or]() {
    return $o(this).fetch;
  }
  set [or](e3) {
    $o(this).fetch = e3;
  }
};
function mr(e3) {
  Object.defineProperties(e3, (function(e4) {
    let t2;
    if (void 0 !== e4.expires_in) {
      const n2 = /* @__PURE__ */ new Date();
      n2.setSeconds(n2.getSeconds() + e4.expires_in), t2 = n2.getTime();
    }
    return { expiresIn: { __proto__: null, value() {
      if (t2) {
        const e5 = Date.now();
        return t2 > e5 ? Math.floor((t2 - e5) / 1e3) : 0;
      }
    } }, claims: { __proto__: null, value() {
      try {
        return kn(this);
      } catch (e5) {
        return;
      }
    } } };
  })(e3));
}
async function yr(e3, t2, n2) {
  var o2;
  let r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  const i2 = null === (o2 = e3.headers.get("retry-after")) || void 0 === o2 ? void 0 : o2.trim();
  if (void 0 === i2) return;
  let a2;
  if (/^\d+$/.test(i2)) a2 = parseInt(i2, 10);
  else {
    const e4 = new Date(i2);
    if (Number.isFinite(e4.getTime())) {
      const t3 = /* @__PURE__ */ new Date(), n3 = e4.getTime() - t3.getTime();
      n3 > 0 && (a2 = Math.ceil(n3 / 1e3));
    }
  }
  if (r2 && !Number.isFinite(a2)) throw new Lt("invalid Retry-After header value", { cause: e3 });
  a2 > t2 && await wr(a2 - t2, n2);
}
function wr(e3, t2) {
  return new Promise(((n2, o2) => {
    const r2 = (e4) => {
      try {
        t2.throwIfAborted();
      } catch (e5) {
        return void o2(e5);
      }
      if (e4 <= 0) return void n2();
      const i2 = Math.min(e4, 5);
      setTimeout((() => r2(e4 - i2)), 1e3 * i2);
    };
    r2(e3);
  }));
}
async function gr(e3, t2) {
  Ar(e3);
  const { as: n2, c: o2, auth: r2, fetch: i2, tlsOnly: a2, timeout: s2 } = $o(e3);
  return (async function(e4, t3, n3, o3, r3) {
    Qt(e4), $t(t3);
    const i3 = an(e4, "backchannel_authentication_endpoint", t3.use_mtls_endpoint_aliases, true !== (null == r3 ? void 0 : r3[St])), a3 = new URLSearchParams(o3);
    a3.set("client_id", t3.client_id);
    const s3 = zt(null == r3 ? void 0 : r3.headers);
    return s3.set("accept", "application/json"), gn(e4, t3, n3, i3, a3, s3, r3);
  })(n2, o2, r2, t2, { [At]: i2, [St]: !a2, headers: new Headers(Yo), signal: Pr(s2) }).then(((e4) => (async function(e5, t3, n3) {
    if (Qt(e5), $t(t3), !_t(n3, Response)) throw kt('"response" must be an instance of Response', "ERR_INVALID_ARG_TYPE");
    await mn(n3, 200, "Backchannel Authentication Endpoint"), qn(n3);
    const o3 = await oo(n3);
    Ft(o3.auth_req_id, '"response" body "auth_req_id" property', Nn, { body: o3 });
    let r3 = "number" != typeof o3.expires_in ? parseFloat(o3.expires_in) : o3.expires_in;
    return Vt(r3, true, '"response" body "expires_in" property', Nn, { body: o3 }), o3.expires_in = r3, void 0 !== o3.interval && Vt(o3.interval, false, '"response" body "interval" property', Nn, { body: o3 }), o3;
  })(n2, o2, e4))).catch(dr);
}
async function vr(e3, t2, n2, o2) {
  var r2, i2;
  Ar(e3), n2 = new URLSearchParams(n2);
  let a2 = null !== (r2 = t2.interval) && void 0 !== r2 ? r2 : 5;
  const s2 = null !== (i2 = null == o2 ? void 0 : o2.signal) && void 0 !== i2 ? i2 : AbortSignal.timeout(1e3 * t2.expires_in);
  try {
    await wr(a2, s2);
  } catch (e4) {
    dr(e4);
  }
  const { as: c2, c: u2, auth: l2, fetch: d2, tlsOnly: h2, nonRepudiation: p2, timeout: f2, decrypt: m2 } = $o(e3), y2 = (r3, i3) => vr(e3, ft(ft({}, t2), {}, { interval: r3 }), n2, ft(ft({}, o2), {}, { signal: s2, flag: i3 })), w2 = await (async function(e4, t3, n3, o3, r3) {
    Qt(e4), $t(t3), Ft(o3, '"authReqId"');
    const i3 = new URLSearchParams(null == r3 ? void 0 : r3.additionalParameters);
    return i3.set("auth_req_id", o3), vn(e4, t3, n3, "urn:openid:params:grant-type:ciba", i3, r3);
  })(c2, u2, l2, t2.auth_req_id, { [At]: d2, [St]: !h2, additionalParameters: n2, DPoP: null == o2 ? void 0 : o2.DPoP, headers: new Headers(Yo), signal: s2.aborted ? s2 : Pr(f2) }).catch(dr);
  var g2;
  if (503 === w2.status && w2.headers.has("retry-after")) return await yr(w2, a2, s2, true), await (null === (g2 = w2.body) || void 0 === g2 ? void 0 : g2.cancel()), y2(a2);
  const v2 = (async function(e4, t3, n3, o3) {
    return Sn(e4, t3, n3, void 0, null == o3 ? void 0 : o3[Rt], null == o3 ? void 0 : o3.recognizedTokenTypes);
  })(c2, u2, w2, { [Rt]: m2 });
  let b2;
  try {
    b2 = await v2;
  } catch (e4) {
    if (Rr(e4, o2)) return y2(a2, Ir);
    if (e4 instanceof sn) switch (e4.error) {
      case "slow_down":
        a2 += 5;
      case "authorization_pending":
        return await yr(e4.response, a2, s2), y2(a2);
    }
    dr(e4);
  }
  return b2.id_token && await (null == p2 ? void 0 : p2(w2)), mr(b2), b2;
}
function br(e3) {
  $o(e3).tlsOnly = false;
}
async function _r(e3, t2, n2, o2, r2) {
  if (Ar(e3), !((null == r2 ? void 0 : r2.flag) === Ir || t2 instanceof URL || (function(e4, t3) {
    try {
      return Object.getPrototypeOf(e4)[Symbol.toStringTag] === t3;
    } catch (e5) {
      return false;
    }
  })(t2, "Request"))) throw ar('"currentUrl" must be an instance of URL, or Request', ir);
  let i2, a2;
  const { as: s2, c: c2, auth: u2, fetch: l2, tlsOnly: d2, jarm: h2, hybrid: p2, nonRepudiation: f2, timeout: m2, decrypt: y2, implicit: w2 } = $o(e3);
  if ((null == r2 ? void 0 : r2.flag) === Ir) i2 = r2.authResponse, a2 = r2.redirectUri;
  else {
    if (!(t2 instanceof URL)) {
      const e4 = t2;
      switch (t2 = new URL(t2.url), e4.method) {
        case "GET":
          break;
        case "POST":
          const n3 = new URLSearchParams(await Yn(e4));
          if (p2) t2.hash = n3.toString();
          else for (const [e5, o3] of n3.entries()) t2.searchParams.append(e5, o3);
          break;
        default:
          throw ar("unexpected Request HTTP method", rr);
      }
    }
    switch (a2 = (function(e4) {
      return (e4 = new URL(e4)).search = "", e4.hash = "", e4.href;
    })(t2), true) {
      case !!h2:
        i2 = await h2(t2, null == n2 ? void 0 : n2.expectedState);
        break;
      case !!p2:
        i2 = await p2(t2, null == n2 ? void 0 : n2.expectedNonce, null == n2 ? void 0 : n2.expectedState, null == n2 ? void 0 : n2.maxAge);
        break;
      case !!w2:
        throw new TypeError("authorizationCodeGrant() cannot be used by response_type=id_token clients");
      default:
        try {
          i2 = no(s2, c2, t2.searchParams, null == n2 ? void 0 : n2.expectedState);
        } catch (e4) {
          dr(e4);
        }
    }
  }
  const g2 = await (async function(e4, t3, n3, o3, r3, i3, a3) {
    if (Qt(e4), $t(t3), !An.has(o3)) throw kt('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()', "ERR_INVALID_ARG_VALUE");
    Ft(r3, '"redirectUri"');
    const s3 = $n(o3, "code");
    if (!s3) throw Ut('no authorization code in "callbackParameters"', Nn);
    const c3 = new URLSearchParams(null == a3 ? void 0 : a3.additionalParameters);
    return c3.set("redirect_uri", r3), c3.set("code", s3), i3 !== Pn && (Ft(i3, '"codeVerifier"'), c3.set("code_verifier", i3)), vn(e4, t3, n3, "authorization_code", c3, a3);
  })(s2, c2, u2, i2, a2, (null == n2 ? void 0 : n2.pkceCodeVerifier) || Pn, { additionalParameters: o2, [At]: l2, [St]: !d2, DPoP: null == r2 ? void 0 : r2.DPoP, headers: new Headers(Yo), signal: Pr(m2) }).catch(dr);
  "string" != typeof (null == n2 ? void 0 : n2.expectedNonce) && "number" != typeof (null == n2 ? void 0 : n2.maxAge) || (n2.idTokenExpected = true);
  const v2 = Cn(s2, c2, g2, { expectedNonce: null == n2 ? void 0 : n2.expectedNonce, maxAge: null == n2 ? void 0 : n2.maxAge, requireIdToken: null == n2 ? void 0 : n2.idTokenExpected, [Rt]: y2 });
  let b2;
  try {
    b2 = await v2;
  } catch (t3) {
    if (Rr(t3, r2)) return _r(e3, void 0, n2, o2, ft(ft({}, r2), {}, { flag: Ir, authResponse: i2, redirectUri: a2 }));
    dr(t3);
  }
  return b2.id_token && await (null == f2 ? void 0 : f2(g2)), mr(b2), b2;
}
async function kr(e3, t2, n2, o2) {
  Ar(e3), n2 = new URLSearchParams(n2);
  const { as: r2, c: i2, auth: a2, fetch: s2, tlsOnly: c2, nonRepudiation: u2, timeout: l2, decrypt: d2 } = $o(e3), h2 = await (async function(e4, t3, n3, o3, r3) {
    Qt(e4), $t(t3), Ft(o3, '"refreshToken"');
    const i3 = new URLSearchParams(null == r3 ? void 0 : r3.additionalParameters);
    return i3.set("refresh_token", o3), vn(e4, t3, n3, "refresh_token", i3, r3);
  })(r2, i2, a2, t2, { [At]: s2, [St]: !c2, additionalParameters: n2, DPoP: null == o2 ? void 0 : o2.DPoP, headers: new Headers(Yo), signal: Pr(l2) }).catch(dr), p2 = (async function(e4, t3, n3, o3) {
    return Sn(e4, t3, n3, void 0, null == o3 ? void 0 : o3[Rt], null == o3 ? void 0 : o3.recognizedTokenTypes);
  })(r2, i2, h2, { [Rt]: d2 });
  let f2;
  try {
    f2 = await p2;
  } catch (r3) {
    if (Rr(r3, o2)) return kr(e3, t2, n2, ft(ft({}, o2), {}, { flag: Ir }));
    dr(r3);
  }
  return f2.id_token && await (null == u2 ? void 0 : u2(h2)), mr(f2), f2;
}
async function Sr(e3, t2, n2) {
  Ar(e3), t2 = new URLSearchParams(t2);
  const { as: o2, c: r2, auth: i2, fetch: a2, tlsOnly: s2, timeout: c2 } = $o(e3), u2 = await (async function(e4, t3, n3, o3, r3) {
    return Qt(e4), $t(t3), vn(e4, t3, n3, "client_credentials", new URLSearchParams(o3), r3);
  })(o2, r2, i2, t2, { [At]: a2, [St]: !s2, DPoP: null == n2 ? void 0 : n2.DPoP, headers: new Headers(Yo), signal: Pr(c2) }).catch(dr), l2 = (async function(e4, t3, n3, o3) {
    return Sn(e4, t3, n3, void 0, null == o3 ? void 0 : o3[Rt], null == o3 ? void 0 : o3.recognizedTokenTypes);
  })(o2, r2, u2);
  let d2;
  try {
    d2 = await l2;
  } catch (o3) {
    if (Rr(o3, n2)) return Sr(e3, t2, ft(ft({}, n2), {}, { flag: Ir }));
    dr(o3);
  }
  return mr(d2), d2;
}
function Er(e3, t2) {
  Ar(e3);
  const { as: n2, c: o2, tlsOnly: r2, hybrid: i2, jarm: a2, implicit: s2 } = $o(e3), c2 = an(n2, "authorization_endpoint", false, r2);
  if ((t2 = new URLSearchParams(t2)).has("client_id") || t2.set("client_id", o2.client_id), !t2.has("request_uri") && !t2.has("request")) {
    if (t2.has("response_type") || t2.set("response_type", i2 ? "code id_token" : s2 ? "id_token" : "code"), s2 && !t2.has("nonce")) throw ar("response_type=id_token clients must provide a nonce parameter in their authorization request parameters", rr);
    a2 && t2.set("response_mode", "jwt");
  }
  for (const [e4, n3] of t2.entries()) c2.searchParams.append(e4, n3);
  return c2;
}
async function Tr(e3, t2, n2) {
  Ar(e3);
  const o2 = Er(e3, t2), { as: r2, c: i2, auth: a2, fetch: s2, tlsOnly: c2, timeout: u2 } = $o(e3), l2 = await (async function(e4, t3, n3, o3, r3) {
    var i3;
    Qt(e4), $t(t3);
    const a3 = an(e4, "pushed_authorization_request_endpoint", t3.use_mtls_endpoint_aliases, true !== (null == r3 ? void 0 : r3[St])), s3 = new URLSearchParams(o3);
    s3.set("client_id", t3.client_id);
    const c3 = zt(null == r3 ? void 0 : r3.headers);
    c3.set("accept", "application/json"), void 0 !== (null == r3 ? void 0 : r3.DPoP) && (yn(r3.DPoP), await r3.DPoP.addProof(a3, c3, "POST"));
    const u3 = await gn(e4, t3, n3, a3, s3, c3, r3);
    return null == r3 || null === (i3 = r3.DPoP) || void 0 === i3 || i3.cacheNonce(u3, a3), u3;
  })(r2, i2, a2, o2.searchParams, { [At]: s2, [St]: !c2, DPoP: null == n2 ? void 0 : n2.DPoP, headers: new Headers(Yo), signal: Pr(u2) }).catch(dr), d2 = (async function(e4, t3, n3) {
    if (Qt(e4), $t(t3), !_t(n3, Response)) throw kt('"response" must be an instance of Response', "ERR_INVALID_ARG_TYPE");
    await mn(n3, 201, "Pushed Authorization Request Endpoint"), qn(n3);
    const o3 = await oo(n3);
    Ft(o3.request_uri, '"response" body "request_uri" property', Nn, { body: o3 });
    let r3 = "number" != typeof o3.expires_in ? parseFloat(o3.expires_in) : o3.expires_in;
    return Vt(r3, true, '"response" body "expires_in" property', Nn, { body: o3 }), o3.expires_in = r3, o3;
  })(r2, i2, l2);
  let h2;
  try {
    h2 = await d2;
  } catch (o3) {
    if (Rr(o3, n2)) return Tr(e3, t2, ft(ft({}, n2), {}, { flag: Ir }));
    dr(o3);
  }
  return Er(e3, { request_uri: h2.request_uri });
}
function Ar(e3) {
  if (!(e3 instanceof fr)) throw ar('"config" must be an instance of Configuration', ir);
  if (Object.getPrototypeOf(e3) !== fr.prototype) throw ar("subclassing Configuration is not allowed", rr);
}
function Pr(e3) {
  return e3 ? AbortSignal.timeout(1e3 * e3) : void 0;
}
function Rr(e3, t2) {
  return !(null == t2 || !t2.DPoP || t2.flag === Ir) && (function(e4) {
    if (e4 instanceof un) {
      const { 0: t3, length: n2 } = e4.cause;
      return 1 === n2 && "dpop" === t3.scheme && "use_dpop_nonce" === t3.parameters.error;
    }
    return e4 instanceof sn && "use_dpop_nonce" === e4.error;
  })(e3);
}
Object.freeze(fr.prototype);
var Ir = Symbol();
async function xr(e3, t2, n2, o2) {
  Ar(e3);
  const { as: r2, c: i2, auth: a2, fetch: s2, tlsOnly: c2, timeout: u2, decrypt: l2 } = $o(e3), d2 = await (async function(e4, t3, n3, o3, r3, i3) {
    return Qt(e4), $t(t3), Ft(o3, '"grantType"'), vn(e4, t3, n3, o3, new URLSearchParams(r3), i3);
  })(r2, i2, a2, t2, new URLSearchParams(n2), { [At]: s2, [St]: !c2, DPoP: null == o2 ? void 0 : o2.DPoP, headers: new Headers(Yo), signal: Pr(u2) }).then(((e4) => {
    let n3;
    return "urn:ietf:params:oauth:grant-type:token-exchange" === t2 && (n3 = { n_a: () => {
    } }), (async function(e5, t3, n4, o3) {
      return Sn(e5, t3, n4, void 0, null == o3 ? void 0 : o3[Rt], null == o3 ? void 0 : o3.recognizedTokenTypes);
    })(r2, i2, e4, { [Rt]: l2, recognizedTokenTypes: n3 });
  })).catch(dr);
  return mr(d2), d2;
}
async function Or(e3, t2, n2) {
  if (t2 instanceof Uint8Array) {
    if (!e3.startsWith("HS")) throw new TypeError((function(e4) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), o2 = 1; o2 < t3; o2++) n3[o2 - 1] = arguments[o2];
      return Ro("Key must be ", e4, ...n3);
    })(t2, "CryptoKey", "KeyObject", "JSON Web Key"));
    return crypto.subtle.importKey("raw", t2, { hash: "SHA-".concat(e3.slice(-3)), name: "HMAC" }, false, [n2]);
  }
  return Po(t2, e3, n2), t2;
}
async function Cr(e3, t2, n2, o2) {
  const r2 = await Or(e3, t2, "verify");
  !(function(e4, t3) {
    if (e4.startsWith("RS") || e4.startsWith("PS")) {
      const { modulusLength: n3 } = t3.algorithm;
      if ("number" != typeof n3 || n3 < 2048) throw new TypeError("".concat(e4, " requires key modulusLength to be 2048 bits or larger"));
    }
  })(e3, r2);
  const i2 = (function(e4, t3) {
    const n3 = "SHA-".concat(e4.slice(-3));
    switch (e4) {
      case "HS256":
      case "HS384":
      case "HS512":
        return { hash: n3, name: "HMAC" };
      case "PS256":
      case "PS384":
      case "PS512":
        return { hash: n3, name: "RSA-PSS", saltLength: parseInt(e4.slice(-3), 10) >> 3 };
      case "RS256":
      case "RS384":
      case "RS512":
        return { hash: n3, name: "RSASSA-PKCS1-v1_5" };
      case "ES256":
      case "ES384":
      case "ES512":
        return { hash: n3, name: "ECDSA", namedCurve: t3.namedCurve };
      case "Ed25519":
      case "EdDSA":
        return { name: "Ed25519" };
      case "ML-DSA-44":
      case "ML-DSA-65":
      case "ML-DSA-87":
        return { name: e4 };
      default:
        throw new yo("alg ".concat(e4, " is not supported either by JOSE or your javascript runtime"));
    }
  })(e3, r2.algorithm);
  try {
    return await crypto.subtle.verify(i2, r2, n2, o2);
  } catch (e4) {
    return false;
  }
}
async function jr(e3, t2, n2) {
  if (!jo(e3)) throw new wo("Flattened JWS must be an object");
  if (void 0 === e3.protected && void 0 === e3.header) throw new wo('Flattened JWS must have either of the "protected" or "header" members');
  if (void 0 !== e3.protected && "string" != typeof e3.protected) throw new wo("JWS Protected Header incorrect type");
  if (void 0 === e3.payload) throw new wo("JWS Payload missing");
  if ("string" != typeof e3.signature) throw new wo("JWS Signature missing or incorrect type");
  if (void 0 !== e3.header && !jo(e3.header)) throw new wo("JWS Unprotected Header incorrect type");
  let o2 = {};
  if (e3.protected) try {
    const t3 = lo(e3.protected);
    o2 = JSON.parse(so.decode(t3));
  } catch (e4) {
    throw new wo("JWS Protected Header is invalid");
  }
  if (!(function() {
    for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++) t3[n3] = arguments[n3];
    const o3 = t3.filter(Boolean);
    if (0 === o3.length || 1 === o3.length) return true;
    let r3;
    for (const e5 of o3) {
      const t4 = Object.keys(e5);
      if (r3 && 0 !== r3.size) for (const e6 of t4) {
        if (r3.has(e6)) return false;
        r3.add(e6);
      }
      else r3 = new Set(t4);
    }
    return true;
  })(o2, e3.header)) throw new wo("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  const r2 = ft(ft({}, o2), e3.header), i2 = (function(e4, t3, n3, o3, r3) {
    if (void 0 !== r3.crit && void 0 === (null == o3 ? void 0 : o3.crit)) throw new e4('"crit" (Critical) Header Parameter MUST be integrity protected');
    if (!o3 || void 0 === o3.crit) return /* @__PURE__ */ new Set();
    if (!Array.isArray(o3.crit) || 0 === o3.crit.length || o3.crit.some(((e5) => "string" != typeof e5 || 0 === e5.length))) throw new e4('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    let i3;
    i3 = void 0 !== n3 ? new Map([...Object.entries(n3), ...t3.entries()]) : t3;
    for (const t4 of o3.crit) {
      if (!i3.has(t4)) throw new yo('Extension Header Parameter "'.concat(t4, '" is not recognized'));
      if (void 0 === r3[t4]) throw new e4('Extension Header Parameter "'.concat(t4, '" is missing'));
      if (i3.get(t4) && void 0 === o3[t4]) throw new e4('Extension Header Parameter "'.concat(t4, '" MUST be integrity protected'));
    }
    return new Set(o3.crit);
  })(wo, /* @__PURE__ */ new Map([["b64", true]]), null == n2 ? void 0 : n2.crit, o2, r2);
  let a2 = true;
  if (i2.has("b64") && (a2 = o2.b64, "boolean" != typeof a2)) throw new wo('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
  const { alg: s2 } = r2;
  if ("string" != typeof s2 || !s2) throw new wo('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  const c2 = n2 && (function(e4, t3) {
    if (void 0 !== t3 && (!Array.isArray(t3) || t3.some(((e5) => "string" != typeof e5)))) throw new TypeError('"'.concat(e4, '" option must be an array of strings'));
    if (t3) return new Set(t3);
  })("algorithms", n2.algorithms);
  if (c2 && !c2.has(s2)) throw new mo('"alg" (Algorithm) Header Parameter value not allowed');
  if (a2) {
    if ("string" != typeof e3.payload) throw new wo("JWS Payload must be a string");
  } else if ("string" != typeof e3.payload && !(e3.payload instanceof Uint8Array)) throw new wo("JWS Payload must be a string or an Uint8Array instance");
  let u2 = false;
  "function" == typeof t2 && (t2 = await t2(o2, e3), u2 = true), qo(s2, t2, "verify");
  const l2 = (function() {
    for (var e4 = arguments.length, t3 = new Array(e4), n3 = 0; n3 < e4; n3++) t3[n3] = arguments[n3];
    const o3 = t3.reduce(((e5, t4) => {
      let { length: n4 } = t4;
      return e5 + n4;
    }), 0), r3 = new Uint8Array(o3);
    let i3 = 0;
    for (const e5 of t3) r3.set(e5, i3), i3 += e5.length;
    return r3;
  })(void 0 !== e3.protected ? co(e3.protected) : new Uint8Array(), co("."), "string" == typeof e3.payload ? a2 ? co(e3.payload) : ao.encode(e3.payload) : e3.payload);
  let d2;
  try {
    d2 = lo(e3.signature);
  } catch (e4) {
    throw new wo("Failed to base64url decode the signature");
  }
  const h2 = await Fo(t2, s2);
  if (!await Cr(s2, h2, d2, l2)) throw new So();
  let p2;
  if (a2) try {
    p2 = lo(e3.payload);
  } catch (e4) {
    throw new wo("Failed to base64url decode the payload");
  }
  else p2 = "string" == typeof e3.payload ? ao.encode(e3.payload) : e3.payload;
  const f2 = { payload: p2 };
  return void 0 !== e3.protected && (f2.protectedHeader = o2), void 0 !== e3.header && (f2.unprotectedHeader = e3.header), u2 ? ft(ft({}, f2), {}, { key: h2 }) : f2;
}
var Dr = (e3) => Math.floor(e3.getTime() / 1e3);
var Kr = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
function Lr(e3) {
  const t2 = Kr.exec(e3);
  if (!t2 || t2[4] && t2[1]) throw new TypeError("Invalid time period format");
  const n2 = parseFloat(t2[2]);
  let o2;
  switch (t2[3].toLowerCase()) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      o2 = Math.round(n2);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      o2 = Math.round(60 * n2);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      o2 = Math.round(3600 * n2);
      break;
    case "day":
    case "days":
    case "d":
      o2 = Math.round(86400 * n2);
      break;
    case "week":
    case "weeks":
    case "w":
      o2 = Math.round(604800 * n2);
      break;
    default:
      o2 = Math.round(31557600 * n2);
  }
  return "-" === t2[1] || "ago" === t2[4] ? -o2 : o2;
}
var Ur = (e3) => e3.includes("/") ? e3.toLowerCase() : "application/".concat(e3.toLowerCase());
var Nr = (e3, t2) => "string" == typeof e3 ? t2.includes(e3) : !!Array.isArray(e3) && t2.some(Set.prototype.has.bind(new Set(e3)));
async function Wr(e3, t2, n2) {
  var o2;
  const r2 = await (async function(e4, t3, n3) {
    if (e4 instanceof Uint8Array && (e4 = so.decode(e4)), "string" != typeof e4) throw new wo("Compact JWS must be a string or Uint8Array");
    const { 0: o3, 1: r3, 2: i3, length: a3 } = e4.split(".");
    if (3 !== a3) throw new wo("Invalid Compact JWS");
    const s2 = await jr({ payload: r3, protected: o3, signature: i3 }, t3, n3), c2 = { payload: s2.payload, protectedHeader: s2.protectedHeader };
    return "function" == typeof t3 ? ft(ft({}, c2), {}, { key: s2.key }) : c2;
  })(e3, t2, n2);
  if (null !== (o2 = r2.protectedHeader.crit) && void 0 !== o2 && o2.includes("b64") && false === r2.protectedHeader.b64) throw new go("JWTs MUST NOT use unencoded payload");
  const i2 = (function(e4, t3) {
    let n3, o3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    try {
      n3 = JSON.parse(so.decode(t3));
    } catch (e5) {
    }
    if (!jo(n3)) throw new go("JWT Claims Set must be a top-level JSON object");
    const { typ: r3 } = o3;
    if (r3 && ("string" != typeof e4.typ || Ur(e4.typ) !== Ur(r3))) throw new po('unexpected "typ" JWT header value', n3, "typ", "check_failed");
    const { requiredClaims: i3 = [], issuer: a3, subject: s2, audience: c2, maxTokenAge: u2 } = o3, l2 = [...i3];
    void 0 !== u2 && l2.push("iat"), void 0 !== c2 && l2.push("aud"), void 0 !== s2 && l2.push("sub"), void 0 !== a3 && l2.push("iss");
    for (const e5 of new Set(l2.reverse())) if (!(e5 in n3)) throw new po('missing required "'.concat(e5, '" claim'), n3, e5, "missing");
    if (a3 && !(Array.isArray(a3) ? a3 : [a3]).includes(n3.iss)) throw new po('unexpected "iss" claim value', n3, "iss", "check_failed");
    if (s2 && n3.sub !== s2) throw new po('unexpected "sub" claim value', n3, "sub", "check_failed");
    if (c2 && !Nr(n3.aud, "string" == typeof c2 ? [c2] : c2)) throw new po('unexpected "aud" claim value', n3, "aud", "check_failed");
    let d2;
    switch (typeof o3.clockTolerance) {
      case "string":
        d2 = Lr(o3.clockTolerance);
        break;
      case "number":
        d2 = o3.clockTolerance;
        break;
      case "undefined":
        d2 = 0;
        break;
      default:
        throw new TypeError("Invalid clockTolerance option type");
    }
    const { currentDate: h2 } = o3, p2 = Dr(h2 || /* @__PURE__ */ new Date());
    if ((void 0 !== n3.iat || u2) && "number" != typeof n3.iat) throw new po('"iat" claim must be a number', n3, "iat", "invalid");
    if (void 0 !== n3.nbf) {
      if ("number" != typeof n3.nbf) throw new po('"nbf" claim must be a number', n3, "nbf", "invalid");
      if (n3.nbf > p2 + d2) throw new po('"nbf" claim timestamp check failed', n3, "nbf", "check_failed");
    }
    if (void 0 !== n3.exp) {
      if ("number" != typeof n3.exp) throw new po('"exp" claim must be a number', n3, "exp", "invalid");
      if (n3.exp <= p2 - d2) throw new fo('"exp" claim timestamp check failed', n3, "exp", "check_failed");
    }
    if (u2) {
      const e5 = p2 - n3.iat;
      if (e5 - d2 > ("number" == typeof u2 ? u2 : Lr(u2))) throw new fo('"iat" claim timestamp check failed (too far in the past)', n3, "iat", "check_failed");
      if (e5 < 0 - d2) throw new po('"iat" claim timestamp check failed (it should be in the past)', n3, "iat", "check_failed");
    }
    return n3;
  })(r2.protectedHeader, r2.payload, n2), a2 = { payload: i2, protectedHeader: r2.protectedHeader };
  return "function" == typeof t2 ? ft(ft({}, a2), {}, { key: r2.key }) : a2;
}
function zr(e3) {
  return jo(e3);
}
var Hr;
var Mr;
var Jr = /* @__PURE__ */ new WeakMap();
var Vr = /* @__PURE__ */ new WeakMap();
var Fr = class {
  constructor(e3) {
    if (lt(this, Jr, void 0), lt(this, Vr, /* @__PURE__ */ new WeakMap()), !(function(e4) {
      return e4 && "object" == typeof e4 && Array.isArray(e4.keys) && e4.keys.every(zr);
    })(e3)) throw new vo("JSON Web Key Set malformed");
    dt(Jr, this, structuredClone(e3));
  }
  jwks() {
    return ut(Jr, this);
  }
  async getKey(e3, t2) {
    const { alg: n2, kid: o2 } = ft(ft({}, e3), null == t2 ? void 0 : t2.header), r2 = (function(e4) {
      switch ("string" == typeof e4 && e4.slice(0, 2)) {
        case "RS":
        case "PS":
          return "RSA";
        case "ES":
          return "EC";
        case "Ed":
          return "OKP";
        case "ML":
          return "AKP";
        default:
          throw new yo('Unsupported "alg" value for a JSON Web Key Set');
      }
    })(n2), i2 = ut(Jr, this).keys.filter(((e4) => {
      let t3 = r2 === e4.kty;
      if (t3 && "string" == typeof o2 && (t3 = o2 === e4.kid), !t3 || "string" != typeof e4.alg && "AKP" !== r2 || (t3 = n2 === e4.alg), t3 && "string" == typeof e4.use && (t3 = "sig" === e4.use), t3 && Array.isArray(e4.key_ops) && (t3 = e4.key_ops.includes("verify")), t3) switch (n2) {
        case "ES256":
          t3 = "P-256" === e4.crv;
          break;
        case "ES384":
          t3 = "P-384" === e4.crv;
          break;
        case "ES512":
          t3 = "P-521" === e4.crv;
          break;
        case "Ed25519":
        case "EdDSA":
          t3 = "Ed25519" === e4.crv;
      }
      return t3;
    })), { 0: a2, length: s2 } = i2;
    if (0 === s2) throw new bo();
    if (1 !== s2) {
      const e4 = new _o(), t3 = ut(Vr, this);
      throw e4[Symbol.asyncIterator] = yt((function* () {
        for (const e5 of i2) try {
          yield yield st(Gr(t3, e5, n2));
        } catch (e6) {
        }
      })), e4;
    }
    return Gr(ut(Vr, this), a2, n2);
  }
};
async function Gr(e3, t2, n2) {
  const o2 = e3.get(t2) || e3.set(t2, {}).get(t2);
  if (void 0 === o2[n2]) {
    const e4 = await (async function(e5, t3, n3) {
      var o3;
      if (!jo(e5)) throw new TypeError("JWK must be an object");
      let r2;
      switch (null != t3 || (t3 = e5.alg), null != r2 || (r2 = null !== (o3 = null == n3 ? void 0 : n3.extractable) && void 0 !== o3 ? o3 : e5.ext), e5.kty) {
        case "oct":
          if ("string" != typeof e5.k || !e5.k) throw new TypeError('missing "k" (Key Value) Parameter value');
          return lo(e5.k);
        case "RSA":
          if ("oth" in e5 && void 0 !== e5.oth) throw new yo('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
          return Ho(ft(ft({}, e5), {}, { alg: t3, ext: r2 }));
        case "AKP":
          if ("string" != typeof e5.alg || !e5.alg) throw new TypeError('missing "alg" (Algorithm) Parameter value');
          if (void 0 !== t3 && t3 !== e5.alg) throw new TypeError("JWK alg and alg option value mismatch");
          return Ho(ft(ft({}, e5), {}, { ext: r2 }));
        case "EC":
        case "OKP":
          return Ho(ft(ft({}, e5), {}, { alg: t3, ext: r2 }));
        default:
          throw new yo('Unsupported "kty" (Key Type) Parameter value');
      }
    })(ft(ft({}, t2), {}, { ext: true }), n2);
    if (e4 instanceof Uint8Array || "public" !== e4.type) throw new vo("JSON Web Key Set members must be public keys");
    o2[n2] = e4;
  }
  return o2[n2];
}
function Zr(e3) {
  const t2 = new Fr(e3), n2 = async (e4, n3) => t2.getKey(e4, n3);
  return Object.defineProperties(n2, { jwks: { value: () => structuredClone(t2.jwks()), enumerable: false, configurable: false, writable: false } }), n2;
}
var qr;
if ("undefined" == typeof navigator || null === (Hr = navigator.userAgent) || void 0 === Hr || null === (Mr = Hr.startsWith) || void 0 === Mr || !Mr.call(Hr, "Mozilla/5.0 ")) {
  const e3 = "v6.1.3";
  qr = "".concat("jose", "/").concat(e3);
}
var Br = Symbol();
var Xr = Symbol();
var Yr = /* @__PURE__ */ new WeakMap();
var Qr = /* @__PURE__ */ new WeakMap();
var $r = /* @__PURE__ */ new WeakMap();
var ei = /* @__PURE__ */ new WeakMap();
var ti = /* @__PURE__ */ new WeakMap();
var ni = /* @__PURE__ */ new WeakMap();
var oi = /* @__PURE__ */ new WeakMap();
var ri = /* @__PURE__ */ new WeakMap();
var ii = /* @__PURE__ */ new WeakMap();
var ai = /* @__PURE__ */ new WeakMap();
var si = class {
  constructor(e3, t2) {
    if (lt(this, Yr, void 0), lt(this, Qr, void 0), lt(this, $r, void 0), lt(this, ei, void 0), lt(this, ti, void 0), lt(this, ni, void 0), lt(this, oi, void 0), lt(this, ri, void 0), lt(this, ii, void 0), lt(this, ai, void 0), !(e3 instanceof URL)) throw new TypeError("url must be an instance of URL");
    var n2, o2;
    dt(Yr, this, new URL(e3.href)), dt(Qr, this, "number" == typeof (null == t2 ? void 0 : t2.timeoutDuration) ? null == t2 ? void 0 : t2.timeoutDuration : 5e3), dt($r, this, "number" == typeof (null == t2 ? void 0 : t2.cooldownDuration) ? null == t2 ? void 0 : t2.cooldownDuration : 3e4), dt(ei, this, "number" == typeof (null == t2 ? void 0 : t2.cacheMaxAge) ? null == t2 ? void 0 : t2.cacheMaxAge : 6e5), dt(oi, this, new Headers(null == t2 ? void 0 : t2.headers)), qr && !ut(oi, this).has("User-Agent") && ut(oi, this).set("User-Agent", qr), ut(oi, this).has("accept") || (ut(oi, this).set("accept", "application/json"), ut(oi, this).append("accept", "application/jwk-set+json")), dt(ri, this, null == t2 ? void 0 : t2[Br]), void 0 !== (null == t2 ? void 0 : t2[Xr]) && (dt(ai, this, null == t2 ? void 0 : t2[Xr]), n2 = null == t2 ? void 0 : t2[Xr], o2 = ut(ei, this), "object" == typeof n2 && null !== n2 && "uat" in n2 && "number" == typeof n2.uat && !(Date.now() - n2.uat >= o2) && "jwks" in n2 && jo(n2.jwks) && Array.isArray(n2.jwks.keys) && Array.prototype.every.call(n2.jwks.keys, jo) && (dt(ti, this, ut(ai, this).uat), dt(ii, this, Zr(ut(ai, this).jwks))));
  }
  pendingFetch() {
    return !!ut(ni, this);
  }
  coolingDown() {
    return "number" == typeof ut(ti, this) && Date.now() < ut(ti, this) + ut($r, this);
  }
  fresh() {
    return "number" == typeof ut(ti, this) && Date.now() < ut(ti, this) + ut(ei, this);
  }
  jwks() {
    var e3;
    return null === (e3 = ut(ii, this)) || void 0 === e3 ? void 0 : e3.jwks();
  }
  async getKey(e3, t2) {
    ut(ii, this) && this.fresh() || await this.reload();
    try {
      return await ut(ii, this).call(this, e3, t2);
    } catch (n2) {
      if (n2 instanceof bo && false === this.coolingDown()) return await this.reload(), ut(ii, this).call(this, e3, t2);
      throw n2;
    }
  }
  async reload() {
    ut(ni, this) && ("undefined" != typeof WebSocketPair || "undefined" != typeof navigator && "Cloudflare-Workers" === navigator.userAgent || "undefined" != typeof EdgeRuntime && "vercel" === EdgeRuntime) && dt(ni, this, void 0), ut(ni, this) || dt(ni, this, (async function(e3, t2, n2) {
      let o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : fetch;
      const r2 = await o2(e3, { method: "GET", signal: n2, redirect: "manual", headers: t2 }).catch(((e4) => {
        if ("TimeoutError" === e4.name) throw new ko();
        throw e4;
      }));
      if (200 !== r2.status) throw new ho("Expected 200 OK from the JSON Web Key Set HTTP response");
      try {
        return await r2.json();
      } catch (e4) {
        throw new ho("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    })(ut(Yr, this).href, ut(oi, this), AbortSignal.timeout(ut(Qr, this)), ut(ri, this)).then(((e3) => {
      dt(ii, this, Zr(e3)), ut(ai, this) && (ut(ai, this).uat = Date.now(), ut(ai, this).jwks = e3), dt(ti, this, Date.now()), dt(ni, this, void 0);
    })).catch(((e3) => {
      throw dt(ni, this, void 0), e3;
    }))), await ut(ni, this);
  }
};
var ci = ["mfaToken"];
var ui = ["mfaToken"];
var li;
var di;
var hi;
var pi;
var fi;
var mi;
var yi;
var wi;
var gi = class extends Error {
  constructor(e3, t2) {
    super(t2), ht(this, "code", void 0), this.name = "NotSupportedError", this.code = e3;
  }
};
var vi = class extends Error {
  constructor(e3, t2, n2) {
    super(t2), ht(this, "cause", void 0), ht(this, "code", void 0), this.code = e3, this.cause = n2 && { error: n2.error, error_description: n2.error_description, message: n2.message };
  }
};
var bi = class extends vi {
  constructor(e3, t2) {
    super("token_by_code_error", e3, t2), this.name = "TokenByCodeError";
  }
};
var _i = class extends vi {
  constructor(e3, t2) {
    super("token_by_client_credentials_error", e3, t2), this.name = "TokenByClientCredentialsError";
  }
};
var ki = class extends vi {
  constructor(e3, t2) {
    super("token_by_refresh_token_error", e3, t2), this.name = "TokenByRefreshTokenError";
  }
};
var Si = class extends vi {
  constructor(e3, t2) {
    super("token_for_connection_error", e3, t2), this.name = "TokenForConnectionErrorCode";
  }
};
var Ei = class extends vi {
  constructor(e3, t2) {
    super("token_exchange_error", e3, t2), this.name = "TokenExchangeError";
  }
};
var Ti = class extends Error {
  constructor(e3) {
    super(e3), ht(this, "code", "verify_logout_token_error"), this.name = "VerifyLogoutTokenError";
  }
};
var Ai = class extends vi {
  constructor(e3) {
    super("backchannel_authentication_error", "There was an error when trying to use Client-Initiated Backchannel Authentication.", e3), ht(this, "code", "backchannel_authentication_error"), this.name = "BackchannelAuthenticationError";
  }
};
var Pi = class extends vi {
  constructor(e3) {
    super("build_authorization_url_error", "There was an error when trying to build the authorization URL.", e3), this.name = "BuildAuthorizationUrlError";
  }
};
var Ri = class extends vi {
  constructor(e3) {
    super("build_link_user_url_error", "There was an error when trying to build the Link User URL.", e3), this.name = "BuildLinkUserUrlError";
  }
};
var Ii = class extends vi {
  constructor(e3) {
    super("build_unlink_user_url_error", "There was an error when trying to build the Unlink User URL.", e3), this.name = "BuildUnlinkUserUrlError";
  }
};
var xi = class extends Error {
  constructor() {
    super("The client secret or client assertion signing key must be provided."), ht(this, "code", "missing_client_auth_error"), this.name = "MissingClientAuthError";
  }
};
function Oi(e3) {
  return Object.entries(e3).filter(((e4) => {
    let [, t2] = e4;
    return void 0 !== t2;
  })).reduce(((e4, t2) => ft(ft({}, e4), {}, { [t2[0]]: t2[1] })), {});
}
var Ci = class extends Error {
  constructor(e3, t2, n2) {
    super(t2), ht(this, "cause", void 0), ht(this, "code", void 0), this.code = e3, this.cause = n2 && { error: n2.error, error_description: n2.error_description, message: n2.message };
  }
};
var ji = class extends Ci {
  constructor(e3, t2) {
    super("mfa_list_authenticators_error", e3, t2), this.name = "MfaListAuthenticatorsError";
  }
};
var Di = class extends Ci {
  constructor(e3, t2) {
    super("mfa_enrollment_error", e3, t2), this.name = "MfaEnrollmentError";
  }
};
var Ki = class extends Ci {
  constructor(e3, t2) {
    super("mfa_delete_authenticator_error", e3, t2), this.name = "MfaDeleteAuthenticatorError";
  }
};
var Li = class extends Ci {
  constructor(e3, t2) {
    super("mfa_challenge_error", e3, t2), this.name = "MfaChallengeError";
  }
};
function Ui(e3) {
  return { id: e3.id, authenticatorType: e3.authenticator_type, active: e3.active, name: e3.name, oobChannels: e3.oob_channels, type: e3.type };
}
var Ni = (li = /* @__PURE__ */ new WeakMap(), di = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap(), class {
  constructor(e3) {
    var t2;
    lt(this, li, void 0), lt(this, di, void 0), lt(this, hi, void 0), dt(li, this, "https://".concat(e3.domain)), dt(di, this, e3.clientId), dt(hi, this, null !== (t2 = e3.customFetch) && void 0 !== t2 ? t2 : function() {
      return fetch(...arguments);
    });
  }
  async listAuthenticators(e3) {
    const t2 = "".concat(ut(li, this), "/mfa/authenticators"), { mfaToken: n2 } = e3, o2 = await ut(hi, this).call(this, t2, { method: "GET", headers: { Authorization: "Bearer ".concat(n2), "Content-Type": "application/json" } });
    if (!o2.ok) {
      const e4 = await o2.json();
      throw new ji(e4.error_description || "Failed to list authenticators", e4);
    }
    return (await o2.json()).map(Ui);
  }
  async enrollAuthenticator(e3) {
    const t2 = "".concat(ut(li, this), "/mfa/associate"), { mfaToken: n2 } = e3, o2 = mt(e3, ci), r2 = { authenticator_types: o2.authenticatorTypes };
    "oobChannels" in o2 && (r2.oob_channels = o2.oobChannels), "phoneNumber" in o2 && o2.phoneNumber && (r2.phone_number = o2.phoneNumber), "email" in o2 && o2.email && (r2.email = o2.email);
    const i2 = await ut(hi, this).call(this, t2, { method: "POST", headers: { Authorization: "Bearer ".concat(n2), "Content-Type": "application/json" }, body: JSON.stringify(r2) });
    if (!i2.ok) {
      const e4 = await i2.json();
      throw new Di(e4.error_description || "Failed to enroll authenticator", e4);
    }
    return (function(e4) {
      if ("otp" === e4.authenticator_type) return { authenticatorType: "otp", secret: e4.secret, barcodeUri: e4.barcode_uri, recoveryCodes: e4.recovery_codes, id: e4.id };
      if ("oob" === e4.authenticator_type) return { authenticatorType: "oob", oobChannel: e4.oob_channel, oobCode: e4.oob_code, bindingMethod: e4.binding_method, id: e4.id };
      throw new Error("Unexpected authenticator type: ".concat(e4.authenticator_type));
    })(await i2.json());
  }
  async deleteAuthenticator(e3) {
    const { authenticatorId: t2, mfaToken: n2 } = e3, o2 = "".concat(ut(li, this), "/mfa/authenticators/").concat(encodeURIComponent(t2)), r2 = await ut(hi, this).call(this, o2, { method: "DELETE", headers: { Authorization: "Bearer ".concat(n2), "Content-Type": "application/json" } });
    if (!r2.ok) {
      const e4 = await r2.json();
      throw new Ki(e4.error_description || "Failed to delete authenticator", e4);
    }
  }
  async challengeAuthenticator(e3) {
    const t2 = "".concat(ut(li, this), "/mfa/challenge"), { mfaToken: n2 } = e3, o2 = mt(e3, ui), r2 = { mfa_token: n2, client_id: ut(di, this), challenge_type: o2.challengeType };
    o2.authenticatorId && (r2.authenticator_id = o2.authenticatorId);
    const i2 = await ut(hi, this).call(this, t2, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(r2) });
    if (!i2.ok) {
      const e4 = await i2.json();
      throw new Li(e4.error_description || "Failed to challenge authenticator", e4);
    }
    return (function(e4) {
      const t3 = { challengeType: e4.challenge_type };
      return void 0 !== e4.oob_code && (t3.oobCode = e4.oob_code), void 0 !== e4.binding_method && (t3.bindingMethod = e4.binding_method), t3;
    })(await i2.json());
  }
});
var Wi = class e2 {
  constructor(e3, t2, n2, o2, r2, i2, a2) {
    ht(this, "accessToken", void 0), ht(this, "idToken", void 0), ht(this, "refreshToken", void 0), ht(this, "expiresAt", void 0), ht(this, "scope", void 0), ht(this, "claims", void 0), ht(this, "authorizationDetails", void 0), ht(this, "tokenType", void 0), ht(this, "issuedTokenType", void 0), this.accessToken = e3, this.idToken = n2, this.refreshToken = o2, this.expiresAt = t2, this.scope = r2, this.claims = i2, this.authorizationDetails = a2;
  }
  static fromTokenEndpointResponse(t2) {
    const n2 = t2.id_token ? t2.claims() : void 0, o2 = new e2(t2.access_token, Math.floor(Date.now() / 1e3) + Number(t2.expires_in), t2.id_token, t2.refresh_token, t2.scope, n2, t2.authorization_details);
    return o2.tokenType = t2.token_type, o2.issuedTokenType = t2.issued_token_type, o2;
  }
};
var zi = "openid profile email offline_access";
var Hi = Object.freeze(/* @__PURE__ */ new Set(["grant_type", "client_id", "client_secret", "client_assertion", "client_assertion_type", "subject_token", "subject_token_type", "requested_token_type", "actor_token", "actor_token_type", "audience", "aud", "resource", "resources", "resource_indicator", "scope", "connection", "login_hint", "organization", "assertion"]));
function Mi(e3) {
  if (null == e3) throw new Ei("subject_token is required");
  if ("string" != typeof e3) throw new Ei("subject_token must be a string");
  if (0 === e3.trim().length) throw new Ei("subject_token cannot be blank or whitespace");
  if (e3 !== e3.trim()) throw new Ei("subject_token must not include leading or trailing whitespace");
  if (/^bearer\s+/i.test(e3)) throw new Ei("subject_token must not include the 'Bearer ' prefix");
}
function Ji(e3, t2) {
  if (t2) {
    for (const [n2, o2] of Object.entries(t2)) if (!Hi.has(n2)) if (Array.isArray(o2)) {
      if (o2.length > 20) throw new Ei("Parameter '".concat(n2, "' exceeds maximum array size of ").concat(20));
      o2.forEach(((t3) => {
        e3.append(n2, t3);
      }));
    } else e3.append(n2, o2);
  }
}
var Vi = (pi = /* @__PURE__ */ new WeakMap(), fi = /* @__PURE__ */ new WeakMap(), mi = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ new WeakMap(), wi = /* @__PURE__ */ new WeakSet(), class {
  constructor(e3) {
    if ((function(e4, t2) {
      ct(e4, t2), t2.add(e4);
    })(this, wi), lt(this, pi, void 0), lt(this, fi, void 0), lt(this, mi, void 0), lt(this, yi, void 0), ht(this, "mfa", void 0), dt(mi, this, e3), e3.useMtls && !e3.customFetch) throw new gi("mtls_without_custom_fetch_not_supported", "Using mTLS without a custom fetch implementation is not supported");
    this.mfa = new Ni({ domain: ut(mi, this).domain, clientId: ut(mi, this).clientId, customFetch: ut(mi, this).customFetch });
  }
  async buildAuthorizationUrl(e3) {
    const { serverMetadata: t2 } = await at(wi, this, Fi).call(this);
    if (null != e3 && e3.pushedAuthorizationRequests && !t2.pushed_authorization_request_endpoint) throw new gi("par_not_supported_error", "The Auth0 tenant does not have pushed authorization requests enabled. Learn how to enable it here: https://auth0.com/docs/get-started/applications/configure-par");
    try {
      return await at(wi, this, Bi).call(this, e3);
    } catch (e4) {
      throw new Pi(e4);
    }
  }
  async buildLinkUserUrl(e3) {
    try {
      const t2 = await at(wi, this, Bi).call(this, { authorizationParams: ft(ft({}, e3.authorizationParams), {}, { requested_connection: e3.connection, requested_connection_scope: e3.connectionScope, scope: "openid link_account offline_access", id_token_hint: e3.idToken }) });
      return { linkUserUrl: t2.authorizationUrl, codeVerifier: t2.codeVerifier };
    } catch (e4) {
      throw new Ri(e4);
    }
  }
  async buildUnlinkUserUrl(e3) {
    try {
      const t2 = await at(wi, this, Bi).call(this, { authorizationParams: ft(ft({}, e3.authorizationParams), {}, { requested_connection: e3.connection, scope: "openid unlink_account", id_token_hint: e3.idToken }) });
      return { unlinkUserUrl: t2.authorizationUrl, codeVerifier: t2.codeVerifier };
    } catch (e4) {
      throw new Ii(e4);
    }
  }
  async backchannelAuthentication(e3) {
    const { configuration: t2, serverMetadata: n2 } = await at(wi, this, Fi).call(this), o2 = Oi(ft(ft({}, ut(mi, this).authorizationParams), null == e3 ? void 0 : e3.authorizationParams)), r2 = new URLSearchParams(ft(ft({ scope: zi }, o2), {}, { client_id: ut(mi, this).clientId, binding_message: e3.bindingMessage, login_hint: JSON.stringify({ format: "iss_sub", iss: n2.issuer, sub: e3.loginHint.sub }) }));
    e3.requestedExpiry && r2.append("requested_expiry", e3.requestedExpiry.toString()), e3.authorizationDetails && r2.append("authorization_details", JSON.stringify(e3.authorizationDetails));
    try {
      const e4 = await gr(t2, r2), n3 = await vr(t2, e4);
      return Wi.fromTokenEndpointResponse(n3);
    } catch (e4) {
      throw new Ai(e4);
    }
  }
  async initiateBackchannelAuthentication(e3) {
    const { configuration: t2, serverMetadata: n2 } = await at(wi, this, Fi).call(this), o2 = Oi(ft(ft({}, ut(mi, this).authorizationParams), null == e3 ? void 0 : e3.authorizationParams)), r2 = new URLSearchParams(ft(ft({ scope: zi }, o2), {}, { client_id: ut(mi, this).clientId, binding_message: e3.bindingMessage, login_hint: JSON.stringify({ format: "iss_sub", iss: n2.issuer, sub: e3.loginHint.sub }) }));
    e3.requestedExpiry && r2.append("requested_expiry", e3.requestedExpiry.toString()), e3.authorizationDetails && r2.append("authorization_details", JSON.stringify(e3.authorizationDetails));
    try {
      const e4 = await gr(t2, r2);
      return { authReqId: e4.auth_req_id, expiresIn: e4.expires_in, interval: e4.interval };
    } catch (e4) {
      throw new Ai(e4);
    }
  }
  async backchannelAuthenticationGrant(e3) {
    let { authReqId: t2 } = e3;
    const { configuration: n2 } = await at(wi, this, Fi).call(this), o2 = new URLSearchParams({ auth_req_id: t2 });
    try {
      const e4 = await xr(n2, "urn:openid:params:grant-type:ciba", o2);
      return Wi.fromTokenEndpointResponse(e4);
    } catch (e4) {
      throw new Ai(e4);
    }
  }
  async getTokenForConnection(e3) {
    var t2;
    if (e3.refreshToken && e3.accessToken) throw new Si("Either a refresh or access token should be specified, but not both.");
    const n2 = null !== (t2 = e3.accessToken) && void 0 !== t2 ? t2 : e3.refreshToken;
    if (!n2) throw new Si("Either a refresh or access token must be specified.");
    try {
      return await this.exchangeToken({ connection: e3.connection, subjectToken: n2, subjectTokenType: e3.accessToken ? "urn:ietf:params:oauth:token-type:access_token" : "urn:ietf:params:oauth:token-type:refresh_token", loginHint: e3.loginHint });
    } catch (e4) {
      if (e4 instanceof Ei) throw new Si(e4.message, e4.cause);
      throw e4;
    }
  }
  async exchangeToken(e3) {
    return "connection" in e3 ? at(wi, this, Gi).call(this, e3) : at(wi, this, Zi).call(this, e3);
  }
  async getTokenByCode(e3, t2) {
    const { configuration: n2 } = await at(wi, this, Fi).call(this);
    try {
      const o2 = await _r(n2, e3, { pkceCodeVerifier: t2.codeVerifier });
      return Wi.fromTokenEndpointResponse(o2);
    } catch (e4) {
      throw new bi("There was an error while trying to request a token.", e4);
    }
  }
  async getTokenByRefreshToken(e3) {
    const { configuration: t2 } = await at(wi, this, Fi).call(this);
    try {
      const n2 = await kr(t2, e3.refreshToken);
      return Wi.fromTokenEndpointResponse(n2);
    } catch (e4) {
      throw new ki("The access token has expired and there was an error while trying to refresh it.", e4);
    }
  }
  async getTokenByClientCredentials(e3) {
    const { configuration: t2 } = await at(wi, this, Fi).call(this);
    try {
      const n2 = new URLSearchParams({ audience: e3.audience });
      e3.organization && n2.append("organization", e3.organization);
      const o2 = await Sr(t2, n2);
      return Wi.fromTokenEndpointResponse(o2);
    } catch (e4) {
      throw new _i("There was an error while trying to request a token.", e4);
    }
  }
  async buildLogoutUrl(e3) {
    const { configuration: t2, serverMetadata: n2 } = await at(wi, this, Fi).call(this);
    if (!n2.end_session_endpoint) {
      const t3 = new URL("https://".concat(ut(mi, this).domain, "/v2/logout"));
      return t3.searchParams.set("returnTo", e3.returnTo), t3.searchParams.set("client_id", ut(mi, this).clientId), t3;
    }
    return (function(e4, t3) {
      Ar(e4);
      const { as: n3, c: o2, tlsOnly: r2 } = $o(e4), i2 = an(n3, "end_session_endpoint", false, r2);
      (t3 = new URLSearchParams(t3)).has("client_id") || t3.set("client_id", o2.client_id);
      for (const [e5, n4] of t3.entries()) i2.searchParams.append(e5, n4);
      return i2;
    })(t2, { post_logout_redirect_uri: e3.returnTo });
  }
  async verifyLogoutToken(e3) {
    const { serverMetadata: t2 } = await at(wi, this, Fi).call(this);
    ut(yi, this) || dt(yi, this, (function(e4, t3) {
      const n3 = new si(e4, t3), o2 = async (e5, t4) => n3.getKey(e5, t4);
      return Object.defineProperties(o2, { coolingDown: { get: () => n3.coolingDown(), enumerable: true, configurable: false }, fresh: { get: () => n3.fresh(), enumerable: true, configurable: false }, reload: { value: () => n3.reload(), enumerable: true, configurable: false, writable: false }, reloading: { get: () => n3.pendingFetch(), enumerable: true, configurable: false }, jwks: { value: () => n3.jwks(), enumerable: true, configurable: false, writable: false } }), o2;
    })(new URL(t2.jwks_uri), { [Br]: ut(mi, this).customFetch }));
    const { payload: n2 } = await Wr(e3.logoutToken, ut(yi, this), { issuer: t2.issuer, audience: ut(mi, this).clientId, algorithms: ["RS256"], requiredClaims: ["iat"] });
    if (!("sid" in n2) && !("sub" in n2)) throw new Ti('either "sid" or "sub" (or both) claims must be present');
    if ("sid" in n2 && "string" != typeof n2.sid) throw new Ti('"sid" claim must be a string');
    if ("sub" in n2 && "string" != typeof n2.sub) throw new Ti('"sub" claim must be a string');
    if ("nonce" in n2) throw new Ti('"nonce" claim is prohibited');
    if (!("events" in n2)) throw new Ti('"events" claim is missing');
    if ("object" != typeof n2.events || null === n2.events) throw new Ti('"events" claim must be an object');
    if (!("http://schemas.openid.net/event/backchannel-logout" in n2.events)) throw new Ti('"http://schemas.openid.net/event/backchannel-logout" member is missing in the "events" claim');
    if ("object" != typeof n2.events["http://schemas.openid.net/event/backchannel-logout"]) throw new Ti('"http://schemas.openid.net/event/backchannel-logout" member in the "events" claim must be an object');
    return { sid: n2.sid, sub: n2.sub };
  }
});
async function Fi() {
  if (ut(pi, this) && ut(fi, this)) return { configuration: ut(pi, this), serverMetadata: ut(fi, this) };
  const e3 = await at(wi, this, qi).call(this);
  return dt(pi, this, await hr(new URL("https://".concat(ut(mi, this).domain)), ut(mi, this).clientId, { use_mtls_endpoint_aliases: ut(mi, this).useMtls }, e3, { [or]: ut(mi, this).customFetch })), dt(fi, this, ut(pi, this).serverMetadata()), ut(pi, this)[or] = ut(mi, this).customFetch || fetch, { configuration: ut(pi, this), serverMetadata: ut(fi, this) };
}
async function Gi(e3) {
  var t2, n2;
  const { configuration: o2 } = await at(wi, this, Fi).call(this);
  if ("audience" in e3 || "resource" in e3) throw new Ei("audience and resource parameters are not supported for Token Vault exchanges");
  Mi(e3.subjectToken);
  const r2 = new URLSearchParams({ connection: e3.connection, subject_token: e3.subjectToken, subject_token_type: null !== (t2 = e3.subjectTokenType) && void 0 !== t2 ? t2 : "urn:ietf:params:oauth:token-type:access_token", requested_token_type: null !== (n2 = e3.requestedTokenType) && void 0 !== n2 ? n2 : "http://auth0.com/oauth/token-type/federated-connection-access-token" });
  e3.loginHint && r2.append("login_hint", e3.loginHint), e3.scope && r2.append("scope", e3.scope), Ji(r2, e3.extra);
  try {
    const e4 = await xr(o2, "urn:auth0:params:oauth:grant-type:token-exchange:federated-connection-access-token", r2);
    return Wi.fromTokenEndpointResponse(e4);
  } catch (t3) {
    throw new Ei("Failed to exchange token for connection '".concat(e3.connection, "'."), t3);
  }
}
async function Zi(e3) {
  const { configuration: t2 } = await at(wi, this, Fi).call(this);
  Mi(e3.subjectToken);
  const n2 = new URLSearchParams({ subject_token_type: e3.subjectTokenType, subject_token: e3.subjectToken });
  e3.audience && n2.append("audience", e3.audience), e3.scope && n2.append("scope", e3.scope), e3.requestedTokenType && n2.append("requested_token_type", e3.requestedTokenType), e3.organization && n2.append("organization", e3.organization), Ji(n2, e3.extra);
  try {
    const e4 = await xr(t2, "urn:ietf:params:oauth:grant-type:token-exchange", n2);
    return Wi.fromTokenEndpointResponse(e4);
  } catch (t3) {
    throw new Ei("Failed to exchange token of type '".concat(e3.subjectTokenType, "'").concat(e3.audience ? " for audience '".concat(e3.audience, "'") : "", "."), t3);
  }
}
async function qi() {
  if (!ut(mi, this).clientSecret && !ut(mi, this).clientAssertionSigningKey && !ut(mi, this).useMtls) throw new xi();
  if (ut(mi, this).useMtls) return (e4, t2, n2, o2) => {
    n2.set("client_id", t2.client_id);
  };
  let e3 = ut(mi, this).clientAssertionSigningKey;
  return !e3 || e3 instanceof CryptoKey || (e3 = await (async function(e4, t2, n2) {
    if ("string" != typeof e4 || 0 !== e4.indexOf("-----BEGIN PRIVATE KEY-----")) throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    return zo(e4, t2, n2);
  })(e3, ut(mi, this).clientAssertionSigningAlg || "RS256")), e3 ? (function(e4, t2) {
    return tn(e4, t2);
  })(e3) : nr(ut(mi, this).clientSecret);
}
async function Bi(e3) {
  const { configuration: t2 } = await at(wi, this, Fi).call(this), n2 = cr(), o2 = await sr(n2), r2 = Oi(ft(ft({}, ut(mi, this).authorizationParams), null == e3 ? void 0 : e3.authorizationParams)), i2 = new URLSearchParams(ft(ft({ scope: zi }, r2), {}, { client_id: ut(mi, this).clientId, code_challenge: o2, code_challenge_method: "S256" }));
  return { authorizationUrl: null != e3 && e3.pushedAuthorizationRequests ? await Tr(t2, i2) : await Er(t2, i2), codeVerifier: n2 };
}
var Xi = class _Xi extends r {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _Xi.prototype);
  }
  static fromPayload(e3) {
    let { error: t2, error_description: n2 } = e3;
    return new _Xi(t2, n2);
  }
};
var Yi = class _Yi extends Xi {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _Yi.prototype);
  }
};
var Qi = class _Qi extends Xi {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _Qi.prototype);
  }
};
var $i = class _$i extends Xi {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _$i.prototype);
  }
};
var ea = class _ea extends Xi {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _ea.prototype);
  }
};
var ta = class _ta extends Xi {
  constructor(e3, t2) {
    super(e3, t2), Object.setPrototypeOf(this, _ta.prototype);
  }
};
var na = class {
  constructor() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 6e5;
    this.contexts = /* @__PURE__ */ new Map(), this.ttlMs = e3;
  }
  set(e3, t2) {
    this.cleanup(), this.contexts.set(e3, Object.assign(Object.assign({}, t2), { createdAt: Date.now() }));
  }
  get(e3) {
    const t2 = this.contexts.get(e3);
    if (t2) {
      if (!(Date.now() - t2.createdAt > this.ttlMs)) return t2;
      this.contexts.delete(e3);
    }
  }
  remove(e3) {
    this.contexts.delete(e3);
  }
  cleanup() {
    const e3 = Date.now();
    for (const [t2, n2] of this.contexts) e3 - n2.createdAt > this.ttlMs && this.contexts.delete(t2);
  }
  get size() {
    return this.contexts.size;
  }
};
var oa = class {
  constructor(e3, t2) {
    this.authJsMfaClient = e3, this.auth0Client = t2, this.contextManager = new na();
  }
  setMFAAuthDetails(e3, t2, n2, o2) {
    this.contextManager.set(e3, { scope: t2, audience: n2, mfaRequirements: o2 });
  }
  async getAuthenticators(e3) {
    var t2, n2;
    const o2 = this.contextManager.get(e3);
    if (!(null === (t2 = null == o2 ? void 0 : o2.mfaRequirements) || void 0 === t2 ? void 0 : t2.challenge) || 0 === o2.mfaRequirements.challenge.length) throw new Yi("invalid_request", "challengeType is required and must contain at least one challenge type, please check mfa_required error payload");
    const r2 = o2.mfaRequirements.challenge.map(((e4) => e4.type));
    try {
      return (await this.authJsMfaClient.listAuthenticators({ mfaToken: e3 })).filter(((e4) => !!e4.type && r2.includes(e4.type)));
    } catch (e4) {
      if (e4 instanceof ji) throw new Yi(null === (n2 = e4.cause) || void 0 === n2 ? void 0 : n2.error, e4.message);
      throw e4;
    }
  }
  async enroll(e3) {
    var t2;
    const n2 = (function(e4) {
      const t3 = tt[e4.factorType];
      return Object.assign(Object.assign(Object.assign({ mfaToken: e4.mfaToken, authenticatorTypes: t3.authenticatorTypes }, t3.oobChannels && { oobChannels: t3.oobChannels }), "phoneNumber" in e4 && { phoneNumber: e4.phoneNumber }), "email" in e4 && { email: e4.email });
    })(e3);
    try {
      return await this.authJsMfaClient.enrollAuthenticator(n2);
    } catch (e4) {
      if (e4 instanceof Di) throw new Qi(null === (t2 = e4.cause) || void 0 === t2 ? void 0 : t2.error, e4.message);
      throw e4;
    }
  }
  async challenge(e3) {
    var t2;
    try {
      const t3 = { challengeType: e3.challengeType, mfaToken: e3.mfaToken };
      return e3.authenticatorId && (t3.authenticatorId = e3.authenticatorId), await this.authJsMfaClient.challengeAuthenticator(t3);
    } catch (e4) {
      if (e4 instanceof Li) throw new $i(null === (t2 = e4.cause) || void 0 === t2 ? void 0 : t2.error, e4.message);
      throw e4;
    }
  }
  async getEnrollmentFactors(e3) {
    const t2 = this.contextManager.get(e3);
    if (!t2 || !t2.mfaRequirements) throw new ta("mfa_context_not_found", "MFA context not found for this MFA token. Please retry the original request to get a new MFA token.");
    return t2.mfaRequirements.enroll && 0 !== t2.mfaRequirements.enroll.length ? t2.mfaRequirements.enroll : [];
  }
  async verify(e3) {
    const t2 = this.contextManager.get(e3.mfaToken);
    if (!t2) throw new ea("mfa_context_not_found", "MFA context not found for this MFA token. Please retry the original request to get a new MFA token.");
    const n2 = (function(e4) {
      return "otp" in e4 && e4.otp ? nt : "oobCode" in e4 && e4.oobCode ? ot : "recoveryCode" in e4 && e4.recoveryCode ? rt : void 0;
    })(e3);
    if (!n2) throw new ea("invalid_request", "Unable to determine grant type. Provide one of: otp, oobCode, or recoveryCode.");
    const o2 = t2.scope, r2 = t2.audience;
    try {
      const t3 = await this.auth0Client._requestTokenForMfa({ grant_type: n2, mfaToken: e3.mfaToken, scope: o2, audience: r2, otp: e3.otp, oob_code: e3.oobCode, binding_code: e3.bindingCode, recovery_code: e3.recoveryCode });
      return this.contextManager.remove(e3.mfaToken), t3;
    } catch (e4) {
      if (e4 instanceof d) this.setMFAAuthDetails(e4.mfa_token, o2, r2, e4.mfa_requirements);
      else if (e4 instanceof ea) throw new ea(e4.error, e4.error_description);
      throw e4;
    }
  }
};
var ra = class {
  constructor(e3) {
    let t2, n2;
    if (this.userCache = new we().enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: false, useFormData: true }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e3), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e3.authorizationParams) }), "undefined" != typeof window && (() => {
      if (!y()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
      if (void 0 === y().subtle) throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    })(), this.lockManager = (H || (H = z()), H), e3.cache && e3.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e3.cache) n2 = e3.cache;
    else {
      if (t2 = e3.cacheLocation || "memory", !Fe(t2)) throw new Error('Invalid cache location "'.concat(t2, '"'));
      n2 = Fe(t2)();
    }
    var r2;
    this.httpTimeoutMs = e3.httpTimeoutInSeconds ? 1e3 * e3.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e3.legacySameSiteCookie ? Oe : Ce, this.orgHintCookieName = (r2 = this.options.clientId, "auth0.".concat(r2, ".organization_hint")), this.isAuthenticatedCookieName = ((e4) => "auth0.".concat(e4, ".is.authenticated"))(this.options.clientId), this.sessionCheckExpiryDays = e3.sessionCheckExpiryDays || 1;
    const i2 = e3.useCookiesForTransactions ? this.cookieStorage : je;
    var a2;
    this.scope = (function(e4, t3) {
      for (var n3 = arguments.length, o2 = new Array(n3 > 2 ? n3 - 2 : 0), r3 = 2; r3 < n3; r3++) o2[r3 - 2] = arguments[r3];
      if ("object" != typeof e4) return { default: pe(t3, e4, ...o2) };
      let i3 = { default: pe(t3, ...o2) };
      return Object.keys(e4).forEach(((n4) => {
        const r4 = e4[n4];
        i3[n4] = pe(t3, r4, ...o2);
      })), i3;
    })(this.options.authorizationParams.scope, "openid", this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new ve(i2, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || o, this.cacheManager = new ge(n2, n2.allKeys ? void 0 : new Je(n2, this.options.clientId), this.nowProvider), this.dpop = this.options.useDpop ? new Xe(this.options.clientId) : void 0, this.domainUrl = (a2 = this.options.domain, /^https?:\/\//.test(a2) ? a2 : "https://".concat(a2)), this.tokenIssuer = ((e4, t3) => e4 ? e4.startsWith("https://") ? e4 : "https://".concat(e4, "/") : "".concat(t3, "/"))(this.options.issuer, this.domainUrl);
    const s2 = "".concat(this.domainUrl, "/me/"), c2 = this.createFetcher(Object.assign(Object.assign({}, this.options.useDpop && { dpopNonceId: "__auth0_my_account_api__" }), { getAccessToken: () => this.getTokenSilently({ authorizationParams: { scope: "create:me:connected_accounts", audience: s2 }, detailedResponse: true }) }));
    this.myAccountApi = new $e(c2, s2), this.authJsClient = new Vi({ domain: this.options.domain, clientId: this.options.clientId }), this.mfa = new oa(this.authJsClient.mfa, this), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new He());
  }
  getConfiguration() {
    return Object.freeze({ domain: this.options.domain, clientId: this.options.clientId });
  }
  _url(e3) {
    const t2 = this.options.auth0Client || n, o2 = b(t2, true), r2 = encodeURIComponent(btoa(JSON.stringify(o2)));
    return "".concat(this.domainUrl).concat(e3, "&auth0Client=").concat(r2);
  }
  _authorizeUrl(e3) {
    return this._url("/authorize?".concat(_(e3)));
  }
  async _verifyIdToken(e3, t2, n2) {
    const o2 = await this.nowProvider();
    return ke({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e3, nonce: t2, organization: n2, leeway: this.options.leeway, max_age: (r2 = this.options.authorizationParams.max_age, "string" != typeof r2 ? r2 : parseInt(r2, 10) || void 0), now: o2 });
    var r2;
  }
  _processOrgHint(e3) {
    e3 ? this.cookieStorage.save(this.orgHintCookieName, e3, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
  }
  async _prepareAuthorizeUrl(e3, t2, n2) {
    var o2;
    const r2 = g(w()), i2 = g(w()), a2 = w(), s2 = await k(a2), c2 = E(s2), u2 = await (null === (o2 = this.dpop) || void 0 === o2 ? void 0 : o2.calculateThumbprint()), l2 = ((e4, t3, n3, o3, r3, i3, a3, s3, c3) => Object.assign(Object.assign(Object.assign({ client_id: e4.clientId }, e4.authorizationParams), n3), { scope: fe(t3, n3.scope, n3.audience), response_type: "code", response_mode: s3 || "query", state: o3, nonce: r3, redirect_uri: a3 || e4.authorizationParams.redirect_uri, code_challenge: i3, code_challenge_method: "S256", dpop_jkt: c3 }))(this.options, this.scope, e3, r2, i2, c2, e3.redirect_uri || this.options.authorizationParams.redirect_uri || n2, null == t2 ? void 0 : t2.response_mode, u2), d2 = this._authorizeUrl(l2);
    return { nonce: i2, code_verifier: a2, scope: l2.scope, audience: l2.audience || "default", redirect_uri: l2.redirect_uri, state: r2, url: d2 };
  }
  async loginWithPopup(e3, t2) {
    var n2;
    if (e3 = e3 || {}, !(t2 = t2 || {}).popup && (t2.popup = ((e4) => {
      const t3 = window.screenX + (window.innerWidth - 400) / 2, n3 = window.screenY + (window.innerHeight - 600) / 2;
      return window.open(e4, "auth0:authorize:popup", "left=".concat(t3, ",top=").concat(n3, ",width=").concat(400, ",height=").concat(600, ",resizable,scrollbars=yes,status=1"));
    })(""), !t2.popup)) throw new l();
    const o2 = await this._prepareAuthorizeUrl(e3.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin);
    t2.popup.location.href = o2.url;
    const i2 = await ((e4) => new Promise(((t3, n3) => {
      let o3;
      const i3 = setInterval((() => {
        e4.popup && e4.popup.closed && (clearInterval(i3), clearTimeout(a3), window.removeEventListener("message", o3, false), n3(new u(e4.popup)));
      }), 1e3), a3 = setTimeout((() => {
        clearInterval(i3), n3(new c(e4.popup)), window.removeEventListener("message", o3, false);
      }), 1e3 * (e4.timeoutInSeconds || 60));
      o3 = function(s2) {
        if (s2.data && "authorization_response" === s2.data.type) {
          if (clearTimeout(a3), clearInterval(i3), window.removeEventListener("message", o3, false), false !== e4.closePopup && e4.popup.close(), s2.data.response.error) return n3(r.fromPayload(s2.data.response));
          t3(s2.data.response);
        }
      }, window.addEventListener("message", o3);
    })))(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));
    if (o2.state !== i2.state) throw new r("state_mismatch", "Invalid state");
    const a2 = (null === (n2 = e3.authorizationParams) || void 0 === n2 ? void 0 : n2.organization) || this.options.authorizationParams.organization;
    await this._requestToken({ audience: o2.audience, scope: o2.scope, code_verifier: o2.code_verifier, grant_type: "authorization_code", code: i2.code, redirect_uri: o2.redirect_uri }, { nonceIn: o2.nonce, organization: a2 });
  }
  async getUser() {
    var e3;
    const t2 = await this._getIdTokenFromCache();
    return null === (e3 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e3 ? void 0 : e3.user;
  }
  async getIdTokenClaims() {
    var e3;
    const t2 = await this._getIdTokenFromCache();
    return null === (e3 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e3 ? void 0 : e3.claims;
  }
  async loginWithRedirect() {
    var t2;
    const n2 = Ge(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), { openUrl: o2, fragment: r2, appState: i2 } = n2, a2 = e(n2, ["openUrl", "fragment", "appState"]), s2 = (null === (t2 = a2.authorizationParams) || void 0 === t2 ? void 0 : t2.organization) || this.options.authorizationParams.organization, c2 = await this._prepareAuthorizeUrl(a2.authorizationParams || {}), { url: u2 } = c2, l2 = e(c2, ["url"]);
    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l2), { appState: i2, response_type: De.Code }), s2 && { organization: s2 }));
    const d2 = r2 ? "".concat(u2, "#").concat(r2) : u2;
    o2 ? await o2(d2) : window.location.assign(d2);
  }
  async handleRedirectCallback() {
    const e3 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.location.href).split("?").slice(1);
    if (0 === e3.length) throw new Error("There are no query params available for parsing.");
    const t2 = this.transactionManager.get();
    if (!t2) throw new r("missing_transaction", "Invalid state");
    this.transactionManager.remove();
    const n2 = ((e4) => {
      e4.indexOf("#") > -1 && (e4 = e4.substring(0, e4.indexOf("#")));
      const t3 = new URLSearchParams(e4);
      return { state: t3.get("state"), code: t3.get("code") || void 0, connect_code: t3.get("connect_code") || void 0, error: t3.get("error") || void 0, error_description: t3.get("error_description") || void 0 };
    })(e3.join(""));
    return t2.response_type === De.ConnectCode ? this._handleConnectAccountRedirectCallback(n2, t2) : this._handleLoginRedirectCallback(n2, t2);
  }
  async _handleLoginRedirectCallback(e3, t2) {
    const { code: n2, state: o2, error: a2, error_description: s2 } = e3;
    if (a2) throw new i(a2, s2 || a2, o2, t2.appState);
    if (!t2.code_verifier || t2.state && t2.state !== o2) throw new r("state_mismatch", "Invalid state");
    const c2 = t2.organization, u2 = t2.nonce, l2 = t2.redirect_uri;
    return await this._requestToken(Object.assign({ audience: t2.audience, scope: t2.scope, code_verifier: t2.code_verifier, grant_type: "authorization_code", code: n2 }, l2 ? { redirect_uri: l2 } : {}), { nonceIn: u2, organization: c2 }), { appState: t2.appState, response_type: De.Code };
  }
  async _handleConnectAccountRedirectCallback(e3, t2) {
    const { connect_code: n2, state: o2, error: i2, error_description: s2 } = e3;
    if (i2) throw new a(i2, s2 || i2, t2.connection, o2, t2.appState);
    if (!n2) throw new r("missing_connect_code", "Missing connect code");
    if (!(t2.code_verifier && t2.state && t2.auth_session && t2.redirect_uri && t2.state === o2)) throw new r("state_mismatch", "Invalid state");
    const c2 = await this.myAccountApi.completeAccount({ auth_session: t2.auth_session, connect_code: n2, redirect_uri: t2.redirect_uri, code_verifier: t2.code_verifier });
    return Object.assign(Object.assign({}, c2), { appState: t2.appState, response_type: De.ConnectCode });
  }
  async checkSession(e3) {
    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
      if (!this.cookieStorage.get("auth0.is.authenticated")) return;
      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated");
    }
    try {
      await this.getTokenSilently(e3);
    } catch (e4) {
    }
  }
  async getTokenSilently() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    var t2, n2;
    const o2 = Object.assign(Object.assign({ cacheMode: "on" }, e3), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e3.authorizationParams), { scope: fe(this.scope, null === (t2 = e3.authorizationParams) || void 0 === t2 ? void 0 : t2.scope, (null === (n2 = e3.authorizationParams) || void 0 === n2 ? void 0 : n2.audience) || this.options.authorizationParams.audience) }) }), r2 = await ((e4, t3) => {
      let n3 = Me[t3];
      return n3 || (n3 = e4().finally((() => {
        delete Me[t3], n3 = null;
      })), Me[t3] = n3), n3;
    })((() => this._getTokenSilently(o2)), "".concat(this.options.clientId, "::").concat(o2.authorizationParams.audience, "::").concat(o2.authorizationParams.scope));
    return e3.detailedResponse ? r2 : null == r2 ? void 0 : r2.access_token;
  }
  async _getTokenSilently(t2) {
    const { cacheMode: n2 } = t2, o2 = e(t2, ["cacheMode"]);
    if ("off" !== n2) {
      const e3 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId, cacheMode: n2 });
      if (e3) return e3;
    }
    if ("cache-only" === n2) return;
    const r2 = (i2 = this.options.clientId, a2 = o2.authorizationParams.audience || "default", "".concat("auth0.lock.getTokenSilently", ".").concat(i2, ".").concat(a2));
    var i2, a2;
    try {
      return await this.lockManager.runWithLock(r2, 5e3, (async () => {
        if ("off" !== n2) {
          const e4 = await this._getEntryFromCache({ scope: o2.authorizationParams.scope, audience: o2.authorizationParams.audience || "default", clientId: this.options.clientId });
          if (e4) return e4;
        }
        const e3 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o2) : await this._getTokenFromIFrame(o2), { id_token: t3, token_type: r3, access_token: i3, oauthTokenScope: a3, expires_in: s2 } = e3;
        return Object.assign(Object.assign({ id_token: t3, token_type: r3, access_token: i3 }, a3 ? { scope: a3 } : null), { expires_in: s2 });
      }));
    } catch (e3) {
      if (this._isInteractiveError(e3) && "popup" === this.options.interactiveErrorHandler) return await this._handleInteractiveErrorWithPopup(o2);
      throw e3;
    }
  }
  _isInteractiveError(e3) {
    return e3 instanceof d;
  }
  async _handleInteractiveErrorWithPopup(e3) {
    try {
      await this.loginWithPopup({ authorizationParams: e3.authorizationParams });
      const t2 = await this._getEntryFromCache({ scope: e3.authorizationParams.scope, audience: e3.authorizationParams.audience || "default", clientId: this.options.clientId });
      if (!t2) throw new r("interactive_handler_cache_miss", "Token not found in cache after interactive authentication");
      return t2;
    } catch (e4) {
      throw e4;
    }
  }
  async getTokenWithPopup() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var o2, r2;
    const i2 = Object.assign(Object.assign({}, e3), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e3.authorizationParams), { scope: fe(this.scope, null === (o2 = e3.authorizationParams) || void 0 === o2 ? void 0 : o2.scope, (null === (r2 = e3.authorizationParams) || void 0 === r2 ? void 0 : r2.audience) || this.options.authorizationParams.audience) }) });
    n2 = Object.assign(Object.assign({}, t), n2), await this.loginWithPopup(i2, n2);
    return (await this.cacheManager.get(new me({ scope: i2.authorizationParams.scope, audience: i2.authorizationParams.audience || "default", clientId: this.options.clientId }), void 0, this.options.useMrrt)).access_token;
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  _buildLogoutUrl(t2) {
    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;
    const n2 = t2.logoutParams || {}, { federated: o2 } = n2, r2 = e(n2, ["federated"]), i2 = o2 ? "&federated" : "";
    return this._url("/v2/logout?".concat(_(Object.assign({ clientId: t2.clientId }, r2)))) + i2;
  }
  async logout() {
    let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    var n2;
    const o2 = Ge(t2), { openUrl: r2 } = o2, i2 = e(o2, ["openUrl"]);
    null === t2.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t2.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove("@@user@@"), await (null === (n2 = this.dpop) || void 0 === n2 ? void 0 : n2.clear());
    const a2 = this._buildLogoutUrl(i2);
    r2 ? await r2(a2) : false !== r2 && window.location.assign(a2);
  }
  async _getTokenFromIFrame(e3) {
    const t2 = (n2 = this.options.clientId, "".concat("auth0.lock.getTokenFromIFrame", ".").concat(n2));
    var n2;
    try {
      return await this.lockManager.runWithLock(t2, 5e3, (async () => {
        const t3 = Object.assign(Object.assign({}, e3.authorizationParams), { prompt: "none" }), n3 = this.cookieStorage.get(this.orgHintCookieName);
        n3 && !t3.organization && (t3.organization = n3);
        const { url: o2, state: i2, nonce: a2, code_verifier: c2, redirect_uri: u2, scope: l2, audience: d2 } = await this._prepareAuthorizeUrl(t3, { response_mode: "web_message" }, window.location.origin);
        if (window.crossOriginIsolated) throw new r("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
        const h2 = e3.timeoutInSeconds || this.options.authorizeTimeoutInSeconds;
        let p2;
        try {
          p2 = new URL(this.domainUrl).origin;
        } catch (e4) {
          p2 = this.domainUrl;
        }
        const f2 = await (function(e4, t4) {
          let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 60;
          return new Promise(((o3, i3) => {
            const a3 = window.document.createElement("iframe");
            a3.setAttribute("width", "0"), a3.setAttribute("height", "0"), a3.style.display = "none";
            const c3 = () => {
              window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener("message", u3, false));
            };
            let u3;
            const l3 = setTimeout((() => {
              i3(new s()), c3();
            }), 1e3 * n4);
            u3 = function(e5) {
              if (e5.origin != t4) return;
              if (!e5.data || "authorization_response" !== e5.data.type) return;
              const n5 = e5.source;
              n5 && n5.close(), e5.data.response.error ? i3(r.fromPayload(e5.data.response)) : o3(e5.data.response), clearTimeout(l3), window.removeEventListener("message", u3, false), setTimeout(c3, 2e3);
            }, window.addEventListener("message", u3, false), window.document.body.appendChild(a3), a3.setAttribute("src", e4);
          }));
        })(o2, p2, h2);
        if (i2 !== f2.state) throw new r("state_mismatch", "Invalid state");
        const m2 = await this._requestToken(Object.assign(Object.assign({}, e3.authorizationParams), { code_verifier: c2, code: f2.code, grant_type: "authorization_code", redirect_uri: u2, timeout: e3.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a2, organization: t3.organization });
        return Object.assign(Object.assign({}, m2), { scope: l2, oauthTokenScope: m2.scope, audience: d2 });
      }));
    } catch (e4) {
      throw "login_required" === e4.error && this.logout({ openUrl: false }), e4;
    }
  }
  async _getTokenUsingRefreshToken(e3) {
    var t2, n2;
    const o2 = await this.cacheManager.get(new me({ scope: e3.authorizationParams.scope, audience: e3.authorizationParams.audience || "default", clientId: this.options.clientId }), void 0, this.options.useMrrt);
    if (!(o2 && o2.refresh_token || this.worker)) {
      if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e3);
      throw new h(e3.authorizationParams.audience || "default", e3.authorizationParams.scope);
    }
    const r2 = e3.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, i2 = "number" == typeof e3.timeoutInSeconds ? 1e3 * e3.timeoutInSeconds : null, a2 = ((e4, t3, n3, o3) => {
      var r3;
      if (e4 && n3 && o3) {
        if (t3.audience !== n3) return t3.scope;
        const e5 = o3.split(" "), i3 = (null === (r3 = t3.scope) || void 0 === r3 ? void 0 : r3.split(" ")) || [], a3 = i3.every(((t4) => e5.includes(t4)));
        return e5.length >= i3.length && a3 ? o3 : t3.scope;
      }
      return t3.scope;
    })(this.options.useMrrt, e3.authorizationParams, null == o2 ? void 0 : o2.audience, null == o2 ? void 0 : o2.scope);
    try {
      const t3 = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e3.authorizationParams), { grant_type: "refresh_token", refresh_token: o2 && o2.refresh_token, redirect_uri: r2 }), i2 && { timeout: i2 }), { scopesToRequest: a2 });
      if (t3.refresh_token && (null == o2 ? void 0 : o2.refresh_token) && await this.cacheManager.updateEntry(o2.refresh_token, t3.refresh_token), this.options.useMrrt) {
        if (s2 = null == o2 ? void 0 : o2.audience, c2 = null == o2 ? void 0 : o2.scope, u2 = e3.authorizationParams.audience, l2 = e3.authorizationParams.scope, s2 !== u2 || !Ze(l2, c2)) {
          if (!Ze(a2, t3.scope)) {
            if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e3);
            await this.cacheManager.remove(this.options.clientId, e3.authorizationParams.audience, e3.authorizationParams.scope);
            const n3 = ((e4, t4) => {
              const n4 = (null == e4 ? void 0 : e4.split(" ")) || [], o3 = (null == t4 ? void 0 : t4.split(" ")) || [];
              return n4.filter(((e5) => -1 == o3.indexOf(e5))).join(",");
            })(a2, t3.scope);
            throw new p(e3.authorizationParams.audience || "default", n3);
          }
        }
      }
      return Object.assign(Object.assign({}, t3), { scope: e3.authorizationParams.scope, oauthTokenScope: t3.scope, audience: e3.authorizationParams.audience || "default" });
    } catch (o3) {
      if (o3.message) {
        if (o3.message.includes("user is blocked")) throw await this.logout({ openUrl: false }), o3;
        if ((o3.message.includes("Missing Refresh Token") || o3.message.includes("invalid refresh token")) && this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e3);
      }
      throw o3 instanceof d && this.mfa.setMFAAuthDetails(o3.mfa_token, null === (t2 = e3.authorizationParams) || void 0 === t2 ? void 0 : t2.scope, null === (n2 = e3.authorizationParams) || void 0 === n2 ? void 0 : n2.audience, o3.mfa_requirements), o3;
    }
    var s2, c2, u2, l2;
  }
  async _saveEntryInCache(t2) {
    const { id_token: n2, decodedToken: o2 } = t2, r2 = e(t2, ["id_token", "decodedToken"]);
    this.userCache.set("@@user@@", { id_token: n2, decodedToken: o2 }), await this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken), await this.cacheManager.set(r2);
  }
  async _getIdTokenFromCache() {
    const e3 = this.options.authorizationParams.audience || "default", t2 = this.scope[e3], n2 = await this.cacheManager.getIdToken(new me({ clientId: this.options.clientId, audience: e3, scope: t2 })), o2 = this.userCache.get("@@user@@");
    return n2 && n2.id_token === (null == o2 ? void 0 : o2.id_token) ? o2 : (this.userCache.set("@@user@@", n2), n2);
  }
  async _getEntryFromCache(e3) {
    let { scope: t2, audience: n2, clientId: o2, cacheMode: r2 } = e3;
    const i2 = await this.cacheManager.get(new me({ scope: t2, audience: n2, clientId: o2 }), 60, this.options.useMrrt, r2);
    if (i2 && i2.access_token) {
      const { token_type: e4, access_token: t3, oauthTokenScope: n3, expires_in: o3 } = i2, r3 = await this._getIdTokenFromCache();
      return r3 && Object.assign(Object.assign({ id_token: r3.id_token, token_type: e4 || "Bearer", access_token: t3 }, n3 ? { scope: n3 } : null), { expires_in: o3 });
    }
  }
  async _requestToken(e3, t2) {
    var n2, o2;
    const { nonceIn: r2, organization: i2, scopesToRequest: a2 } = t2 || {}, s2 = await de(Object.assign(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs, useMrrt: this.options.useMrrt, dpop: this.dpop }, e3), { scope: a2 || e3.scope }), this.worker), c2 = await this._verifyIdToken(s2.id_token, r2, i2);
    if ("authorization_code" === e3.grant_type) {
      const e4 = await this._getIdTokenFromCache();
      (null === (o2 = null === (n2 = null == e4 ? void 0 : e4.decodedToken) || void 0 === n2 ? void 0 : n2.claims) || void 0 === o2 ? void 0 : o2.sub) && e4.decodedToken.claims.sub !== c2.claims.sub && (await this.cacheManager.clear(this.options.clientId), this.userCache.remove("@@user@@"));
    }
    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, s2), { decodedToken: c2, scope: e3.scope, audience: e3.audience || "default" }), s2.scope ? { oauthTokenScope: s2.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgHint(i2 || c2.claims.org_id), Object.assign(Object.assign({}, s2), { decodedToken: c2 });
  }
  async loginWithCustomTokenExchange(e3) {
    return this._requestToken(Object.assign(Object.assign({}, e3), { grant_type: "urn:ietf:params:oauth:grant-type:token-exchange", subject_token: e3.subject_token, subject_token_type: e3.subject_token_type, scope: fe(this.scope, e3.scope, e3.audience || this.options.authorizationParams.audience), audience: e3.audience || this.options.authorizationParams.audience, organization: e3.organization || this.options.authorizationParams.organization }));
  }
  async exchangeToken(e3) {
    return this.loginWithCustomTokenExchange(e3);
  }
  _assertDpop(e3) {
    if (!e3) throw new Error("`useDpop` option must be enabled before using DPoP.");
  }
  getDpopNonce(e3) {
    return this._assertDpop(this.dpop), this.dpop.getNonce(e3);
  }
  setDpopNonce(e3, t2) {
    return this._assertDpop(this.dpop), this.dpop.setNonce(e3, t2);
  }
  generateDpopProof(e3) {
    return this._assertDpop(this.dpop), this.dpop.generateProof(e3);
  }
  createFetcher() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Qe(e3, { isDpopEnabled: () => !!this.options.useDpop, getAccessToken: (e4) => {
      var t2;
      return this.getTokenSilently({ authorizationParams: { scope: null === (t2 = null == e4 ? void 0 : e4.scope) || void 0 === t2 ? void 0 : t2.join(" "), audience: null == e4 ? void 0 : e4.audience }, detailedResponse: true });
    }, getDpopNonce: () => this.getDpopNonce(e3.dpopNonceId), setDpopNonce: (t2) => this.setDpopNonce(t2, e3.dpopNonceId), generateDpopProof: (e4) => this.generateDpopProof(e4) });
  }
  async connectAccountWithRedirect(e3) {
    const { openUrl: t2, appState: n2, connection: o2, scopes: r2, authorization_params: i2, redirectUri: a2 = this.options.authorizationParams.redirect_uri || window.location.origin } = e3;
    if (!o2) throw new Error("connection is required");
    const s2 = g(w()), c2 = w(), u2 = await k(c2), l2 = E(u2), { connect_uri: d2, connect_params: h2, auth_session: p2 } = await this.myAccountApi.connectAccount({ connection: o2, scopes: r2, redirect_uri: a2, state: s2, code_challenge: l2, code_challenge_method: "S256", authorization_params: i2 });
    this.transactionManager.create({ state: s2, code_verifier: c2, auth_session: p2, redirect_uri: a2, appState: n2, connection: o2, response_type: De.ConnectCode });
    const f2 = new URL(d2);
    f2.searchParams.set("ticket", h2.ticket), t2 ? await t2(f2.toString()) : window.location.assign(f2);
  }
  async _requestTokenForMfa(t2, n2) {
    const { mfaToken: o2 } = t2, r2 = e(t2, ["mfaToken"]);
    return this._requestToken(Object.assign(Object.assign({}, r2), { mfa_token: o2 }), n2);
  }
};
var initialAuthState = {
  isAuthenticated: false,
  isLoading: true,
  error: void 0,
  user: void 0
};
var stub = function() {
  throw new Error("You forgot to wrap your component in <Auth0Provider>.");
};
var initialContext = __assign(__assign({}, initialAuthState), { buildAuthorizeUrl: stub, buildLogoutUrl: stub, getAccessTokenSilently: stub, getAccessTokenWithPopup: stub, getIdTokenClaims: stub, loginWithCustomTokenExchange: stub, exchangeToken: stub, loginWithRedirect: stub, loginWithPopup: stub, connectAccountWithRedirect: stub, logout: stub, handleRedirectCallback: stub, getDpopNonce: stub, setDpopNonce: stub, generateDpopProof: stub, createFetcher: stub, getConfiguration: stub, mfa: {
  getAuthenticators: stub,
  enroll: stub,
  challenge: stub,
  verify: stub,
  getEnrollmentFactors: stub
} });
var Auth0Context = (0, import_react.createContext)(initialContext);
var OAuthError = (
  /** @class */
  (function(_super) {
    __extends(OAuthError2, _super);
    function OAuthError2(error, error_description) {
      var _this = _super.call(this, error_description !== null && error_description !== void 0 ? error_description : error) || this;
      _this.error = error;
      _this.error_description = error_description;
      Object.setPrototypeOf(_this, OAuthError2.prototype);
      return _this;
    }
    return OAuthError2;
  })(Error)
);
var CODE_RE = /[?&](?:connect_)?code=[^&]+/;
var STATE_RE = /[?&]state=[^&]+/;
var ERROR_RE = /[?&]error=[^&]+/;
var hasAuthParams = function(searchParams) {
  if (searchParams === void 0) {
    searchParams = window.location.search;
  }
  return (CODE_RE.test(searchParams) || ERROR_RE.test(searchParams)) && STATE_RE.test(searchParams);
};
var normalizeErrorFn = function(fallbackMessage) {
  return function(error) {
    if (error instanceof Error) {
      return error;
    }
    if (error !== null && typeof error === "object" && "error" in error && typeof error.error === "string") {
      if ("error_description" in error && typeof error.error_description === "string") {
        var e_1 = error;
        return new OAuthError(e_1.error, e_1.error_description);
      }
      var e3 = error;
      return new OAuthError(e3.error);
    }
    return new Error(fallbackMessage);
  };
};
var loginError = normalizeErrorFn("Login failed");
var tokenError = normalizeErrorFn("Get access token failed");
var deprecateRedirectUri = function(options) {
  var _a, _b;
  if (options === null || options === void 0 ? void 0 : options.redirectUri) {
    console.warn("Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version");
    options.authorizationParams = (_a = options.authorizationParams) !== null && _a !== void 0 ? _a : {};
    options.authorizationParams.redirect_uri = options.redirectUri;
    delete options.redirectUri;
  }
  if ((_b = options === null || options === void 0 ? void 0 : options.authorizationParams) === null || _b === void 0 ? void 0 : _b.redirectUri) {
    console.warn("Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version");
    options.authorizationParams.redirect_uri = options.authorizationParams.redirectUri;
    delete options.authorizationParams.redirectUri;
  }
};
var reducer = function(state, action) {
  switch (action.type) {
    case "LOGIN_POPUP_STARTED":
      return __assign(__assign({}, state), { isLoading: true });
    case "LOGIN_POPUP_COMPLETE":
    case "INITIALISED":
      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user, isLoading: false, error: void 0 });
    case "HANDLE_REDIRECT_COMPLETE":
    case "GET_ACCESS_TOKEN_COMPLETE":
      if (state.user === action.user) {
        return state;
      }
      return __assign(__assign({}, state), { isAuthenticated: !!action.user, user: action.user });
    case "LOGOUT":
      return __assign(__assign({}, state), { isAuthenticated: false, user: void 0 });
    case "ERROR":
      return __assign(__assign({}, state), { isLoading: false, error: action.error });
  }
};
var toAuth0ClientOptions = function(opts) {
  deprecateRedirectUri(opts);
  return __assign(__assign({}, opts), { auth0Client: {
    name: "auth0-react",
    version: "2.15.0"
  } });
};
var defaultOnRedirectCallback = function(appState) {
  var _a;
  window.history.replaceState({}, document.title, (_a = appState.returnTo) !== null && _a !== void 0 ? _a : window.location.pathname);
};
var Auth0Provider = function(opts) {
  var children = opts.children, skipRedirectCallback = opts.skipRedirectCallback, _a = opts.onRedirectCallback, onRedirectCallback = _a === void 0 ? defaultOnRedirectCallback : _a, _b = opts.context, context = _b === void 0 ? Auth0Context : _b, clientOpts = __rest(opts, ["children", "skipRedirectCallback", "onRedirectCallback", "context"]);
  var client = (0, import_react.useState)(function() {
    return new ra(toAuth0ClientOptions(clientOpts));
  })[0];
  var _c = (0, import_react.useReducer)(reducer, initialAuthState), state = _c[0], dispatch = _c[1];
  var didInitialise = (0, import_react.useRef)(false);
  var handleError = (0, import_react.useCallback)(function(error) {
    dispatch({ type: "ERROR", error });
    return error;
  }, []);
  (0, import_react.useEffect)(function() {
    if (didInitialise.current) {
      return;
    }
    didInitialise.current = true;
    (function() {
      return __awaiter(void 0, void 0, void 0, function() {
        var user, _a2, _b2, appState, response_type, result, error_1;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              _c2.trys.push([0, 7, , 8]);
              user = void 0;
              if (!(hasAuthParams() && !skipRedirectCallback)) return [3, 3];
              return [4, client.handleRedirectCallback()];
            case 1:
              _a2 = _c2.sent(), _b2 = _a2.appState, appState = _b2 === void 0 ? {} : _b2, response_type = _a2.response_type, result = __rest(_a2, ["appState", "response_type"]);
              return [4, client.getUser()];
            case 2:
              user = _c2.sent();
              appState.response_type = response_type;
              if (response_type === De.ConnectCode) {
                appState.connectedAccount = result;
              }
              onRedirectCallback(appState, user);
              return [3, 6];
            case 3:
              return [4, client.checkSession()];
            case 4:
              _c2.sent();
              return [4, client.getUser()];
            case 5:
              user = _c2.sent();
              _c2.label = 6;
            case 6:
              dispatch({ type: "INITIALISED", user });
              return [3, 8];
            case 7:
              error_1 = _c2.sent();
              handleError(loginError(error_1));
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    })();
  }, [client, onRedirectCallback, skipRedirectCallback, handleError]);
  var loginWithRedirect = (0, import_react.useCallback)(function(opts2) {
    deprecateRedirectUri(opts2);
    return client.loginWithRedirect(opts2);
  }, [client]);
  var loginWithPopup = (0, import_react.useCallback)(function(options, config) {
    return __awaiter(void 0, void 0, void 0, function() {
      var error_2, user;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            dispatch({ type: "LOGIN_POPUP_STARTED" });
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, client.loginWithPopup(options, config)];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            error_2 = _a2.sent();
            handleError(loginError(error_2));
            return [
              2
              /*return*/
            ];
          case 4:
            return [4, client.getUser()];
          case 5:
            user = _a2.sent();
            dispatch({ type: "LOGIN_POPUP_COMPLETE", user });
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [client, handleError]);
  var logout = (0, import_react.useCallback)(function() {
    var args_1 = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args_1[_i2] = arguments[_i2];
    }
    return __awaiter(void 0, __spreadArray([], args_1, true), void 0, function(opts2) {
      if (opts2 === void 0) {
        opts2 = {};
      }
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, client.logout(opts2)];
          case 1:
            _a2.sent();
            if (opts2.openUrl || opts2.openUrl === false) {
              dispatch({ type: "LOGOUT" });
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [client]);
  var getAccessTokenSilently = (0, import_react.useCallback)(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function(opts2) {
      return __awaiter(void 0, void 0, void 0, function() {
        var token, error_3, _a2;
        var _b2;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              _c2.trys.push([0, 2, 3, 5]);
              return [4, client.getTokenSilently(opts2)];
            case 1:
              token = _c2.sent();
              return [3, 5];
            case 2:
              error_3 = _c2.sent();
              throw tokenError(error_3);
            case 3:
              _a2 = dispatch;
              _b2 = {
                type: "GET_ACCESS_TOKEN_COMPLETE"
              };
              return [4, client.getUser()];
            case 4:
              _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);
              return [
                7
                /*endfinally*/
              ];
            case 5:
              return [2, token];
          }
        });
      });
    },
    [client]
  );
  var getAccessTokenWithPopup = (0, import_react.useCallback)(function(opts2, config) {
    return __awaiter(void 0, void 0, void 0, function() {
      var token, error_4, _a2;
      var _b2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            _c2.trys.push([0, 2, 3, 5]);
            return [4, client.getTokenWithPopup(opts2, config)];
          case 1:
            token = _c2.sent();
            return [3, 5];
          case 2:
            error_4 = _c2.sent();
            throw tokenError(error_4);
          case 3:
            _a2 = dispatch;
            _b2 = {
              type: "GET_ACCESS_TOKEN_COMPLETE"
            };
            return [4, client.getUser()];
          case 4:
            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [2, token];
        }
      });
    });
  }, [client]);
  var connectAccountWithRedirect = (0, import_react.useCallback)(function(options) {
    return client.connectAccountWithRedirect(options);
  }, [client]);
  var getIdTokenClaims = (0, import_react.useCallback)(function() {
    return client.getIdTokenClaims();
  }, [client]);
  var loginWithCustomTokenExchange = (0, import_react.useCallback)(function(options) {
    return __awaiter(void 0, void 0, void 0, function() {
      var tokenResponse, error_5, _a2;
      var _b2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            _c2.trys.push([0, 2, 3, 5]);
            return [4, client.loginWithCustomTokenExchange(options)];
          case 1:
            tokenResponse = _c2.sent();
            return [3, 5];
          case 2:
            error_5 = _c2.sent();
            throw tokenError(error_5);
          case 3:
            _a2 = dispatch;
            _b2 = {
              type: "GET_ACCESS_TOKEN_COMPLETE"
            };
            return [4, client.getUser()];
          case 4:
            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [2, tokenResponse];
        }
      });
    });
  }, [client]);
  var exchangeToken = (0, import_react.useCallback)(function(options) {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        return [2, loginWithCustomTokenExchange(options)];
      });
    });
  }, [loginWithCustomTokenExchange]);
  var handleRedirectCallback = (0, import_react.useCallback)(function(url) {
    return __awaiter(void 0, void 0, void 0, function() {
      var error_6, _a2;
      var _b2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            _c2.trys.push([0, 2, 3, 5]);
            return [4, client.handleRedirectCallback(url)];
          case 1:
            return [2, _c2.sent()];
          case 2:
            error_6 = _c2.sent();
            throw tokenError(error_6);
          case 3:
            _a2 = dispatch;
            _b2 = {
              type: "HANDLE_REDIRECT_COMPLETE"
            };
            return [4, client.getUser()];
          case 4:
            _a2.apply(void 0, [(_b2.user = _c2.sent(), _b2)]);
            return [
              7
              /*endfinally*/
            ];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [client]);
  var getDpopNonce = (0, import_react.useCallback)(function(id) {
    return client.getDpopNonce(id);
  }, [client]);
  var setDpopNonce = (0, import_react.useCallback)(function(nonce, id) {
    return client.setDpopNonce(nonce, id);
  }, [client]);
  var generateDpopProof = (0, import_react.useCallback)(function(params) {
    return client.generateDpopProof(params);
  }, [client]);
  var createFetcher = (0, import_react.useCallback)(function(config) {
    return client.createFetcher(config);
  }, [client]);
  var getConfiguration = (0, import_react.useCallback)(function() {
    return client.getConfiguration();
  }, [client]);
  var mfa = (0, import_react.useMemo)(function() {
    return client.mfa;
  }, [client]);
  var contextValue = (0, import_react.useMemo)(function() {
    return __assign(__assign({}, state), { getAccessTokenSilently, getAccessTokenWithPopup, getIdTokenClaims, loginWithCustomTokenExchange, exchangeToken, loginWithRedirect, loginWithPopup, connectAccountWithRedirect, logout, handleRedirectCallback, getDpopNonce, setDpopNonce, generateDpopProof, createFetcher, getConfiguration, mfa });
  }, [
    state,
    getAccessTokenSilently,
    getAccessTokenWithPopup,
    getIdTokenClaims,
    loginWithCustomTokenExchange,
    exchangeToken,
    loginWithRedirect,
    loginWithPopup,
    connectAccountWithRedirect,
    logout,
    handleRedirectCallback,
    getDpopNonce,
    setDpopNonce,
    generateDpopProof,
    createFetcher,
    getConfiguration,
    mfa
  ]);
  return import_react.default.createElement(context.Provider, { value: contextValue }, children);
};
var useAuth0 = function(context) {
  if (context === void 0) {
    context = Auth0Context;
  }
  return (0, import_react.useContext)(context);
};
var withAuth0 = function(Component, context) {
  if (context === void 0) {
    context = Auth0Context;
  }
  return function WithAuth(props) {
    return import_react.default.createElement(context.Consumer, null, function(auth) {
      return import_react.default.createElement(Component, __assign({}, props, { auth0: auth }));
    });
  };
};
var defaultOnRedirecting = function() {
  return import_react.default.createElement(import_react.default.Fragment, null);
};
var defaultOnBeforeAuthentication = function() {
  return __awaiter(void 0, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [
        2
        /*return*/
      ];
    });
  });
};
var defaultReturnTo = function() {
  return "".concat(window.location.pathname).concat(window.location.search);
};
var withAuthenticationRequired = function(Component, options) {
  if (options === void 0) {
    options = {};
  }
  return function WithAuthenticationRequired(props) {
    var _this = this;
    var _a = options.returnTo, returnTo = _a === void 0 ? defaultReturnTo : _a, _b = options.onRedirecting, onRedirecting = _b === void 0 ? defaultOnRedirecting : _b, _c = options.onBeforeAuthentication, onBeforeAuthentication = _c === void 0 ? defaultOnBeforeAuthentication : _c, loginOptions = options.loginOptions, _d = options.context, context = _d === void 0 ? Auth0Context : _d;
    var _e2 = useAuth0(context), isAuthenticated = _e2.isAuthenticated, isLoading = _e2.isLoading, loginWithRedirect = _e2.loginWithRedirect;
    (0, import_react.useEffect)(function() {
      if (isLoading || isAuthenticated) {
        return;
      }
      var opts = __assign(__assign({}, loginOptions), { appState: __assign(__assign({}, loginOptions === null || loginOptions === void 0 ? void 0 : loginOptions.appState), { returnTo: typeof returnTo === "function" ? returnTo() : returnTo }) });
      void (function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, onBeforeAuthentication()];
              case 1:
                _a2.sent();
                return [4, loginWithRedirect(opts)];
              case 2:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      })();
    }, [
      isLoading,
      isAuthenticated,
      loginWithRedirect,
      onBeforeAuthentication,
      loginOptions,
      returnTo
    ]);
    return isAuthenticated ? import_react.default.createElement(Component, __assign({}, props)) : onRedirecting();
  };
};
export {
  Auth0Context,
  Auth0Provider,
  i as AuthenticationError,
  a as ConnectError,
  r as GenericError,
  we as InMemoryCache,
  ye as LocalStorageCache,
  $i as MfaChallengeError,
  Qi as MfaEnrollmentError,
  ta as MfaEnrollmentFactorsError,
  Xi as MfaError,
  Yi as MfaListAuthenticatorsError,
  d as MfaRequiredError,
  ea as MfaVerifyError,
  h as MissingRefreshTokenError,
  OAuthError,
  u as PopupCancelledError,
  l as PopupOpenError,
  c as PopupTimeoutError,
  De as ResponseType,
  s as TimeoutError,
  f as UseDpopNonceError,
  Ke as User,
  initialContext,
  useAuth0,
  withAuth0,
  withAuthenticationRequired
};
//# sourceMappingURL=@auth0_auth0-react.js.map
